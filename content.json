{"meta":{"title":"Nan's Blog","subtitle":"弱者才言命，强者只言运！","description":"克己复礼","author":"马亮南生","url":""},"pages":[{"title":"分类","date":"2018-12-06T11:48:02.000Z","updated":"2018-12-10T08:59:19.994Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-06T11:46:40.000Z","updated":"2018-12-10T08:58:50.994Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据迁移","slug":"数据迁移","date":"2020-07-17T06:11:46.000Z","updated":"2020-07-17T08:42:44.925Z","comments":true,"path":"2020/07/17/数据迁移/","link":"","permalink":"/2020/07/17/数据迁移/","excerpt":"","text":"cp 是在本机进行拷贝不能跨服务器 scp 是secure copy的简写，用于在Linux下进行远程拷贝文件的命令， scp传输是加密的，可能会稍微影响一下速度，当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来，另 外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了，虽然 rsync比scp会快一点，但当小文件众多的情况 下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用 rsync 迁移单个没有太多小文件的数时比scp优秀，速度快 scp命令rsync命令rsync的参数说明 -v 详细输出 -z 传输时进行压缩以提高传输效率。 -a 归档模式，表示以递归的方式传输文件，并保持文件的属性 –exclude 排除不需要同步传输的文件或者目录 –delete 让目标目录和源目录的数据一致 –bwlimit 限制带宽，默认单位是：kb（案例：某DBA做数据同步，导致用户无法访问网站） –info=progress2 给出了一个很好的整体进度百分比（局部值） 无密码通过ssh执行rsync默认情况下，在执行rsync命令时通常需要我们输入密码。但有时我们并不希望如此，那么如何实现无密码执行rsync呢？ 需要密码 测试通过ssh可以执行rsync（需要密码） 执行rsync，确保你帐户的密码在远程服务器上可以使用，并能够将文件复制到远程服务器。例：将原服务器文件/root/mm.sh同步到远程目录/usr/share/nginx/html(服务器地址：172.18.195.253) ，执行此操作时，服务器会要求你输入密码 1rsync -avz --info=progress2 /root/mm.sh 172.18.195.253:/usr/share/nginx/html 免密 使用ssh-keygen生成密匙 现在我们来配置ssh使得通过ssh执行rsync时不再索要密码。在原服务器上使用ssh-keygen生成公钥和秘钥。 12345678$ ssh-keygenGenerating public/private rsa key pair.# 直接回车Enter file in which to save the key (/root/.ssh/id_rsa):# 直接回车Enter passphrase (empty for no passphrase):# 直接回车Enter same passphrase again: 注意：当它要求您输入passphrase按下enter键，不需要给任何密码 使用ssh-copy-id将公匙拷贝至远程主机 12# ip 就是目标服务器地址ssh-copy-id -i ~/.ssh/id_rsa.pub 172.18.195.253 注：执行以上操作时会要求你输入远程主机帐户和密码，然后就会自动将公钥拷贝至远程目录。 无需密码通过ssh来执行rsync 现在，你可以不需要密码通过ssh连接到远程主机 1ssh 172.18.195.253 再次执行rsync，它将不再要求你输入密码 1rsync -avz --info=progress2 /root/mm.sh 172.18.195.253:/usr/share/nginx/html","categories":[{"name":"远程拷贝","slug":"远程拷贝","permalink":"/categories/远程拷贝/"}],"tags":[{"name":"rsync","slug":"rsync","permalink":"/tags/rsync/"}]},{"title":"值得推荐的idea优秀插件","slug":"值得推荐的idea优秀插件","date":"2020-07-13T07:52:13.000Z","updated":"2020-07-13T10:03:33.471Z","comments":true,"path":"2020/07/13/值得推荐的idea优秀插件/","link":"","permalink":"/2020/07/13/值得推荐的idea优秀插件/","excerpt":"","text":"LombokLombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。 idea下载安装插件 在使用之前需要添加一下依赖： 1234567&lt;!-- Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; POJO类常用注解 @Getter/@Setter： 作用类上，生成所有成员变量的getter/setter方法；作用于成员变量上，生成该成员变量的getter/setter方法。可以设定访问权限及是否懒加载等 @ToString：作用于类，覆盖默认的toString()方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段 @EqualsAndHashCode：作用于类，覆盖默认的equals和hashCode @NonNull：主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常 @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor：作用于类上，用于生成构造函数。有staticName、access等属性 - (staticName属性一旦设定，将采用静态方法的方式生成实例，access属性可以限定访问权限) @NoArgsConstructor：生成无参构造器 @RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器 @AllArgsConstructor：生成全参构造器 @Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor @Builder：作用于类上，将类转变为建造者模式 @Log：作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解 其他重要注解 @Cleanup：自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 @SneakyThrows：可以对受检异常进行捕捉并抛出 @Synchronized：作用于方法级别，可以替换synchronize关键字或lock锁，用处不大 MybatisXMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生 功能 Java 与 XML 调回跳转 Mapper 方法自动生成 XML 计划支持 连接数据源之后 xml 里自动提示字段 sql 增删改查 集成 MP 代码生成 其他 Alibaba Java Coding Guidelines一款阿里巴巴公司试行的开发设计规范~ Bug的严重程度、优先级如何定义 Blocker： 即系统无法执行、崩溃或严重资源不足、应用模块无法启动或异常退出、无法测试、造成系统不稳定。严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃/死机/冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其它导致无法测试的错误, 如服务器500错误 Critical：即影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。功能未实现、功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误、安全性问题 Major：即界面、性能缺陷、兼容性。操作界面错误（包括数据窗口内列名定义、含义是否一致）、边界条件下错误、提示信息错误（包括未给出信息、信息提示错误等）、长时间操作无进度提示、系统未优化（性能问题）、光标跳转设置不好，鼠标（光标）定位错误、兼容性问题 Minor/Trivial：即易用性及建议性问题。界面格式等不规范、辅助说明描述不清楚、操作时未给用户提示、可输入区域和只读区域没有明显的区分标志、个别不影响产品理解的错别字、文字排列不整齐等一些小问题 犹如神助的功能阿里规范插件实时检查你书写的代码，并在右侧实时给出警告，警告也是汉字的！！ 处理注：以下处理方式仅限Blocker，其他还需要自己手动修正 快捷键：Ait + Enter 自动补全（注：Windows 快捷键） 扫描结果面板，点击按钮自动补全 stackoverflow这个插件其实是最实用的插件，程序猿遇到的问题，基本都能找到回答，但是它使用的是google搜索引擎，对于，不购买vpn的同学来说，感觉好鸡肋呀~ 选中需要搜索的问题，然后，右键点击查询 - 用StackoverFlow搜索的话个人觉得比用google 更精准","categories":[{"name":"IDEA","slug":"IDEA","permalink":"/categories/IDEA/"}],"tags":[{"name":"插件","slug":"插件","permalink":"/tags/插件/"}]},{"title":"南生论坛页面静态展示v2.8.2","slug":"南生论坛页面静态展示v2-8-2","date":"2020-07-08T13:34:33.000Z","updated":"2020-07-13T06:15:33.313Z","comments":true,"path":"2020/07/08/南生论坛页面静态展示v2-8-2/","link":"","permalink":"/2020/07/08/南生论坛页面静态展示v2-8-2/","excerpt":"","text":"注：以下截图是v2.8.2的界面样子 功能说明南生论坛v2.8.2在v2.6的基础上： 对前后端代码和数据库表进行了全面重构，新增了闲聊，图片/视频文件压缩并上七牛云，优化系统，提升访问效率，新增轮播图管理、项目管理，运用了Redis缓存技术 适用人员南生论坛v2.8.2该版本适用于对ssm框架有一定熟悉度、对代码规范度要求比较高、对图片/视频文件上云有兴趣的童鞋使用，主要可以通过该项目了解整个项目的设计思路（让心怀大志、无从下手的你找到突破口） 优势南生论坛v2.8.2注释十分详细、逻辑清晰、界面简洁美观、功能较完善、ECharts图表化展示、人机交互、异步加载、分页加载、统计记录、相册相片、支持Markdown、支持QQ分享文章、文章显示更加合理化（首页等展示文章的缩略信息-可以提高文章的展示数量；新增文章详情页面-有利于读者专心于该文章而不被其它信息干扰）、新增闲聊、图片/视频文件上云、新增轮播图管理、新增项目管理、Redis缓存技术、代码冗余度较低、命名规范 缺点前后端未分离 用户系统-展示登录 image 注册 image 首页 image 写文章 image 修改文章 image 文章详情 image 闲聊 image 毒鸡汤 image 个人主页 image 他人主页 image 编辑个人资料 image 基本信息设置 image 修改头像 image 动态 image 回答 image 关注 image 收藏 image 相册 image 有照片的相册 image 无照片的相册 image 管理系统-展示登录 image 仪表盘 image 用户管理 image 文章管理 image 版块管理 image 版本管理 image 轮播管理 image 项目管理 image 访问记录 image","categories":[{"name":"南生论坛","slug":"南生论坛","permalink":"/categories/南生论坛/"}],"tags":[{"name":"展示","slug":"展示","permalink":"/tags/展示/"}]},{"title":"Java图片处理的几种方式","slug":"Java图片处理的几种方式","date":"2020-05-30T11:39:28.000Z","updated":"2020-06-01T07:56:05.817Z","comments":true,"path":"2020/05/30/Java图片处理的几种方式/","link":"","permalink":"/2020/05/30/Java图片处理的几种方式/","excerpt":"","text":"Maven依赖： 12345678910111213141516171819202122&lt;!-- 文件上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 时间操作组件 --&gt;&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 一、本地Java实现把图片上传到本地 配置文件path.properties配置如下： 123456789101112131415# 文件保存公共路径data.store.local=/home/***/data# 文章图片（题图）articlePath=article# 文章图片（配图）illustrationPath=illustration# 用户头像userPath=user# 用户相册photoPath=photo# 允许上传的文件后缀名，不包含\".\"#data.store.local.suffix=png,jpg,jpegdata.store.local.suffix=* 调用ArticleController.java的内容： 1234567891011121314151617181920212223@RequestMapping(\"/api/rest/nanshengbbs/v3.0/article\")@Controllerpublic class ArticleController &#123; @Autowired FileUploadUtil fileUploadUtil; @Autowired PathUtil pathUtil; @PostMapping(\"/setArticle\") @ResponseBody public ReturnT&lt;?&gt; setArticle(@RequestParam(value = \"picture\", required = false)) &#123; try &#123; // 保存文件 String newFileName = fileUploadUtil.save(file, pathUtil.getArticlePath()); return ReturnT.success(\"发布文章成功\"); &#125; catch (Exception e) &#123; logger.error(\"发布文章失败\"); return ReturnT.fail(\"发布文章失败\"); &#125; &#125;&#125;// 结果：文件保存到C:\\home\\nanshengbbs\\data\\article 或者 /home/nanshengbbs/data/article 工具类FileUploadUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import org.apache.commons.io.FileUtils;import org.apache.commons.io.FilenameUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import org.springframework.web.multipart.MultipartFile;import javax.annotation.PostConstruct;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.file.Paths;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;@PropertySource(&#123;\"classpath:path.properties\"&#125;)@Componentpublic class FileUploadUtil &#123; private static Logger logger = LoggerFactory.getLogger(FileUploadUtil.class); // 文件存储根路径 @Value(\"$&#123;data.store.local&#125;\") private String rootPath; // 允许上传的文件后缀名 @Value(\"$&#123;data.store.local.suffix&#125;\") private String suffix; private List&lt;String&gt; suffixList = null; @PostConstruct private void init()&#123; if (StringUtil.isNotEmpty(suffix))&#123; suffixList = Stream.of(suffix.split(\"(, *)+\")) .map(s -&gt; s.trim().toLowerCase()).collect(Collectors.toList()); &#125; &#125; /** * 保存文件 * @param file 源文件 * @param folder 文件夹名称（介于前者与后者之间） * @return */ public String save(MultipartFile file, String folder)&#123; String orginalName = file.getOriginalFilename(); if (checkFile(orginalName))&#123; // 检查文件后缀名 // 构造存储文件名 String fileName = generateFileName(orginalName); // 构造目标文件路径 String targetPath = generateStorePath(folder, fileName); // 保存文件到指定目录 String path = storeData(targetPath, file); logger.info(\"已保存文件：\" + path); return path; &#125; else &#123; logger.info(\"不支持上传该类型的文件：\" + orginalName); return null; &#125; &#125; /** * 删除文件 * @param fulPath 全路径 */ public static void del(String fulPath)&#123; // 封装上传文件位置的全路径 File targetFile = new File(fulPath); // 删除文章对应的图片（实际删除） targetFile.delete(); &#125; /** * 构造存储文件名 * @param orginalName 原始文件名 * @return 返回新的文件名 */ public String generateFileName(String orginalName)&#123; return DateUtil.getNowDate() + \"_\" + orginalName;//“上传时间_文件名” &#125; /** * 构造目标文件路径 * @param folder 文件夹名称（介于前者与后者之间） * @param fileName 文件名 * @return 目标文件路径 */ public String generateStorePath(String folder, String fileName)&#123; return Paths.get(rootPath, folder, fileName).toString(); &#125; /** * 保存文件到指定目录 * @param path 目标目录 * @param file 文件 * @return */ public String storeData(String path, MultipartFile file)&#123; File stored = new File(path); try (InputStream in = file.getInputStream();)&#123; FileUtils.copyInputStreamToFile(in, stored); return stored.getCanonicalPath(); &#125; catch (IOException e) &#123; logger.error(e.getMessage(), e); return null; &#125; &#125; /** * 检查文件后缀名 * @param fileName 文件名 * @return 通过检查为true，不通过为false */ public boolean checkFile(String fileName)&#123; if (suffixList.size() == 1 &amp;&amp; suffixList.get(0).equals(\"*\"))&#123; return true; &#125; String ext = FilenameUtils.getExtension(fileName); return suffixList.contains(ext.toLowerCase()); &#125;&#125; StringUtil.java12345678910111213141516171819public class StringUtil &#123; /** * 字符串为空 * @param data * @return */ public static boolean isEmpty(String data)&#123; return data == null || \"\".equals(data); &#125; /** * 字符串不为空 * @param data * @return */ public static boolean isNotEmpty(String data)&#123; return !isEmpty(data); &#125;&#125; PathUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@PropertySource(&#123;\"classpath:path.properties\"&#125;)@Componentpublic class PathUtil &#123; // 文章图片（题图） @Value(\"$&#123;articlePath&#125;\") private String articlePath; // 文章图片（配图） @Value(\"$&#123;illustrationPath&#125;\") private String illustrationPath; // 用户头像 @Value(\"$&#123;userPath&#125;\") private String userPath; // 用户相册 @Value(\"$&#123;photoPath&#125;\") private String photoPath; public String getArticlePath() &#123; return articlePath; &#125; public void setArticlePath(String articlePath) &#123; this.articlePath = articlePath; &#125; public String getIllustrationPath() &#123; return illustrationPath; &#125; public void setIllustrationPath(String illustrationPath) &#123; this.illustrationPath = illustrationPath; &#125; public String getUserPath() &#123; return userPath; &#125; public void setUserPath(String userPath) &#123; this.userPath = userPath; &#125; public String getPhotoPath() &#123; return photoPath; &#125; public void setPhotoPath(String photoPath) &#123; this.photoPath = photoPath; &#125;&#125; 二、图片服务器Java实现把图片上传到图片服务器(nginx+vsftp) nginx搭建参考：搭建http服务器-nginx vsftp搭建参考：Vsftp安装与配置 配置文件path.properties配置如下： 12345678910111213141516171819# ftp相关配置ftp.address=*.*.*.*ftp.port=21ftp.username=ftpuserftp.password=******# 文件保存公共路径data.store.local=/home/ftpuser/***/data# 图片服务器相关配置image.base.url=http://*.nanshengbbs.top/***/data# 文章图片（题图）articlePath=article# 文章图片（配图）illustrationPath=illustration# 用户头像userPath=user# 用户相册photoPath=photo 调用ArticleController.java的内容： 123456789101112131415161718192021222324252627@RequestMapping(\"/api/rest/nanshengbbs/v3.0/article\")@Controllerpublic class ArticleController &#123; @Autowired FtpUtil ftpUtil; @Autowired PathUtil pathUtil; @PostMapping(\"/setArticle\") @ResponseBody public ReturnT&lt;?&gt; setArticle(@RequestParam(value = \"picture\", required = false)) &#123; try &#123; // 构造文件名 String fileName = UUIDUtil.getRandomUUID() + file.getOriginalFilename() .substring(file.getOriginalFilename().lastIndexOf(\".\")); // 调用FtpUtil工具类进行上传 String newFileName = ftpUtil.uploadFile(pathUtil.getArticlePath(), fileName, file.getInputStream()); return ReturnT.success(\"发布文章成功\"); &#125; catch (Exception e) &#123; logger.error(\"发布文章失败\"); return ReturnT.fail(\"发布文章失败\"); &#125; &#125;&#125;// 结果：文件保存到（/home/ftpuser/nanshengbbs/data/article） 工具类FtpUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import org.apache.commons.net.ftp.FTP;import org.apache.commons.net.ftp.FTPClient;import org.apache.commons.net.ftp.FTPReply;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import java.io.IOException;import java.io.InputStream;import java.nio.file.Paths;@PropertySource(&#123;\"classpath:path.properties\"&#125;)@Componentpublic class FtpUtil &#123; // FTP服务器ip @Value(\"$&#123;ftp.address&#125;\") private String host; // FTP服务器端口 @Value(\"$&#123;ftp.port&#125;\") private int port; // FTP登录账号 @Value(\"$&#123;ftp.username&#125;\") private String username; // FTP登录密码 @Value(\"$&#123;ftp.password&#125;\") private String password; // FTP服务器基础目录（/home/ftpuser/nanshengbbs/data） @Value(\"$&#123;data.store.local&#125;\") private String basePath; // 图片服务器相关配置 @Value(\"$&#123;image.base.url&#125;\") private String imageUrl; /** * 向FTP服务器上传文件 * @param filePath FTP服务器文件存放路径。例如文章配图：/article。 * 文件的路径为basePath+filePath * @param fileName 上传到FTP服务器上的文件名 * @param input 输入流 * @return 成功返回图片访问的全路径，否则返回null */ public String uploadFile(String filePath, String fileName, InputStream input) &#123; String result = null; FTPClient ftp = new FTPClient(); try &#123; // 连接FTP服务器（如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器） ftp.connect(host, port); // 登录 ftp.login(username, password); // 获取应答code int reply = ftp.getReplyCode(); // 判断是否成功连接（成功：200 &lt;= n &lt;= 300） if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return result; &#125; // 切换到上传目录 if (!ftp.changeWorkingDirectory(Paths.get(basePath, filePath).toString())) &#123; // 如果目录不存在创建目录 String[] dirs = filePath.split(\"/\"); String tempPath = basePath; for (String dir : dirs) &#123; if (null == dir || \"\".equals(dir)) continue; tempPath += \"/\" + dir; if (!ftp.changeWorkingDirectory(tempPath)) &#123; if (!ftp.makeDirectory(tempPath)) &#123; return result; &#125; else &#123; ftp.changeWorkingDirectory(tempPath); &#125; &#125; &#125; &#125; /** * 一定要加上ftp.enterLocalPassiveMode()设置被动模式，否则的话会出现图片传到服务器上去 * 了，但是大小一直是0。这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通 * 一个端口来传输数据。为什么要这样做呢，因为ftp server可能每次开启不同的端口来传输数据，但 * 是在linux上或者其他服务器上面，由于安全限制，可能某些端口没有开启，所以就出现阻塞。 */ // 设置为被动模式 ftp.enterLocalPassiveMode(); // 设置上传文件的类型为二进制类型 ftp.setFileType(FTP.BINARY_FILE_TYPE); // 去中文 fileName = CommonUtil.getRemoveChinese(fileName); // 上传文件 if (!ftp.storeFile(fileName, input)) &#123; return result; &#125; result = imageUrl + \"/\" + filePath + \"/\" + fileName; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; input.close(); ftp.logout(); if (ftp.isConnected()) &#123; ftp.disconnect(); &#125; &#125; catch (Exception e) &#123;&#125; &#125; System.out.println(result); return result; &#125;&#125; 三、第三方Java实现把图片上传到七牛云对象存储 七牛官网：https://developer.qiniu.com/ 对象存储Java SDK：https://developer.qiniu.com/kodo/sdk/1239/java 配置文件76.properties配置如下： 123# 配置你自己七牛云对应的AccessKey和SecretKeyAccessKey=**************************************SecretKey==************************************** path.properties配置如下： 12# 七牛对象存储对应的域名76.image.domain=http://*.nanshengbbs.top 调用ArticleController.java的内容： 12345678910111213141516171819202122232425@RequestMapping(\"/api/rest/nanshengbbs/v3.0/article\")@Controllerpublic class ArticleController &#123; @Autowired FtpUtil ftpUtil; @Autowired PathUtil pathUtil; @PostMapping(\"/setArticle\") @ResponseBody public ReturnT&lt;?&gt; setArticle(@RequestParam(value = \"picture\", required = false)) &#123; try &#123; // 构造文件名 String fileName = UUIDUtil.getRandomUUID() + file.getOriginalFilename(); // 上传到七牛 String newFileName = QiniuUtil.upload(file.getInputStream(), fileName); return ReturnT.success(\"发布文章成功\"); &#125; catch (Exception e) &#123; logger.error(\"发布文章失败\"); return ReturnT.fail(\"发布文章失败\"); &#125; &#125;&#125;// 结果：文件保存到（七牛云-&gt;对象存储-&gt;文件管理） 工具类QiniuUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import com.google.gson.Gson;import com.qiniu.http.Response;import com.qiniu.storage.Configuration;import com.qiniu.storage.Region;import com.qiniu.storage.UploadManager;import com.qiniu.storage.model.DefaultPutRet;import com.qiniu.util.Auth;import java.io.IOException;import java.io.InputStream;public class QiniuUtil &#123; // 需要操作的账号的AK和SK private static final String ACCESS_KEY = PropertyUtil.getProperties76().getProperty(\"AccessKey\"); private static final String SECRET_KEY = PropertyUtil.getProperties76().getProperty(\"SecretKey\"); // 要上传的空间 private static final String bucket = \"nanshengbbs\"; // 密钥 private static final Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); private static final String upToken = auth.uploadToken(bucket); // 构造一个带指定 Region 对象的配置类（华南） private static final Configuration cfg = new Configuration(Region.huanan()); // 创建上传对象 private static final UploadManager uploadManager = new UploadManager(cfg); /** * 普通上传（上传本地文件） * @param localFilePath 文件全路径 * @param fileName 七牛保存的文件名 * @throws IOException */ public static String upload(String localFilePath, String fileName) throws Exception &#123; // 调用put方法上传 Response res = uploadManager.put(localFilePath, fileName, upToken); // 解析上传成功的结果 DefaultPutRet putRet = new Gson() .fromJson(res.bodyString(), DefaultPutRet.class); return putRet.key; &#125; /** * 字节数组上传 * @param uploadBytes 文件字节数组 * @param fileName 七牛保存的文件名 * @throws IOException */ public static String upload(byte[] uploadBytes, String fileName) throws Exception &#123; // 调用put方法上传 Response res = uploadManager.put(uploadBytes, fileName, upToken); // 解析上传成功的结果 DefaultPutRet putRet = new Gson() .fromJson(res.bodyString(), DefaultPutRet.class); return putRet.key; &#125; /** * 数据流上传 * @param inputStream 文件数据流 * @param fileName 七牛保存的文件名 * @throws IOException */ public static String upload(InputStream inputStream, String fileName) throws Exception &#123; // 调用put方法上传 Response res = uploadManager.put(inputStream, fileName, upToken, null, null); // 解析上传成功的结果 DefaultPutRet putRet = new Gson() .fromJson(res.bodyString(), DefaultPutRet.class); return putRet.key; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Java图片处理","slug":"Java图片处理","permalink":"/tags/Java图片处理/"}]},{"title":"Vsftp安装与配置","slug":"Vsftp安装与配置","date":"2020-05-28T06:53:33.000Z","updated":"2020-05-29T02:20:35.927Z","comments":true,"path":"2020/05/28/Vsftp安装与配置/","link":"","permalink":"/2020/05/28/Vsftp安装与配置/","excerpt":"","text":"简单参见：https://www.jianshu.com/p/1527af1c372c 版本vsftpd: version 3.0.2、CentOS7 FTP传输模式文件传输协议（File Transfer Protocol，FTP），基于该协议FTP客户端与服务端可以实现共享文件、上传文件、下载文件。FTP基于C/S模式，FTP客户端与服务器端有两种传输模式，分别是FTP主动模式、FTP被动模式。主被动模式均是以FTP服务器端为参照。 FTP主动模式：客户端从一个任意的端口N（N&gt;1024）连接到FTP服务器的port 21命令端口，客户端开始监听端口N+1，并发送FTP命令“port N+1”到FTP服务器，FTP服务器以数据端口（20）连接到客户端指定的数据端口（N+1） FTP被动模式：客户端从一个任意的端口N（N&gt;1024）连接到FTP服务器的port 21命令端口，客户端开始监听端口N+1，客户端提交 PASV命令，服务器会开启一个任意的端口（P &gt;1024），并发送PORT P命令给客户端。客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据 在企业实际环境中，如果FTP客户端与FTP服务端均开放防火墙，FTP需以主动模式工作，这样只需要在FTP服务器端防火墙规则中，开放20、21端口即可。 安装在linux环境下，使用最多的FTP服务端软件就是Vsftpd 1yum -y install vsftpd 添加ftp用户1useradd ftpuser 给ftp用户添加密码12passwd ftpuser# 输入两次密码后修改密码 修改selinux可能遇到的问题： 1234567891011# 出现以下错误setenforce: SELinux is disabled# 解决方法说明selinux已经被彻底的关闭了如果需要重新开启selinux，请按下面步骤：vi /etc/selinux/config更改为：SELINUX=1#必须重启linux，不重启是没办法立刻开启selinux的 继续 12345678910111213141516171819202122# 查看状态getsebool -a | grep ftp# 结果：ftpd_anon_write --&gt; offftpd_connect_all_unreserved --&gt; offftpd_connect_db --&gt; offftpd_full_access --&gt; offftpd_use_cifs --&gt; offftpd_use_fusefs --&gt; offftpd_use_nfs --&gt; offftpd_use_passive_mode --&gt; offhttpd_can_connect_ftp --&gt; offhttpd_enable_ftp_server --&gt; offtftp_anon_write --&gt; offtftp_home_dir --&gt; off# 这两个都offftpd_full_access --&gt; offtftp_home_dir --&gt; off# 执行如下命令设置为on:setsebool -P ftpd_full_access onsetsebool -P tftp_home_dir on 再次执行getsebool -a | grep ftp看到那两个状态是on就行了 关闭匿名访问12345678vi /etc/vsftpd/vsftpd.conf# 默认是YES，改成NOanonymous_enable=NO# 继续在vsftp.conf文件【最下面】添加以下内容：（作用是设置FTP被动模式使用的端口范围）pasv_min_port=30000pasv_max_port=60999 然后保存退出即可 开启端口1234567# 打开20 21端口firewall-cmd --zone=public --add-port=20/tcp --permanentfirewall-cmd --zone=public --add-port=21/tcp --permanent# 打开上面FTP被动模式设置的端口firewall-cmd --zone=public --add-port=30000-60999/tcp --permanentfirewall-cmd --reloadfirewall-cmd --list-all 设置开机启动123systemctl enable vsftpd# 或者chkconfig vsftpd on 启动服务123systemctl start vsftpd# 或者service vsftpd start 测试打开filezilla工具，输入虚拟机的ip，20/21端口（不填也行，默认就是20/21），用户名和密码，点击快速连接，连接vsftp服务: 如图所示则连接成功。 配置nginx为图片服务器按照以上步骤安装好nginx和vsftp后，还是不能访问上传的图片的，需要进行如下配置: 1vi /etc/nginx/nginx.conf 按道理这样就可以了，但是我访问却报错:403 forbidden，最后发现是因为ftpuser文件夹没有可读权限，执行如下命令: 12# 授予普通用户文件夹及其子文件夹读写权限chmod -R 777 /home/ftpuser 再次访问即可成功！ 配置配置文件说明 /etc/vsftpd/vsftpd.conf这个文件是vsftpd服务的核心配置文件！我们在修改配置文件的时候，最好先备份一份！ 1cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak 我们先来了解一下里边可以配置的大致内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# 是否允许匿名登录FTP服务器，默认设置为YES允许# 用户可使用用户名ftp或anonymous进行ftp登录，口令为用户的E-mail地址。# 如不允许匿名访问则设置为NOanonymous_enable=YES# 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许# 本地用户登录后会进入用户主目录，而匿名用户登录后进入匿名用户的下载目录/var/ftp/pub# 若只允许匿名用户访问，前面加上#注释掉即可阻止本地用户访问FTP服务器local_enable=YES# 是否允许本地用户对FTP服务器文件具有写权限，默认设置为YES允许write_enable=YES# 掩码，本地用户默认掩码为077# 你可以设置本地用户的文件掩码为缺省022，也可根据个人喜好将其设置为其他值local_umask=022# 是否允许匿名用户上传文件，须将全局的write_enable=YES。默认为YES#anon_upload_enable=YES# 是否允许匿名用户创建新文件夹#anon_mkdir_write_enable=YES # 是否激活目录欢迎信息功能# 当用户用CMD模式首次访问服务器上某个目录时，FTP服务器将显示欢迎信息# 默认情况下，欢迎信息是通过该目录下的.message文件获得的# 此文件保存自定义的欢迎信息，由用户自己建立dirmessage_enable=YES# 是否让系统自动维护上传和下载的日志文件# 默认情况该日志文件为/var/log/vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定# 默认值为NOxferlog_enable=YES# Make sure PORT transfer connections originate from port 20 (ftp-data).# 是否设定FTP服务器将启用FTP数据端口的连接请求# ftp-data数据传输，21为连接控制端口connect_from_port_20=YES# 设定是否允许改变上传文件的属主，与下面一个设定项配合使用# 注意，不推荐使用root用户上传文件#chown_uploads=YES# 设置想要改变的上传文件的属主，如果需要，则输入一个系统用户名# 可以把上传的文件都改成root属主。whoever：任何人#chown_username=whoever# 设定系统维护记录FTP服务器上传和下载情况的日志文件# /var/log/vsftpd.log是默认的，也可以另设其它#xferlog_file=/var/log/vsftpd.log# 是否以标准xferlog的格式书写传输日志文件# 默认为/var/log/xferlog，也可以通过xferlog_file选项对其进行设定# 默认值为NOxferlog_std_format=YES# 以下是附加配置，添加相应的选项将启用相应的设置# 是否生成两个相似的日志文件# 默认在/var/log/xferlog和/var/log/vsftpd.log目录下# 前者是wu_ftpd类型的传输日志，可以利用标准日志工具对其进行分析；后者是vsftpd类型的日志#dual_log_enable# 是否将原本输出到/var/log/vsftpd.log中的日志，输出到系统日志#syslog_enable# 设置数据传输中断间隔时间，此语句表示空闲的用户会话中断时间为600秒# 即当数据传输结束后，用户连接FTP服务器的时间不应超过600秒。可以根据实际情况对该值进行修改#idle_session_timeout=600# 设置数据连接超时时间，该语句表示数据连接超时时间为120秒，可根据实际情况对其个修改#data_connection_timeout=120# 运行vsftpd需要的非特权系统用户，缺省是nobody#nopriv_user=ftpsecure# 是否识别异步ABOR请求。# 如果FTP client会下达“async ABOR”这个指令时，这个设定才需要启用# 而一般此设定并不安全，所以通常将其取消#async_abor_enable=YES# 是否以ASCII方式传输数据。默认情况下，服务器会忽略ASCII方式的请求。# 启用此选项将允许服务器以ASCII方式传输数据# 不过，这样可能会导致由\"SIZE /big/file\"方式引起的DoS攻击#ascii_upload_enable=YES#ascii_download_enable=YES# 登录FTP服务器时显示的欢迎信息# 如有需要，可在更改目录欢迎信息的目录下创建名为.message的文件，并写入欢迎信息保存后#ftpd_banner=Welcome to blah FTP service.# 黑名单设置。如果很讨厌某些email address，就可以使用此设定来取消他的登录权限# 可以将某些特殊的email address抵挡住。#deny_email_enable=YES# 当上面的deny_email_enable=YES时，可以利用这个设定项来规定哪些邮件地址不可登录vsftpd服务器# 此文件需用户自己创建，一行一个email address即可#banned_email_file=/etc/vsftpd/banned_emails# 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限# 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件# 必须与下面的设置项配合#chroot_list_enable=YES# 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录# 从而有利于FTP服务器的安全管理和隐私保护。此文件需自己建立#chroot_list_file=/etc/vsftpd/chroot_list# 是否允许递归查询。默认为关闭，以防止远程用户造成过量的I/O#ls_recurse_enable=YES# 是否允许监听。# 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求listen=NO# 设定是否支持IPV6。如要同时监听IPv4和IPv6端口，# 则必须运行两套vsftpd，采用两套配置文件# 同时确保其中有一个监听选项是被注释掉的listen_ipv6=YES# 设置PAM外挂模块提供的认证服务所使用的配置文件名，即/etc/pam.d/vsftpd文件# 此文件中file=/etc/vsftpd/ftpusers字段，说明了PAM模块能抵挡的帐号内容来自文件/etc/vsftpd/ftpusers中pam_service_name=vsftpd# 是否允许ftpusers文件中的用户登录FTP服务器，默认为NO# 若此项设为YES，则user_list文件中的用户允许登录FTP服务器# 而如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器，甚至连输入密码提示信息都没有userlist_enable=YES# 是否使用tcp_wrappers作为主机访问控制方式。tcp_wrappers=YES /etc/vsftpd/ftpusers这个文件是禁止使用vsftpd的用户列表文件。记录不允许访问FTP服务器的用户名单，管理员可以把一些对系统安全有威胁的用户账号记录在此文件中，以免用户从FTP登录后获得大于上传下载操作的权利，而对系统造成损坏 /etc/vsftpd/user_list这个文件禁止或允许使用vsftpd的用户列表文件。这个文件中指定的用户缺省情况（即在/etc/vsftpd/vsftpd.conf中设置userlist_deny=YES）下也不能访问FTP服务器，在设置了userlist_deny=NO时,仅允许user_list中指定的用户访问FTP服务器 复杂参见：https://blog.csdn.net/aiynmimi/article/details/77012507","categories":[{"name":"vsftp","slug":"vsftp","permalink":"/categories/vsftp/"}],"tags":[{"name":"搭建","slug":"搭建","permalink":"/tags/搭建/"}]},{"title":"判断日期是工作日周末还是节假日","slug":"判断日期是工作日周末还是节假日","date":"2020-05-18T07:02:45.000Z","updated":"2020-05-18T11:48:15.056Z","comments":true,"path":"2020/05/18/判断日期是工作日周末还是节假日/","link":"","permalink":"/2020/05/18/判断日期是工作日周末还是节假日/","excerpt":"","text":"要实现该功能需要两步第一步，配置“班”和“休”由于每年“班”和“休”对应的日期都不一样（依据：国务院办公厅关于2020年部分节假日安排的通知），没法做到完全自动化，必须手动配置 我们将“班”和“休的日期分别配置到/data目录下的2020_w.txt和2020.txt文件： 2020_w.txt（班） 123456011904260509062809271010 2020.txt（休） 123456789101112131415161718192021222324252627282930010101240125012601270128012901300131020102020404040504060501050205030504050506250626062710011002100310041005100610071008 如何快速查看某天是“班”还是“休” 第二步，功能代码废话不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.io.*;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;/** * 判断日期是工作日周末还是节假日 * 工作日对应结果为 0, 节假日对应的结果为 1, 周末（周六、日）对应结果为 2 */public class ChineseHolidayUtil &#123; private static DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); // 存放“休”和“班”的日期key和对应不同的value（0=班、1=休） private final static Map&lt;Date, Integer&gt; holidayBuffer = new HashMap&lt;&gt;(); // 存放文件全路径（包含文件名） private final static List&lt;File&gt; dataPath = new ArrayList&lt;&gt;(); // data文件夹的全路径（data下存放配置好的“班”和“休”的文件） private final static String storDataPath = \"**/common/data\"; // 初始化holidayBuffer static &#123; getFilePath(new File(storDataPath)); if (dataPath.size() != 0) &#123; // 存放每一行的数据 String temp = \"\"; for (File f : dataPath) &#123; try &#123; BufferedReader reader = new BufferedReader(new FileReader(f)); while ((temp = reader.readLine()) != null) &#123; if (!temp.equals(\"\\n\")) &#123; if (f.getName().matches(\"[2][0][2][0-9]_w.txt\")) // 班 holidayBuffer.put(holidayToDate(f, temp), 0); else if(f.getName().matches(\"[2][0][2][0-9].txt\")) // 休 holidayBuffer.put(holidayToDate(f, temp), 1); &#125; &#125; reader.close(); &#125; catch (IOException | ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 判断某一天是否是周末 * @param d * @return */ private static boolean isWeekend(Date d) &#123; Calendar cal = Calendar.getInstance(); cal.setTime(d); return (cal.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || cal.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY); &#125; /** * 将路径下的所有文件“全路径”添加到“dataPath” * @param file */ private static void getFilePath (File file) &#123; if(file.isDirectory())&#123; File f[]= file.listFiles(); if(f!=null)&#123; for (File aF : f) &#123; getFilePath(aF); &#125; &#125; &#125; else &#123; dataPath.add(file); &#125; &#125; /** * 构造（拼接）日期（格式：yyyy-MM-dd） * @param f * @param s * @return * @throws ParseException */ private static Date holidayToDate(File f, String s) throws ParseException &#123; String fileName = f.getName(); return format.parse(fileName.split(\"\\\\_|\\\\.\")[0] + \"-\" + s.substring(0,2) + \"-\" + s.substring(2)); &#125; /** * 获取某天是什么日子（工作日、节日、周末） * @param d 日期 * @return 0工作日 1节日 2周末 */ public static Integer getHoliday(Date d) &#123; System.out.println(d); if (holidayBuffer.containsKey(d)) &#123; return holidayBuffer.get(d); &#125; else &#123; return isWeekend(d) ? 2 : 0; &#125; &#125; // 测试一手 public static void main(String[] args) throws ParseException &#123; System.out.println(getHoliday(format.parse(format.format(new Date())))); &#125;&#125; 完！","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"判断某天是工作日周末还是节假日","slug":"判断某天是工作日周末还是节假日","permalink":"/tags/判断某天是工作日周末还是节假日/"}]},{"title":"安装Licode","slug":"安装Licode","date":"2020-02-11T03:37:42.000Z","updated":"2020-02-13T01:44:38.597Z","comments":true,"path":"2020/02/11/安装Licode/","link":"","permalink":"/2020/02/11/安装Licode/","excerpt":"","text":"准备环境操作系统ubuntu18.04 LTS（root登录，否则手动给权限sudo） 克隆Licode代码您首先需要从github克隆我们的代码。 您需要在计算机中安装git 1sudo apt-get install git 现在克隆存储库并进入licode/文件夹（也可以先在本地下载好传输到服务器） 12git clone https://github.com/ging/licode.gitcd licode 下面使用的所有脚本都包含在从github克隆的代码中 安装依赖项 现在，您需要安装一些依赖项才能使用Licode 12# 前提：需要安装git./scripts/installUbuntuDeps.sh 安装Licode此步骤将安装所有Licode组件。 这些组件是：Erizo，Erizo API，Erizo Controller和Nuve 123456789101112# 前提：需要安装conanapt install python3-pippip3 install conan## 安装erizo./scripts/installErizo.sh# 前提：需要安装Cmake、mongodbapt install cmakeapt install mongodb-clientsapt install mongodb-server-core## 安装nuve./scripts/installNuve.sh 安装基本示例 此步骤将安装一个基本的测试示例 1./scripts/installBasicExample.sh 测试Licode 目前，您已经在计算机中安装了Licode和一个基本的视频会议示例以对其进行测试。让我们运行它们 12345# 此步骤将初始化所有Licode组件./scripts/initLicode.sh# 此步骤将初始化基本示例./scripts/initBasicExample.sh 现在，您可以连接到“ localhost:3001”并测试您的基本视频会议示例！","categories":[{"name":"Licode","slug":"Licode","permalink":"/categories/Licode/"}],"tags":[{"name":"安装","slug":"安装","permalink":"/tags/安装/"}]},{"title":"南生论坛页面静态展示v2.6","slug":"南生论坛页面静态展示v2-6","date":"2020-01-06T13:34:33.000Z","updated":"2020-04-14T03:42:34.476Z","comments":true,"path":"2020/01/06/南生论坛页面静态展示v2-6/","link":"","permalink":"/2020/01/06/南生论坛页面静态展示v2-6/","excerpt":"","text":"注：以下截图是v2.6的界面样子 功能说明南生论坛v2.6在v2.0的基础上：支持Markdown、新增分享功能、新增文章详情页面、首页文章显示简约化 适用人员南生论坛v2.6该版本适用于初学ssm框架、对jQuery和ajax有一定熟悉度、并且想以Markdown形式写文章的童鞋使用，主要可以通过该项目了解整个项目的设计思路（让心怀大志、无从下手的你找到突破口） 优势南生论坛v2.6注释十分详细、逻辑清晰、界面简洁美观、功能较完善、ECharts图表化展示、人机交互、异步加载、分页加载、统计记录、相册相片、支持Markdown、支持QQ分享文章、文章显示更加合理化（首页等展示文章的缩略信息-可以提高文章的展示数量；新增文章详情页面-有利于读者专心于该文章而不被其它信息干扰） 缺点代码冗余度较高、命名不是很规范 用户系统-展示登录 image 手机上的效果： 注册 image 手机上的效果： 首页-登录前 image 手机上的效果： 首页-登录后 image 手机上的效果： 写文章 image 手机上的效果： 修改文章 image 手机上的效果： 文章详情 image 手机上的效果： 个人主页 image 手机上的效果： 他人主页 image 手机上的效果： 编辑个人资料 image 手机上的效果： 基本信息设置 image 手机上的效果： 修改头像 image 手机上的效果： 动态 image 手机上的效果： 回答 image 手机上的效果： 关注 image 手机上的效果： 收藏 image 手机上的效果： 相册 image 手机上的效果： 有照片的相册 image 手机上的效果： 无照片的相册 image 手机上的效果： 管理员系统-展示登录 image 初始页面 image 用户管理 image 文章管理 image 版块管理 image 访问记录 image","categories":[{"name":"南生论坛","slug":"南生论坛","permalink":"/categories/南生论坛/"}],"tags":[{"name":"展示","slug":"展示","permalink":"/tags/展示/"}]},{"title":"南生论坛页面静态展示","slug":"南生论坛页面静态展示","date":"2019-12-19T01:20:43.000Z","updated":"2020-04-14T03:42:19.013Z","comments":true,"path":"2019/12/19/南生论坛页面静态展示/","link":"","permalink":"/2019/12/19/南生论坛页面静态展示/","excerpt":"","text":"注：以下截图是v1.0和v2.0的界面样子 功能说明南生论坛v1.0登录【用户系统】可以：发帖、修改帖子、删除帖子、评论、删除评论、修改个人信息、关注、收藏登录【管理系统】可以：管理用户、管理帖子、管理板块、访问记录 南生论坛v2.0在v1.0的基础上：整体异步实现、新增统计饼图、优化人机交互、实现分页、实现相册功能、实现月周日访问记录（方便管理员了解该论坛的访问情况） 适用人员南生论坛v1.0该版本适用于初学ssm框架的童鞋，主要可以通过该项目了解整个项目的设计思路（让心怀大志、无从下手的你找到突破口） 南生论坛v2.0该版本适用于初学ssm框架、并且对jQuery和ajax有一定熟悉度的童鞋使用，主要可以通过该项目了解整个项目的设计思路（让心怀大志、无从下手的你找到突破口） 优势南生论坛v1.0注释十分详细、逻辑清晰、界面简洁美观、功能较完善 南生论坛v2.0注释十分详细、逻辑清晰、界面简洁美观、功能较完善、ECharts图表化展示、人机交互、异步加载、分页加载、统计记录、相册相片 缺点代码冗余度较高、命名不是很规范 用户系统-展示登录 image 手机上的效果： 注册 image 手机上的效果： 首页-登录前 image 手机上的效果： 首页-登录后 image 手机上的效果： 发帖 image 手机上的效果： 个人主页 image 手机上的效果： 编辑个人资料 image 手机上的效果： 基本信息设置 image 手机上的效果： 修改头像 image 手机上的效果： 动态 image 手机上的效果： 回答 image 手机上的效果： 关注 image 手机上的效果： 收藏 image 手机上的效果： 相册 image 手机上的效果： 有照片的相册 image 手机上的效果： 无照片的相册 image 手机上的效果： 管理员系统-展示登录 image 初始页面 image 用户管理 image 帖子管理 image 版块管理 image 访问记录 image","categories":[{"name":"南生论坛","slug":"南生论坛","permalink":"/categories/南生论坛/"}],"tags":[{"name":"展示","slug":"展示","permalink":"/tags/展示/"}]},{"title":"Chrome插件","slug":"Chrome插件","date":"2019-11-26T06:25:24.000Z","updated":"2019-11-26T06:32:26.695Z","comments":true,"path":"2019/11/26/Chrome插件/","link":"","permalink":"/2019/11/26/Chrome插件/","excerpt":"","text":"完全引用：https://zhaoolee.com/ChromeAppHeroes/ 目录 061《ImageAssistant》图片助手批量图片下载器 060《Tabagotchi》为减缓全球变暖做出贡献 059《PageSpeed Insight and CheckList》为网页优化提供建议和量化指标 058《IP-Address》快速查看当前设备IP 057《图片另存为JPG/PNG/WebP》让WebP图片下载为PNG格式 056《Search》为Chrome设置搜索引擎关键词 055《Keylines》为网页元素添加随机描边颜色 | 备用链接 054《二箱 以图搜图》让你在搜图方面随心所欲（为所欲为） 053《鼠标点击特效 (๑•́ ∀ •̀๑)》为鼠标点击添加有趣的特效 052《Site Palette》自动提取网站配色 051《Custom Cursor for Chrome™》为Chrome换上可爱初音光标 050《Google Results Previewer》无点击查看谷歌搜索结果 049《Web Server for Chrome》搭建本地Web服务器, 实现局域网共享文件夹 048《Words Discoverer》高亮标注单词,提升你的词汇量 047《Go to Tab》快速跳转到打开的网页 046《WhatFont》字体爱好者优雅查看网页字体 045《Restlet Client》优秀的Api测试工具 044《谷歌访问助手》访问Chrome商店 Gmail 谷歌搜索 043《Dream Afar New Tab》探索世界的新方式 042 在Edge中安装Chrome扩展程序 041《Copy All Urls》优雅地保存-开启多个标签页 040《GitZip for github》从Github批量下载表情包 039《Simplify Gmail》让网页版Gmail更清爽 038《Alexa Traffic Rank》一键查看网站全球排名 037《Saladict》谷歌!有道!我全都要! 聚合词典, 并行翻译 036《Screen Shader》把网页调成暖色，你的眼睛会感谢你🙏 035《Print Friendly &amp; PDF》让你拥有最佳的打印阅读体验 034《Astro Bot》用新标签页刷编程题 033《一叶》在任意网页开启实时弹幕 聊天窗口 留言板 032《Smallpdf》简单好用的线上PDF工具 031《OneTab》把多个Tab转换为一个列表 030《掘金》相信优质技术内容的力量 029 《SimpRead》为任意网页开启阅读模式 028《AdBlock》Adblock自定义屏蔽简书广告 027《Text》来自Chrome实验室的跨平台记事本 026《Quickey Launcher》打开网站只需一键 025《Console》Chrome自带好用的计算器 024《Dark Reader》为任意网站启用夜间模式 023《FireShot》一键滚动截屏整个网页 022《扩展管理器》管理你的Chrome扩展 021《哔哩哔哩助手》助你快速成为B站老司机 020《Boxel Rebound》“嗨到中毒”的弹跳小方块(附自制赛道分享方法) 019《MEGA》网盘可以良心到什么程度? 试试MEGA吧! 018《Enhanced Github》从“冰柜”到“冰棍儿”,下载Github单个文件 017《新浪微博图床》本地Markdown编写更流畅, 新浪微博图床来帮忙 016《解除B站区域限制》查看进击的巨人第三季 015 《XPath Helper》完成Bing每日壁纸的小爬虫 014《超级马里奥游戏》Chrome变身小霸王 013《Quick QR》用二维码实现云粘贴 012《OurStickys》Chrome特色网页便签纸 011 《whatruns》一键分析网站技术栈 010《speedtest》网络测速插件speedtest 009《vimium》Chrome与vim双神器融合 008《Chrome Cleaner Pro》为Chrome加速 007《loom》 Chrome翻录网页视频神器 006《SimilarSites》 一键查找姊妹网站 SimilarSites 005《Video Speed Controller》 刷课（刷剧）神器！给网页视频加个速(最快可达16倍!) 004《Tampermonkey》 油猴子! 给浏览器开个挂 003《Secure Shell App》 Chrome中开启ssh一种什么体验 002《chrono》 让Chrome下载资源更容易 001《markdown-here》 Markdown一键转换到”富文本格式”","categories":[{"name":"Chrome插件","slug":"Chrome插件","permalink":"/categories/Chrome插件/"}],"tags":[{"name":"Chrome插件","slug":"Chrome插件","permalink":"/tags/Chrome插件/"}]},{"title":"Hexo - Next 主题添加评论功能","slug":"Hexo-Next-主题添加评论功能","date":"2019-11-05T03:07:09.000Z","updated":"2019-11-05T03:59:46.659Z","comments":true,"path":"2019/11/05/Hexo-Next-主题添加评论功能/","link":"","permalink":"/2019/11/05/Hexo-Next-主题添加评论功能/","excerpt":"","text":"Hexo 的 Next 主题继承了多种评论系统，我在这里介绍两种个人觉得不错的评论系统：Valine 和 gitment Valine 评论系统本博客使用的评论系统 参考：Hexo: 添加Valine评论(邮件通知、评论列表头像) ​ Valine - 一款快速、简洁且高效的无后端评论系统 使用 Valine 评论系统，这款系统不需要登录便可以登录，没有后端，Next 主题最新已经支持安装 基于 Leancloud 的系统 支持 MarkDown 语法 无后端实现，快速高效 注册 LeanCloud因为 Valine 是基于 LeanCloud 系统的，所以先在 LeanCloud 中注册账号 LeanCloud官网登录入口 注册登陆后，访问控制台，创建应用（需要实名验证），选择开发版，创建好之后就生成了 App ID 和 App Key 设置 Next 主题在主题的配置文件中，修改关于 valine 的配置 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 是否开启 appid: # 上一步获取的 App ID appkey: # 上一步获取的 App Key notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: monsterid # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 #默认单页的留言条数 avatar可选默认头像： 评论管理如果想要管理评论，进入 leancloud 官网，找到 控制台-&gt;存储-&gt;commet 中进行管理 Gitment 评论系统gitment，它是基于 github 开发的，是依靠于 GitHub Issues 的评论系统，Next 主题最新已经支持安装 前提：更新 Next 主题（5.1.2 主题） 注册OAuth application 在 github 中进行注册，进入 https://github.com/settings/profile 点击左侧 Developer settings Register a new application 1234Application name: #应用名称Homepage URL： #网站URL(填自己的博客主页地址)Application description #描述Authorization callback URL: #网站URL(填自己的博客主页地址) 注册完成之后，会得到：Client ID 和 Client Secret 新建存放博客评论仓库可以在 github 中建一个项目，专门用来存储你的博客评论 配置 next 主题文件编辑主题配置文件：themes\\next\\ _config.yml，找到有关 gitment 的设置 12345678910111213gitment: enable: true mint: true count: true lazy: false #评论懒加载，如果true，则默认不展示评论，点击按钮查看评论 cleanly: false language: github_user: #github名称 github_repo: BlogComments #上一步新建存放评论的仓库名 client_id: b8bad0exxxx #上面注册 OAuth Application 的 Client ID client_secret: bcee560xxxxxx #上面注册 OAuth Application 申请的 Client Secret proxy_gateway: redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint 初始化 在设置完成之后，hexo 重新部署 每篇文章都要点击初始化评论按钮 评论评论显示在新建存放评论的仓库中的 issue 中 关闭某个页面的评论在页面的 Front-matter 中添加 comments 字段，设为 false 比如标签页不想要评论，则在标签页面中做以下设置 12345title: 标签date: 2015-12-16 17:05:24type: \"tags\"comments: false---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}],"tags":[{"name":"评论","slug":"评论","permalink":"/tags/评论/"},{"name":"Valine","slug":"Valine","permalink":"/tags/Valine/"},{"name":"gitment","slug":"gitment","permalink":"/tags/gitment/"}]},{"title":"Hexo 个人博客部署到 CentOS 个人服务器","slug":"Hexo-个人博客部署到-CentOS-个人服务器","date":"2019-10-30T09:37:20.000Z","updated":"2019-10-30T10:36:53.214Z","comments":true,"path":"2019/10/30/Hexo-个人博客部署到-CentOS-个人服务器/","link":"","permalink":"/2019/10/30/Hexo-个人博客部署到-CentOS-个人服务器/","excerpt":"","text":"目标 在一台 CentOS 7.2 的 ECS 云服务器上快速部署基于 Hexo 的博客站点 可以在本地简洁快速发布一篇博文到个人云服务器上, 用于个人站点展示 服务器配置 默认 ROOT 权限登录 nginx 安装配置 安装nginx 参考Nan&#39;s Blog的《搭建http服务器-nginx》文章 - （只需要安装启动即可，其它的配置可不管）。 nginx 配置（可选） 注：如果这一步配置完，访问服务器 IP 或者域名显示不出来想要的效果，就不必执行这一步了（使用默认的/usr/share/nginx/html即可，注意配置Git时对应的路径改成/usr/share/nginx/html即可） 创建文件目录, 用于博客站点文件存放, 并更改目录读写权限 12345mkdir -p /data/www/hexochown -R $USER:$USER /data/www/hexochmod -R 755 /data/www/hexo 添加 index.html 用于检测配置 nginx 是否成功 1vim /data/www/hexo/index.html 添加如下代码: 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 配置 nginx 服务器 123vim /etc/nginx/nginx.conf# vim 查找: /listen 80 通过 vim 查找功能找到如下代码, 并修改 12345678......server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.xxx.com; # 填写个人域名（没有就不动） root /data/www/hexo; &#125;...... 访问服务器 IP 或者域名显示 Nginx running nginx 配置成功 Git 安装配置 安装Git 1yum install -y git Git配置 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限 12345mkdir -p /data/GitLibrarychown -R $USER:$USER /data/GitLibrarychmod -R 755 /data/GitLibrary Git 初始化裸库 12cd /data/GitLibrarygit init --bare blog.git 创建 Git 钩子(hook) 1vim /data/GitLibrary/blog.git/hooks/post-receive 用于指定 Git 的源代码 和 Git 配置文件 123456#!/bin/bash# 上面的“nginx配置（可选）”成功使用以下配置：git --work-tree=/data/www/hexo --git-dir=/data/GitLibrary/blog.git checkout -f# 上面的“nginx配置（可选）”失败使用以下配置：git --work-tree=/usr/share/nginx/html --git-dir=/data/GitLibrary/blog.git checkout -f 保存并退出 给该文件添加可执行权限 1chmod +x /data/GitLibrary/blog.git/hooks/post-receiv 本地配置参考该篇博客：Hexo搭建博客教程 参考意思博客配置完后只需要再修改下_config.yml文件，具体如下： 1#repo: 用户名@域名或 IP 地址:/data/GitLibrary/blog 部署步骤将本地部署到服务器 清除缓存 1hexo clean 生成静态页面: 12hexo g# 即：hexo generate 将本地静态页面目录部署到云服务器 12hexo d# 即：hexo deploy 这一步会让你输入服务器密码（每次）： 完成 Hexo 个人博客网站搭建, 通过服务器 IP 或者域名即可访问","categories":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"/tags/博客/"},{"name":"CentOS","slug":"CentOS","permalink":"/tags/CentOS/"}]},{"title":"软件需求，概要设计，详细设计（文档）怎么做，做什么？","slug":"软件需求，概要设计，详细设计（文档）怎么做，做什么？","date":"2019-10-16T03:25:39.000Z","updated":"2019-10-16T03:33:09.027Z","comments":true,"path":"2019/10/16/软件需求，概要设计，详细设计（文档）怎么做，做什么？/","link":"","permalink":"/2019/10/16/软件需求，概要设计，详细设计（文档）怎么做，做什么？/","excerpt":"","text":"前言由于项目工作需要 ，需要提供《软件需求规格说明书》，《软件概要设计说明书》和《软件详细设计说明书》。所以这里整理学习一下相关文档需要的内容。文章并不设计对所有需求分析，概要设计和详细设计的详细描述。因为这其中的任何一点都可以单独提取出来成为软件工程学科中的一本书籍内容。 软件设计的整体流程： 软件需求分析阶段：输出了《软件需求规格说明书》，不涉及具体实现方法。用户能看得明白，开发人员也可据此进行下面的工作，搞清楚“要解决什么问题” 概要设计阶段：确定软件系统的总体布局，各个子模块的功能和模块间的关系，与外部系统的关系，选择的技术路线。有一些研究与论证性的内容。并输出《软件概要设计说明书》。搞清楚“总体实现方案” 详细设计阶段：对概要设计的进一步细化，一般由各部分的担当人员依据概要设计分别完成，然后在集成，是具体的实现细节。是“程序”的蓝图，确定每个模块采用的算法、数据结构、接口的实现、属性、参数。并输出《软件详细设计说明书》。搞清楚“每个模块怎么做” 需求分析我们为什么需要《软件需求规格说明书》 ？如果需求的编写只是为了解释说明软件实现的功能，那么良好的编码结构，代码注释就可以很好的实现软件的功能说明，程序员可以将编写需求的时间节约下来进行更多功能的实现； 可是，这样的情况可能更多适用于中小型项目，或者互联网项目，因为这样的项目需求不复杂，并且需求变化很快，所以研发的效率非常重要。然而，针对大型软件项目或者功能比较复杂的系统，软件研发可能是多人协作的成果，所以在信息传递过程中， 我们只有提前考虑好软件需求的内容，才能正确评估开发软件所需要的时间，成本的要素，从而更好的管理项目。 《软件需求规格说明书》的一般结构 正文的第一章内容是1.概述，包含1.1.编写目的；1.2.术语与定义；1.3.参考资料；三个部分 第二章要给出该项目的标准和规范，在文档的后续内容编写中以及项目开发过程中必须遵照这个标准和规范进行。 第三章应该说明该项目的相关假设、限制和一些依赖条件，在后续系统部署的过程中可以有参考意义。 第四章“功能规格”是重点，重点介绍这个系统的角色，界面设计思路，系统的功能视图和功能点清单，以及系统的需求用例。这个内容必须详细描述，这样才能对后续的开发和测试提供指导意义。 第五章“非功能规格”要对项目的性能、安全、数据的备份恢复等内容解释解释说明，一个项目除了功能完整之外，还要考虑性能、安全等相应的要求。 第六章“附录”，是对软件需求规格说明书的一些补充说明文档，其中的“软件需求跟踪矩阵”是重点，这份文档是对后续需求的完善程度进行了严格的控制。 概要设计《概要设计说明书》的一般结构 总述：需求或目标（讲一下事情的起源）、环境、局限； 总体设计：从全局的角度说一下 组织结构、功能、处理流程、有哪些模块、模块间的关系，运行环境等。（输出图：系统结构图，系统流程图，数据流程图，推荐在线画图工具https://www.processon.com/） 外部接口：总体说明外部用户、软、硬件接口(可用资源)； 模块设计：每个模块“做什么”、简要说明“怎么做”（输入、输出、处理逻辑、与其它模块或系统的接口），处在什么逻辑位置、物理位置。 123456模块设计,可以写以下内容： 1、模块描述：说明哪些模块实现了哪些功能； 2、模块层次结构：可以使用某个视角的软件框架图来表达； 3、模块间的关系：模块间依赖关系的描述，通信机制描述； 4、模块的核心接口：说明模块传递的信息、信息的结构； 5、处理方式设计：说一些满足功能和性能的算法； 数据结构：逻辑结构、物理结构。 容灾设计：出错信息、出错处理。（可选） 监控设计：运行模块组合、控制、时间。（可选） 用户界面设计：（可选）。 安全设计：（可选）。 其它设计：（可选）。 制定规范（附录）： 设计原则,代码规范、接口规约、命名规则。 概要设计需要注意的地方 用来评价总体设计的可行性。 用来检查设计的模块是否完整，保证每一个功能都有对应的模块来实现。 用来评估开发工作量、指导开发计划（在不写详细设计的情况下）。 概要设计阶段过于重视业务流程是个误区。 概要设计阶段过于重视细节实现是个误区。 详细设计《详细设计说明书》的一般结构参考如何撰写软件详细设计内容？ 引言，包含：编写目的，背景，参考资料，术语定义及说明 设计概述，包含：任务和目标，需求概述，运行环境概述， 条件与限制，详细设计方法和工具 系统详细需求分析，包含：详细需求分析，详细系统运行环境及限制条件分析接口需求分析 总体方案确认，包含： 系统总体结构确认， 系统详细界面划分 系统详细设计，包含： 系统结构设计及子系统划分，系统功能模块详细设计（采用HIPO图进行功能分解与模块描述，，用IPO或结构图描述各模块的组成结构、算法、模块间的接口关系，以及需求、功能和模块三者之间的交叉参照关系。）, 系统界面详细设计 12345678910111213每个模块的描述说明可参照以下格式：**模块编号：****模块名称：****输入：****处理：****算法描述：****输出：** 数据库系统设计 详细设计需要注意的地方如果有或者有必要，特别是大型的软件系统，详细设计阶段划分系统功能模块或子系统。 概要设计和详细设计的区别概要设计阶段在这个阶段，设计者会大致考虑并照顾模块的内部实现，但不过多纠缠于此。主要集中于划分模块、分配任务、定义调用关系。模块间的接口与传参在这个阶段要定得十分细致明确，应编写严谨的数据字典，避免后续设计产生不解或误解。概要设计一般不是一次就能做到位，而是反复地进行结构调整。典型的调整是合并功能重复的模块，或者进一步分解出可以复用的模块。在概要设计阶段，应最大限度地提取可以重用的模块，建立合理的结构体系，节省后续环节的工作量。概要设计文档最重要的部分是分层数据流图、结构图、数据字典以及相应的文字说明等。以概要设计文档为依据，各个模块的详细设计就可以并行展开了。 详细设计阶段在这个阶段，各个模块可以分给不同的人去并行设计。在详细设计阶段，设计者的工作对象是一个模块，根据概要设计赋予的局部任务和对外接口，设计并表达出模块的算法、流程、状态转换等内容。这里要注意，如果发现有结构调整（如分解出子模块等）的必要，必须返回到概要设计阶段，将调整反应到概要设计文档中，而不能就地解决，不打招呼。详细设计文档最重要的部分是模块的流程图、状态图、局部变量及相应的文字说明等。 参考文章软件需求规格说明书模板软件概要设计-模板软件概要设计做什么，怎么做互联网公司研发RD如何撰写总体设计与详细设计文档项目开发过程中详细设计和概要设计有什么区别和要求?如何撰写软件详细设计内容？","categories":[{"name":"文档","slug":"文档","permalink":"/categories/文档/"}],"tags":[{"name":"软件需求","slug":"软件需求","permalink":"/tags/软件需求/"},{"name":"概要设计","slug":"概要设计","permalink":"/tags/概要设计/"},{"name":"详细设计","slug":"详细设计","permalink":"/tags/详细设计/"}]},{"title":"Rainloop安装配置","slug":"Rainloop安装配置","date":"2019-09-27T01:57:53.000Z","updated":"2019-09-27T02:11:46.011Z","comments":true,"path":"2019/09/27/Rainloop安装配置/","link":"","permalink":"/2019/09/27/Rainloop安装配置/","excerpt":"","text":"简介RainLoop是一个基于WEB的邮件系统，使用PHP开发，通过RainLoop可以将多个邮箱聚合在一起，程序拥有简介的界面和全面的功能，支持SMTP+IMAP，是个人邮件客户端的最佳程序。这里说下安装方法。 前提RainLoop要想运行起来需要满足该博客“PHP入门技巧”完成的PHP环境。 Rainloop安装 Rainloop官网 官方网站：https://www.rainloop.net 下载地址：https://www.rainloop.net/downloads 将Rainloop安装包下载后解压上传到你的网站服务器上（/www目录下），然后直接用浏览器访问：http://wampserver-test.com/?admin，输入以下登录信息登录： 用户名：admin 密码：12345 RainLoop设置方法 这么些设置，自己摸索，就不多说了 说明RainLoop用PHP开发，正常情况下在PHP环境中就可以运行，有时候并不需要数据库，应用程序不存储电子邮件，应用直接访问邮件服务器和RainLoop显示邮件而已，简单实用！性能方面完全取决于你的服务器内存和网速了，如果您需要启用邮件联系人，则需要用数据库（MySQL），具体可以自行折腾。当然我们自己使用的话，完全没有问题。","categories":[{"name":"Rainloop","slug":"Rainloop","permalink":"/categories/Rainloop/"}],"tags":[{"name":"安装配置","slug":"安装配置","permalink":"/tags/安装配置/"},{"name":"WebMail","slug":"WebMail","permalink":"/tags/WebMail/"}]},{"title":"PHP入门技巧","slug":"PHP入门技巧","date":"2019-09-24T02:01:34.000Z","updated":"2019-09-24T03:37:39.305Z","comments":true,"path":"2019/09/24/PHP入门技巧/","link":"","permalink":"/2019/09/24/PHP入门技巧/","excerpt":"","text":"集成环境wamperserver 下载好安装到本地指定目录，官网下载地址 http://www.wampserver.com 安装成功的标志： 双击运行wamperserver图标后： 浏览器访问localhost出现以下页面表示安装成功 根据自己实际的安装路径，D:\\maliangnansheng\\wamp64\\bin\\apache\\apache2.4.39\\conf，找到 apache 的配置文件 httpd.conf 也可以左键图标直接打开文件修改： 123打开文件httpd.conf文件搜索Include conf/extra/httpd-vhosts.conf去掉它前面的#，然后保存这个文件 打开D:\\maliangnansheng\\wamp64\\bin\\apache\\apache2.4.39\\conf\\extra\\httpd-vhosts.conf文件，添加域名映射项，一般是在文件的最后添加上： 也可以左键图标直接打开文件修改： 1234567891011121314# 添加的内容：&lt;VirtualHost *:80&gt; ServerName wampserver-test.com ServerAlias wampserver-test.com DocumentRoot \"$&#123;INSTALL_DIR&#125;/www\" &lt;Directory \"$&#123;INSTALL_DIR&#125;/www/\"&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;# ServerName wampserver-test.com 为配置的虚拟站点# DocumentRoot \"$&#123;INSTALL_DIR&#125;/www\" 项目文件的路径 视图如下： 找到本机的 host 文件（C:\\Windows\\System32\\drivers\\etc ），绑定到本地 12# 在文件最后添加域名：127.0.0.1 wampserver-test.com 重启服务环境，就可以通过域名访问项目了 phpStudy php7.2 废弃each方法12345&lt;?php$b = array();each($b); // Deprecated: The each() function is deprecated. This message will be suppressed on further calls each方法替换为 123456789101112function fun_adm_each(&amp;$array)&#123; $res = array(); $key = key($array); if($key !== null)&#123; next($array); $res[1] = $res['value'] = $array[$key]; $res[0] = $res['key'] = $key; &#125;else&#123; $res = false; &#125; return $res;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"/categories/PHP/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"集成环境","slug":"集成环境","permalink":"/tags/集成环境/"}]},{"title":"EwoMail邮件服务器搭建and配置","slug":"EwoMail邮件服务器搭建and配置","date":"2019-09-19T08:24:34.000Z","updated":"2019-09-19T08:58:30.371Z","comments":true,"path":"2019/09/19/EwoMail邮件服务器搭建and配置/","link":"","permalink":"/2019/09/19/EwoMail邮件服务器搭建and配置/","excerpt":"","text":"引用： EwoMail 邮件服务器（开源版文档） 利用EwoMail开源软件自建邮件服务器 - 安装设置篇 安装以下是无错的简单安装流程，如安装过程出错请参见《引用》地址 安装环境安装前请检查端口，点击查看（无法连接服务器） centos6/7系统，服务器需要干净环境，要求全新干净系统，不能安装在已有的apache,mysql的环境中。 最低配置要求CPU：1核内存：1G硬盘：40G 由于新版本的杀毒软件占用的内存比较多，512M到2GB内存请参考降低内存占用 EwoMail安装后会把数据存放在 /ewomail 目录建议你提前创建 /ewomail 目录，并且将硬盘容量挂载或分配到/ewomail 关闭selinux123vi /etc/sysconfig/selinux# SELINUX=enforcing 改为 SELINUX=disabled 检查swap如果没启动swap，这会导致EwoMail的防病毒组件不能启动，所以在安装前先检查swap是否已经启动，如已启动可跳过该步骤。 12# 查看swapfree -m 如果swap位置都显示是0，那么系统还没创建swap 创建swap分区（内存超过2G，可不配置）创建1G的swap，可以根据你的服务器配置来调整大小 1dd if=/dev/zero of=/mnt/swap bs=1M count=1024 设置交换分区文件 1mkswap /mnt/swap 启动swap 1swapon /mnt/swap 设置开机时自启用 swap 分区 12# 需要修改文件 /etc/fstab 中的 swap 行，在最后-添加以下内容/mnt/swap swap swap defaults 0 0 邮箱域名EwoMail本身是可以配置多个域名来收发邮件的，但在安装前需要一个邮箱的主域名。本次教程例子使用的主域名是sunsheen.cn 设置主机名（可不配置主机名）EwoMail在安装后会默认使用域名前缀mail的主机名，例如mail.sunsheen.cn将系统主机名改成mail.sunsheen.cn 查看当前主机名 1hostname -f 输入命令： 1hostnamectl set-hostname mail.sunsheen.cn 修改文件 /etc/hosts , 添加 mail.sunsheen.cn 123vi /etc/hosts# 在文件最后添加一下内容：172.18.11.11 mail.sunsheen.cn mail localhost 安装EwoMail邮件软件 代码获取渠道 渠道：http://ewomail.com/list-11.html 输入域名，然后生成安装地址，然后去执行安装 安装成功 现在就安装成功了，可以访问邮箱管理后台和web邮件系统 EwoMail邮件系统登录管理 邮箱管理后台：http://IP:8010 （默认账号admin，密码ewomail123） web邮件系统：http://IP:8000 web邮件系统-8000 邮箱管理后台-8010 登录后： 配置","categories":[{"name":"EwoMail","slug":"EwoMail","permalink":"/categories/EwoMail/"}],"tags":[{"name":"邮件服务器","slug":"邮件服务器","permalink":"/tags/邮件服务器/"},{"name":"搭建","slug":"搭建","permalink":"/tags/搭建/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"}]},{"title":"Java 远程执行 Linux 的命令","slug":"Java-远程执行-Linux-的命令","date":"2019-09-05T03:30:30.000Z","updated":"2019-09-10T02:25:14.916Z","comments":true,"path":"2019/09/05/Java-远程执行-Linux-的命令/","link":"","permalink":"/2019/09/05/Java-远程执行-Linux-的命令/","excerpt":"","text":"在 Java 中可以通过 SSH2 协议远程执行 Linux 系统的命令或 Shell 脚本。 添加依赖需添加 ganymed-ssh2-262.jar 、commons-io-2.6.jar、commons-lang3-3.9.jar、fastjson-1.2.58.jar包，Maven 依赖如下： 123456789101112131415161718192021222324252627&lt;!-- https://mvnrepository.com/artifact/ch.ethz.ganymed/ganymed-ssh2 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.ethz.ganymed&lt;/groupId&gt; &lt;artifactId&gt;ganymed-ssh2&lt;/artifactId&gt; &lt;version&gt;262&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt; api 说明 首先构造一个连接器，传入一个需要登陆的ip地址； Connection conn = new Connection(hostname); 模拟登陆目的服务器，传入用户名和密码； boolean isAuthenticated = conn.authenticateWithPassword(username, password); 它会返回一个布尔值，true 代表成功登陆目的服务器，否则登陆失败。 打开一个session，执行你需要的linux 脚本命令； Session session = conn.openSession();session.execCommand(“ifconfig”); 接收目标服务器上的控制台返回结果，读取br中的内容； InputStream stdout = new StreamGobbler(sess.getStdout());BufferedReader br = new BufferedReader(new InputStreamReader(stdout)); 得到脚本运行成功与否的标志 ：0－成功 非0－失败 System.out.println(“ExitCode: ” + sess.getExitStatus()); 关闭session和connection sess.close();conn.close(); 备注1、通过第2步认证成功后，当前目录就位于/home/username/目录之下，你可以指定脚本文件所在的绝对路径，或者通过cd导航到脚本文件所在的目录，然后传递执行脚本所需要的参数，完成脚本调用执行。 2、执行脚本以后，可以获取脚本执行的结果文本，需要对这些文本进行正确编码后返回给客户端，避免乱码产生。 3、如果你需要执行多个linux控制台脚本，比如第一个脚本的返回结果是第二个脚本的入参，你必须打开多个Session,也就是多次调用Session sess = conn.openSession();,使用完毕记得关闭就可以了。 实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import ch.ethz.ssh2.Connection;import ch.ethz.ssh2.Session;import ch.ethz.ssh2.StreamGobbler;import com.alibaba.fastjson.util.IOUtils;import org.apache.commons.lang3.StringUtils;/** * 远程执行Linux命令 * * @author 92481 * */public class RemoteExecuteCommand &#123; // 字符编码默认是utf-8 private static String DEFAULTCHART = \"UTF-8\"; private Connection conn; private String ip; private String userName; private String userPwd; public RemoteExecuteCommand(String ip, String userName, String userPwd) &#123; this.ip = ip; this.userName = userName; this.userPwd = userPwd; &#125; public RemoteExecuteCommand() &#123; &#125; /** * 远程登录linux主机 * @return 登录成功返回true，否则返回false * @throws Exception */ public Boolean login() throws Exception &#123; boolean flg = false; try &#123; conn = new Connection(ip); // 连接 conn.connect(); // 认证 flg = conn.authenticateWithPassword(userName, userPwd); &#125; catch (IOException e) &#123; throw new Exception(\"远程连接服务器失败\", e); &#125; return flg; &#125; /** * 远程执行shll脚本或者命令 * @param cmd 即将执行的命令 * @return 命令执行完后返回的结果值 * @throws Exception */ public String execute(String cmd) throws Exception &#123; String result = \"\"; Session session = null; try &#123; if (login()) &#123; // 打开一个会话 session = conn.openSession(); // 执行命令 session.execCommand(cmd); result = processStdout(session.getStdout(), DEFAULTCHART); // 如果为输出为空，说明脚本执行出错了 if (StringUtils.isBlank(result)) &#123; result = processStdout(session.getStderr(), DEFAULTCHART); &#125; conn.close(); session.close(); &#125; &#125; catch (IOException e) &#123; throw new Exception(\"命令执行失败\", e); &#125; finally &#123; if (conn != null) &#123; conn.close(); &#125; if (session != null) &#123; session.close(); &#125; &#125; return result; &#125; /** * 解析脚本执行返回的结果集 * @param in 输入流对象 * @param charset 编码 * @return 以纯文本的格式返回 * @throws Exception */ private String processStdout(InputStream in, String charset) throws Exception &#123; InputStream stdout = new StreamGobbler(in); StringBuffer buffer = new StringBuffer(); InputStreamReader isr = null; BufferedReader br = null; try &#123; isr = new InputStreamReader(stdout, charset); br = new BufferedReader(isr); String line = null; while ((line = br.readLine()) != null) &#123; buffer.append(line + \"\\n\"); &#125; &#125; catch (UnsupportedEncodingException e) &#123; throw new Exception(\"不支持的编码字符集异常\", e); &#125; catch (IOException e) &#123; throw new Exception(\"读取指纹失败\", e); &#125; finally &#123; IOUtils.close(br); IOUtils.close(isr); IOUtils.close(stdout); &#125; return buffer.toString(); &#125; public static void main(String[] args) throws Exception &#123; String linuxIP = \"172.18.195.253\"; String usrName = \"root\"; String passwd = \"Jufeng2010\"; RemoteExecuteCommand rec = new RemoteExecuteCommand(linuxIP, usrName, passwd); // 执行命令 System.out.println(rec.execute(\"ip a\")); // 执行脚本 // rec.execute(\"sh /etc/init.d/domain.sh hkc.demo.sunsheen.cn 172.18.195.155 8888\"); &#125;&#125; 例如：123// 执行脚本 （域名访问）rec.execute(\"sh /etc/init.d/domain.sh \" + domainBef+domainLater + \" \" + ip + \" \" + innerPort + \" \" + createUserName); 12345678910111213141516171819cd /etc/init.d/domain.shcd /etc/nginx/conf.d/# 创建配置文件touch $1_$4.conf;# 像配置文件写入内容echo \"server &#123; listen 80; server_name $1; location / &#123; proxy_pass http://$2:$3; proxy_set_header Host \\$host:80; proxy_set_header X-Real-IP \\$remote_addr; proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for; proxy_set_header Via \\\"nginx\\\"; &#125;&#125;\" &gt; $1_$4.conf;# 重启nginxnginx -s reload;","categories":[{"name":"Java远程Linux命令","slug":"Java远程Linux命令","permalink":"/categories/Java远程Linux命令/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"远程命令","slug":"远程命令","permalink":"/tags/远程命令/"}]},{"title":"CentOS 7.x - 安装MySQL 5.7","slug":"CentOS-7-x-安装MySQL-5-7","date":"2019-08-21T06:20:39.000Z","updated":"2019-08-22T02:59:43.440Z","comments":true,"path":"2019/08/21/CentOS-7-x-安装MySQL-5-7/","link":"","permalink":"/2019/08/21/CentOS-7-x-安装MySQL-5-7/","excerpt":"","text":"在线安装引用：他人博客、MySQL官网 yum仓库：下载MySQL Yum存储库 CentOS 7的默认yum仓库中并没有MySQL5.7，我们需要手动添加，好在MySQL官方提供了仓库的地址，所以我们能够比较简单地安装MySQL。 本文我们将介绍CentOS 7下MySQL5.7的安装。 添加MySQL5.7仓库123# 地址来源于下载yum存储库时“No thanks, just start my download.”的地址rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm 确认MySQL仓库成功添加1234567yum repolist all | grep mysql | grep enabled# 如果展示像下面,则表示成功添加仓库:mysql-connectors-community/x86_64 MySQL Connectors Community enabled: 51mysql-tools-community/x86_64 MySQL Tools Community enabled: 63mysql57-community/x86_64 MySQL 5.7 Community Server enabled: 267 开始安装MySQL5.7这个过程用时较久（取决于你的网速） 1yum -y install mysql-community-server 启动MySQL 启动 1systemctl start mysqld 设置系统启动时自动启动 1systemctl enable mysqld 查看启动状态 1systemctl status mysqld MySQL的安全设置CentOS上的root默认密码可以在文件/var/log/mysqld.log找到，通过下面命令可以打印出来 12# 该命令只能查询默认的初始密码（如果修改了密码，并不能查询到更改后的密码）cat /var/log/mysqld.log | grep -i 'temporary password' 执行下面命令进行安全设置，这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等 1mysql_secure_installation MySQL5.7初始化密码报错报错信息：ERROR 1820 (HY000): You must reset your password using ALTER USER statement before mysql5.6是密码为空直接进入数据库的，但是mysql5.7就需要初始密码 1cat /var/log/mysqld.log | grep -i 'temporary password' 然后执行 mysql -uroot -p ，输入上面的到的密码进入，用该密码登录后，必须马上修改新的密码，不然会报如下错误： 1use mysql; 如果你想要设置一个简单的测试密码的话，比如设置为777888，会提示这个错误，报错的意思就是你的密码不符合要求 1alter user 'root'@'localhost' identified by '777888'; 这个其实与validate_password_policy的值有关 validate_password_policy有以下取值： 默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。有时候，只是为了自己测试，不想密码设置得那么复杂，譬如说，我只想设置root的密码为777888。必须修改两个全局参数： 首先，修改validate_password_policy参数的值 12mysql&gt; set global validate_password_policy=0;Query OK, 0 rows affected (0.00 sec) validate_password_length(密码长度)参数默认为8，我们修改为1 12mysql&gt; set global validate_password_length=1;Query OK, 0 rows affected (0.00 sec) 完成之后再次执行修改密码语句即可成功 12mysql&gt; alter user 'root'@'localhost' identified by '777888';Query OK, 0 rows affected (0.00 sec) CentOS 如何修改MySQL用户root的密码 用帐号登录mysql 123mysql -uroot -pEnter password:# 输入原密码 改变用户数据库 12345mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changed 修改密码，记得密码要用password()函数进行加密，一定不要忘记！！！ 123456789# 5.6版本修改密码mysql&gt; update user set password=password('Your new password') where user='root';Query OK, 1 row affected (0.04 sec)Rows matched: 1 Changed: 1 Warnings: 0# 5.7版本下的mysql数据库下已经没有password这个字段了，password字段改成了authentication_stringmysql&gt; update mysql.user set authentication_string=password('Your new password') where user='root';Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 刷新权限表 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 退出MySQL 12mysql&gt; quitBye 重启MySQL 1systemctl restart mysqld 设置数据库编码为utf8 打开配置文件 1vim /etc/my.cnf 在[mysqld]，[client]，[mysql]节点下添加编码设置（原本就有的替换、没有的追加成下面的内容） 1234567891011[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES #解释见附录 ***collation-server = utf8_unicode_ciinit-connect='SET NAMES utf8'character-set-server = utf8 重启MySQL即可 1systemctl restart mysqld 离线安装附录sql_mode 常用值说明引用：MySQL sql_mode 说明 官方手册专门有一节介绍 https://dev.mysql.com/doc/refman/5.6/en/sql-mode.html 。 SQL Mode 定义了两个方面：MySQL应支持的SQL语法，以及应该在数据上执行何种确认检查。 SQL语法支持类 ONLY_FULL_GROUP_BY 对于GROUP BY聚合操作，如果在SELECT中的列、HAVING或者ORDER BY子句的列，没有在GROUP BY中出现，那么这个SQL是不合法的。是可以理解的，因为不在 group by 的列查出来展示会有矛盾。在5.7中默认启用，所以在实施5.6升级到5.7的过程需要注意： 12345 Expression #1 of SELECT list is not in GROUP BYclause and contains nonaggregated column&apos;1066export.ebay_order_items.TransactionID&apos; whichis not functionally dependent on columns in GROUP BYclause; this is incompatible with sql_mode=only_full_group_by ANSI_QUOTES 启用 ANSI_QUOTES 后，不能用双引号来引用字符串，因为它被解释为识别符，作用与 一样。设置它以后，update t set f1=”” …`，会报 Unknown column ‘’ in ‘field list 这样的语法错误。 PIPES_AS_CONCAT 将 || 视为字符串的连接操作符而非 或 运算符，这和Oracle数据库是一样的，也和字符串的拼接函数 CONCAT() 相类似。 NO_TABLE_OPTIONS 使用 SHOW CREATE TABLE 时不会输出MySQL特有的语法部分，如 ENGINE ，这个在使用 mysqldump 跨DB种类迁移的时候需要考虑。 NO_AUTO_CREATE_USER 字面意思不自动创建用户。在给MySQL用户授权时，我们习惯使用 GRANT ... ON ... TO dbuser 顺道一起创建用户。设置该选项后就与oracle操作类似，授权之前必须先建立用户。5.7.7开始也默认了。 数据检查类 NO_ZERO_DATE 认为日期 ‘0000-00-00’ 非法，与是否设置后面的严格模式有关。 如果设置了严格模式，则 NO_ZERO_DATE 自然满足。但如果是 INSERT IGNORE 或 UPDATE IGNORE，’0000-00-00’依然允许且只显示warning 如果在非严格模式下，设置了NO_ZERO_DATE，效果与上面一样，’0000-00-00’允许但显示warning；如果没有设置NO_ZERO_DATE，no warning，当做完全合法的值。 NO_ZERO_IN_DATE情况与上面类似，不同的是控制日期和天，是否可为 0 ，即 2010-01-00 是否合法。 NO_ENGINE_SUBSTITUTION 使用 ALTER TABLE或CREATE TABLE 指定 ENGINE 时， 需要的存储引擎被禁用或未编译，该如何处理。启用NO_ENGINE_SUBSTITUTION时，那么直接抛出错误；不设置此值时，CREATE用默认的存储引擎替代，ATLER不进行更改，并抛出一个 warning . STRICT_TRANS_TABLES 设置它，表示启用严格模式。注意 STRICT_TRANS_TABLES 不是几种策略的组合，单独指 INSERT、UPDATE出现少值或无效值该如何处理： 前面提到的把 ‘’ 传给int，严格模式下非法，若启用非严格模式则变成0，产生一个warning Out Of Range，变成插入最大边界值 A value is missing when a new row to be inserted does not contain a value for a non-NULL column that has no explicit DEFAULT clause in its definition 上面并没有囊括所有的 SQL Mode，选了几个代表性的，详细还是 看手册。 sql_mode一般来说很少去关注它，没有遇到实际问题之前不会去启停上面的条目。我们常设置的 sql_mode 是 ANSI、STRICT_TRANS_TABLES、TRADITIONAL，ansi和traditional是上面的几种组合。 ANSI：更改语法和行为，使其更符合标准SQL相当于REAL_AS_FLOAT, PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE TRADITIONAL：更像传统SQL数据库系统，该模式的简单描述是当在列中插入不正确的值时“给出错误而不是警告”。相当于 STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER, NO_ENGINE_SUBSTITUTION ORACLE：相当于 PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER 无论何种mode，产生error之后就意味着单条sql执行失败，对于支持事务的表，则导致当前事务回滚；但如果没有放在事务中执行，或者不支持事务的存储引擎表，则可能导致数据不一致。MySQL认为，相比直接报错终止，数据不一致问题更严重。于是 STRICT_TRANS_TABLES 对非事务表依然尽可能的让写入继续，比如给个”最合理”的默认值或截断。而对于 STRICT_ALL_TABLES，如果是单条更新，则不影响，但如果更新的是多条，第一条成功，后面失败则会出现部分更新。 5.6.6 以后版本默认就是NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES，5.5默认为 ‘’ 。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"}]},{"title":"Servlet登录拦截器","slug":"Servlet登录拦截器","date":"2019-07-11T08:24:23.000Z","updated":"2019-07-11T08:30:38.716Z","comments":true,"path":"2019/07/11/Servlet登录拦截器/","link":"","permalink":"/2019/07/11/Servlet登录拦截器/","excerpt":"","text":"代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.sunsheen.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.sunsheen.jfids.system.config.Configs;import com.sunsheen.jfids.system.security.login.Session;/** * Servlet 登录过滤器 * @author 92481 * */public class LoginFilter implements Filter &#123; public LoginFilter() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; //获取url地址 String reqUrl = req.getRequestURI();// System.out.println(\"reqURL----------\" + reqUrl); // 登录操作不做页面跳转 if(reqUrl.contains(\"/hkcloud/login.w.xhtml\") || reqUrl.contains(\"/hkcloud/getUser\") || reqUrl.contains(\"/hkcloud/login\") || reqUrl.contains(\"/static/\") || reqUrl.endsWith(\".css\") || reqUrl.endsWith(\".js\"))&#123; chain.doFilter(request, response); return; &#125; HttpSession session = Session.getHttpSession(); String apiKey = (String) session.getAttribute(\"ApiKey\"); HttpServletResponse res = (HttpServletResponse) response; // 如果session中存在apiKey证明用户登录，可以放行。否则认为未登陆重定向到登录界面 if (apiKey == null || apiKey.equals(\"\")) &#123; // 登录页面地址 String loginUrl = Configs.get(\"AllConfig.loginUrl\"); //如果request.getHeader(\"X-Requested-With\") 返回的是\"XMLHttpRequest\" //说明就是ajax请求，需要特殊处理 if(\"XMLHttpRequest\".equals(req.getHeader(\"X-Requested-With\")))&#123; //告诉ajax我是重定向 res.setHeader(\"redirect\", \"redirect\"); //告诉ajax我重定向的路径 res.setHeader(\"url\", req.getContextPath() + loginUrl); res.setStatus(HttpServletResponse.SC_FORBIDDEN); return; &#125;else&#123; res.sendRedirect(req.getContextPath() + loginUrl); &#125; &#125; else &#123; chain.doFilter(request, response); return; &#125; &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; 注： ajax请求返回重定向信息 在项目中，考虑到web前台ajax请求未登录资源时，后台返回的重定向信息，ajax不能自动判断是否是重定向，以下是一种折中方法： 前端jquery.ajax默认设置，ajax设置要放在程序ajax调用前，我一般放在公共js中统一引用到文件头里的，这样调用ajax的时候就无需操心其他设置了 12345678910111213141516171819/** * ajax默认设置 包括默认提交方式为POST， 判断后台是否是重定向 */$.ajaxSetup(&#123; // 设置ajax请求结束后的执行动作 complete : function(XMLHttpRequest, textStatus) &#123; // 通过XMLHttpRequest取得响应头，redirect var redirect = XMLHttpRequest.getResponseHeader(\"redirect\"); if (redirect == \"redirect\") &#123; // 若HEADER中含有redirect说明后端想重定向 var win = window; while (win != win.top) &#123; win = win.top; &#125; // 将后端重定向的地址取出来,使用win.location.href去实现重定向的要求 win.location.href = XMLHttpRequest.getResponseHeader(\"url\"); &#125; &#125;, type : 'POST'&#125;);","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"拦截器","slug":"拦截器","permalink":"/tags/拦截器/"},{"name":"filter","slug":"filter","permalink":"/tags/filter/"}]},{"title":"Java汉字转拼音pinyin4j用法","slug":"Java汉字转拼音pinyin4j用法","date":"2019-07-03T10:04:41.000Z","updated":"2019-08-22T03:09:21.196Z","comments":true,"path":"2019/07/03/Java汉字转拼音pinyin4j用法/","link":"","permalink":"/2019/07/03/Java汉字转拼音pinyin4j用法/","excerpt":"","text":"来源：https://www.jianshu.com/p/57a6600d2862 工具介绍pinyin4j 是一个支持将简体和繁体中文转换到成拼音的Java开源类库； 功能 支持同一汉字有多个发音 还支持拼音的格式化输出，比如第几声之类的， 同时支持简体中文、繁体中文转换为拼音…使用起来也非常简单。下面是其官方网址，其中提供了下载： pinyin4j的官方下载地址 Maven仓库 目录结构及说明doc : pinyin4j的api文档 lib : pinyin4j的jar包 src: pinyin4j的源代码 CHANGELOG.txt : pinyin4j的版本更新日志 COPYING.txt : LICENSE说明 README.txt : pinyin4j的概要介绍 原理pinyin4j使用了一个.txt的文本文件（uicode_to_hanyu_pinyin.txt）用来存储汉字unicode编码与拼音的对应关系，通过读取该配置文件达到转换的目的。该属性文件存储信息的基本格式如下：89E3 (jie3,jie4,xie4) //(对应汉字”解”)89E3 是汉字对应的unicode编码的16进制数，(jie3,jie4,xie4)是该汉字对应的三种读音(在汉语里有多音字)，说明pinyin4j支持多音字的处理pinyin4j的处理过程是这样的：根据String的toCharArray方法得到每个字符（得到”解”字的unicode编码，实际上是35299，由于java中char和String都是unicode编码的可以直接转为int型的编码数据35299），然后利用Integer.toHexString(c1).toUpperCase()将其转换成16进制数[也就是89E3]，通过读取配置文件得到“解”字的拼音(jie3,jie4,xie4)，那么这里有三个拼音，pinyin4j的默认取值为第一个，也就是jie3[表示读jie，声调是三声] pinyin4J 使用pinyin4j 提供的工具类为PinyinHelper,里边提供了静态方法 toHanyuPinyinString()(过时) toHanyuPinyinStringArray() pinyin4j 中有四个辅助类分别是： HanyuPinyinCaseType HanyuPinyinToneType HanyuPinyinVCharType HanyuPinyinOutputFormat 具体功能和用法见一下代码： 123456789101112131415161718HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();// 控制大小写// UPPERCASE：大写 (ZHONG)// LOWERCASE：小写 (zhong)defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE);// WITHOUT_TONE：无音标 (zhong)// WITH_TONE_NUMBER：1-4数字表示英标 (zhong4)// WITH_TONE_MARK：直接用音标符（必须WITH_U_UNICODE否则异常） (zhòng)defaultFormat.setToneType(HanyuPinyinToneType.WITH_TONE_NUMBER);// WITH_V：用v表示ü (nv)// WITH_U_AND_COLON：用\"u:\"表示ü (nu:)// WITH_U_UNICODE：直接用ü (nü)defaultFormat.setVCharType(HanyuPinyinVCharType.WITH_U_UNICODE);// oHanyuPinyinStringArray如果传入的字符不是汉字不能转换成拼音，那么会直接返回null。String[] pinyin = PinyinHelper.toHanyuPinyinStringArray('重', defaultFormat);for(String str: pinyin)&#123; System.out.println(str);&#125; 结果： 1ZHONG4 1CHONG2 其他工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 获得汉语拼音【首字母】 * * @param chines * 汉字 * @return */public static String getAlpha(String chines) &#123; String pinyinName = \"\"; char[] nameChar = chines.toCharArray(); HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE); defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE); for (int i = 0; i &lt; nameChar.length; i++) &#123; if (nameChar[i] &gt; 128) &#123; try &#123; pinyinName += PinyinHelper.toHanyuPinyinStringArray( nameChar[i], defaultFormat)[0].charAt(0); &#125; catch (BadHanyuPinyinOutputFormatCombination e) &#123; e.printStackTrace(); &#125; &#125; else &#123; pinyinName += nameChar[i]; &#125; &#125; return pinyinName;&#125;/** * 将字符串中的中文转化为【拼音】,英文字符不变 * * @param inputString * 汉字 * @return */public static String getPingYin(String inputString) &#123; HanyuPinyinOutputFormat format = new HanyuPinyinOutputFormat(); format.setCaseType(HanyuPinyinCaseType.LOWERCASE); format.setToneType(HanyuPinyinToneType.WITHOUT_TONE); format.setVCharType(HanyuPinyinVCharType.WITH_V); String output = \"\"; if (inputString != null &amp;&amp; inputString.length() &gt; 0 &amp;&amp; !\"null\".equals(inputString)) &#123; char[] input = inputString.trim().toCharArray(); try &#123; for (int i = 0; i &lt; input.length; i++) &#123; if (java.lang.Character.toString(input[i]).matches( \"[\\\\u4E00-\\\\u9FA5]+\")) &#123; String[] temp = PinyinHelper.toHanyuPinyinStringArray( input[i], format); output += temp[0]; &#125; else output += java.lang.Character.toString(input[i]); &#125; &#125; catch (BadHanyuPinyinOutputFormatCombination e) &#123; e.printStackTrace(); &#125; &#125; else &#123; return \"*\"; &#125; return output;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"汉字转拼音","slug":"汉字转拼音","permalink":"/tags/汉字转拼音/"},{"name":"pinyin4j","slug":"pinyin4j","permalink":"/tags/pinyin4j/"}]},{"title":"CloudStack API编程指南","slug":"CloudStack-API编程指南","date":"2019-07-02T02:09:30.000Z","updated":"2020-06-24T07:57:57.466Z","comments":true,"path":"2019/07/02/CloudStack-API编程指南/","link":"","permalink":"/2019/07/02/CloudStack-API编程指南/","excerpt":"","text":"来源：https://blog.csdn.net/u012124304/article/details/76152234 角色CloudStack API支持三种角色访问： 根域管理员 域管理员 普通用户 提交API请求所有CloudStack API请求都是以HTTP GET/POST的形式提交，一个请求包含下面三部分： API的URL地址：即web服务API的入口地址(如： http://localhost:8080/client/api) 命令：你想要执行的web服务命令，如启动一个虚拟机 参数：该命令所需要的必要或可选参数 一个API请求的例子如下： 1234567891011121314http://localhost:8080/client/api?command=deployVirtualMachine&amp;serviceOfferingId=1&amp;diskOfferingId=1&amp;templateId=2&amp;zoneId=4&amp;apiKey=miVr6X7u6bN_sdahOBpjNejPgEsT35eXqjB8CG20YI3yaxXcgpyuaIRmFI_EJTVwZ0nUkkJbPmY3y2bciKwFQ&amp;signature=Lxx1DM40AjcXU%2FcaiK8RAP0O1hU%3D#第1行就是CloudStack API的URL； ####第2行表示我们想要执行的命令； ###第3-6行是该命令所需的参数，命令和参数的详情具体可以参考API文档； ##第7行是唯一标识用户的账户的API Key； #第8行是用来认证用户账户执行API命令权限的签名的哈希值 API请求的签名不管你是通过HTTP还是HTTPS的方式访问CloudStack API，都必须对请求进行签名从而让CloudStack能确认调用者已经被认证和授权执行该命令。在进行签名之前先确认你拥有API Key和管理员提供给你的账户的私钥。 以上面的API请求为例子，每个API请求都包含以下几个部分： 基本的URL：http://localhost:8080 API的路径：处理请求的API Servlet的路径：/client/api? 命令字符串：包括命令，命令的参数以及标志用户账户的API Key，需要注意的是，参数的键是不区分大小写的，而参数的值是区分大小写的 签名：使用用户的私钥和HMAC SHA-1哈希算法生成的签名 生成签名的步骤： 命令字符串中的每个键值对（以&amp;分隔开），URL对每个值进行编码从而使其能通过HTTP GET安全地发送 将命令字符串的字母全部转换成小写，并且对键值对按字母顺序进行排序，结果类似下面的形式： 123456apikey=mivr6x7u6bn_sdahobpjnejpgest35exq-jb8cg20yi3yaxxcgpyuairmfi_ejtvwz0nukkjbpmy3y2bcikwfq&amp;command=deployvirtualmachine&amp;diskofferingid=1&amp;serviceofferingid=1&amp;templateid=2&amp;zoneid=4 将排序好的命令字符串和用户的私钥使用HMAC SHA-1哈希算法进行编码，在使用Base64将结果字节数组编码成UTF-8形式，最终得到的签名为：Lxx1DM40AjcXU%2FcaiK8RAP0O1hU%3D 设置API调用失效时间在不安全的通道如HTTP上，我们可以设置一个API调用逾期时间戳来防止重播攻击（replay attacks），服务器会追踪这个时间戳，并拒绝超过这个期限的后续的所有API调用。在API请求中加入以下参数可实现这个特性： signatureVersion=3 expires=YYYY-MM-DDThh:mm:ssZ 限制API调用频率避免对管理服务器的恶意攻击，防止性能下降以及对所有账户提供一致性，当API调用超过一定阈值后会向这些调用返回错误信息。调用者需要等待一段时间后重试一下。可以通过一下全局参数来设置API的调用频率限制： api.throttling.enabled：默认为false，即不限制API调用频率 api.throttling.interval ：以秒为单位 api.throttling.max：每个间隔周期接受的最大请求数 api.throttling.cachesize：存放API调用计数器的缓存，每个账户需要一个cache来存放该账户运行的API总数 API调用频率限制的不足之处： 存在多个管理服务器的时候，不同管理服务器的cache之间不是同步的，所以可能出现允许通过的请求数比设置的值要大的情况，最糟糕的情况下可能出现允许通过的请求数为：限制值*管理服务器数量 尽管如此，CloudStack还是可以有效地避免恶意攻击导致的服务拒绝 API响应CloudStack支持两种响应格式：XML和JSON，默认的响应是XML，可以在请求URL中使用&amp;response=json来设置JSON格式的响应。使用JSON格式时，如果一个响应的键没有值，则该键不会出现在响应中，而XML仍会返回一个空的元素。 最大返回结果页对于每个云，一个命令在一个页面中返回的结果数有一个默认的上限，以此来防止云服务器过载和防止DOS攻击。每个云的默认上限值是不同的，通过全局参数default.page.size来配置。如果云上有许多用户运行了许多虚拟机的话，可以把这个值设置大一点，但要小心不要设置得太大了。 错误处理如果在处理一个API请求的时候发生了错误，会返回特定格式的响应。每个错误信息响应包含一个错误代码和一个文本描述可能出错的原因。如果用户的签名错误或没有权限导致请求被拒绝会返回一个HTTP 401错误 异步命令异步命令可以隐式地执行那些耗时很长的任务，如创建一个快照。它和同步命令有以下几点不同： API引用以一个a来区分 提交后会马上返回一个任务ID 如果是创建资源的命令，在返回任务ID的同时还会返回资源ID 使用异步命令的关键在于Job ID，它在命令被执行后马上返回。使用Job ID，通过queryAsyncJobResult命令我们可以周期性地检查任务的状态，这个命令返回3种可能的任务状态 0-Job表示程序还在进行 1-Job表示成功地完成了 2-Job表示执行失败 查询命令执行状态的命令：command=queryAsyncJobResult&amp;jobId=1","categories":[{"name":"CloudStack","slug":"CloudStack","permalink":"/categories/CloudStack/"}],"tags":[{"name":"CloudStack","slug":"CloudStack","permalink":"/tags/CloudStack/"},{"name":"云计算","slug":"云计算","permalink":"/tags/云计算/"},{"name":"api","slug":"api","permalink":"/tags/api/"}]},{"title":"VPS搭建属于自己的SS代理","slug":"VPS搭建属于自己的SS代理","date":"2019-06-10T08:09:06.000Z","updated":"2019-06-10T08:40:53.564Z","comments":true,"path":"2019/06/10/VPS搭建属于自己的SS代理/","link":"","permalink":"/2019/06/10/VPS搭建属于自己的SS代理/","excerpt":"","text":"安装shadowsocks第一条命令1234# 下载脚本shadowsocks.shwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh# 等待下载完成... 第二条命令12# 为shadowsocks.sh添加执行权限chmod +x shadowsocks.sh 第三条命令123./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log# 中间会提示我们输入一些信息 中间会提示你输入你的SS server的账号，和端口。不输入就是默认。跑完命令后会出来你的SS客户端的信息。特别注意，由于iphone端的目前只支持到cfb，所以我们选择aes-256-cfb，即7，这一步按回车继续然后需要几分钟的安装过程，请耐心等待出现下面的画面！","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"/categories/shadowsocks/"}],"tags":[{"name":"vps","slug":"vps","permalink":"/tags/vps/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"/tags/shadowsocks/"},{"name":"翻墙","slug":"翻墙","permalink":"/tags/翻墙/"}]},{"title":"Centos7.x中磁盘管理及扩展","slug":"Centos7-x中磁盘管理及扩展","date":"2019-05-28T06:51:39.000Z","updated":"2019-11-27T08:48:42.447Z","comments":true,"path":"2019/05/28/Centos7-x中磁盘管理及扩展/","link":"","permalink":"/2019/05/28/Centos7-x中磁盘管理及扩展/","excerpt":"","text":"前提要求：虚拟机：centos7.x 在安装Centos系统时，磁盘选择为LVM逻辑卷。当选择为LVM后才能创建逻辑卷等（必须） 数据格式选择的是xfs，很多讲解使用的是ext3，但以后xfs的优势会比ext越来越大。（可选） LVM是Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对硬盘分区进行管理的一种机制。LVM是建立在硬盘和分区上的逻辑层，它允许跨硬盘、分区创建逻辑卷并创建文件系统，可以很方便执行增加、扩展、删除等操作。 CentOS7查看硬盘情况 12345678910111213141516&gt; lsblk #查看分区和磁盘&gt; &gt; df -h #查看空间使用情况&gt; &gt; fdisk -l #分区工具查看分区信息&gt; &gt; cfdisk /dev/sda #查看分区&gt; &gt; blkid #查看硬盘label（别名）&gt; &gt; du -sh ./* #统计当前目录各文件夹大小&gt; &gt; free -h #查看内存大小&gt; &gt; cat /proc/cpuinfo| grep \"cpu cores\"| uniq #查看cpu核心数&gt; 扩容磁盘挂载物理卷（PV）物理卷（Physical Volume,PV）：就是指硬盘分区，也可以是整个硬盘或已创建的软RAID，是LVM的基本存储设备。在创建逻辑卷之前需要先创建物理卷，然后将多个物理卷组合创建卷组，最后在卷组的基础上创建逻辑卷。 可以将空白硬盘或分区加入主机，系统识别到新的硬盘sdb后，使用pvcreate对硬盘创建PV。 添加新硬盘或直接扩展分区的方式：`直接扩展/或直接新添加一个硬盘 12lsblk #列出系统上所有的磁盘df -h #检查文件系统的磁盘空间占用情况 可以看出磁盘vda还有200多G的空白磁盘没有挂载。 12345678910111213fdisk /dev/vda #回车p #回车n #回车默认 #回车默认 #回车默认 #回车默认 #回车t #回车默认 #回车8e #回车p #回车w #回车reboot #回车 12pvcreate /dev/vda3 #创建物理卷pvdisplay 卷组（VG）卷组（Volume Group,VG）：是由一个或多个物理卷所组成的存储池，在卷组上能创建一个或多个逻辑卷。现在使用vgcreate命令对上文创建的PV（单个物理卷）创建卷组。 12vgcreate -s 10M vg0 /dev/vda3 #创建卷组vg0,指定物理块PE大小10M,并将pv:/dev/vda3加入vg0vgdisplay # 查看所有卷组的信息.后面接具体卷组名,可查看指定卷组信息 1pvdisplay # 查看所当前物理卷的信息.后面可接具体物理卷设备,可查看指定物理卷信息 创建逻辑卷（LV）逻辑卷（Logical Volume,LV）：类似于非LVM系统中的硬盘分区，它建立在卷组之上，是一个标准的块设备，在逻辑卷之上可以建立文件系统。可以使用lvcreate命令创建逻辑卷 12345678910111213141516171819[root@hewanli-mysql ~]# lvcreate -n lv0 -l 100%vg vg0 #使用vg0的全部空间创建逻辑卷lv0 Logical volume \"lv0\" created.[root@hewanli-mysql ~]# lvdisplay --- Logical volume --- LV Path /dev/vg0/lv0 LV Name lv0 VG Name vg0 LV UUID uz1Ej1-mC6D-9MBf-Sdbc-2UQS-frMm-AsuzbC LV Write Access read/write LV Creation host, time hewanli-mysql, 2019-05-28 03:44:32 -0400 LV Status available # open 0 LV Size 249.99 GiB Current LE 25599 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:3 12345pvdisplaylsblk -f /dev/vda#会在/dev下生成一个新的设备文件：ll /dev/vg0/lv0ll /dev/dm-0 文件系统在逻辑卷lv0创建完成后还需要创建文件系统并挂载到指定目录才能够使用,当然还需要将挂载信息写入/etc/fstab文件 1234567891011121314mkfs.xfs /dev/vg0/lv0 # 创建文件系统lsblk /dev/vda -flsblk /dev/vg0/lv0 -f# 将逻辑卷挂载到指定目录（/data），如果改为其他，则以下所有/data都要改成对应的目录（根目录/不可以）if(/data目录不存在)&#123; mkdir /data &amp;&amp; mount /dev/vg0/lv0 /data&#125; else&#123; mount /dev/vg0/lv0 /data&#125;df -T # 查看挂载点blkid /dev/vg0/lv0 #注意UUID，下面命令会使用df -T /dev/vg0/lv0echo \"UUID=2fb5642b-0167-4709-9d35-85a407b4801a /data xfs defaults 0 0\" &gt;&gt; /etc/fstab #UUID填自己的（上面命令结果有输出）cat /etc/fstab | egrep \"UUID\" 12lsblk #列出系统上所有的磁盘df -h #检查文件系统的磁盘空间占用情况 扩展逻辑卷我们可以很方便的多逻辑卷进行扩展，不论是使用新的空白磁盘还是已有的空白分区。其大致实现原理为：对空白分区创建物理卷，然后将物理卷加入到需要扩展逻辑卷所在的卷组，最后扩大逻辑卷空间。如果逻辑卷所在的卷组还有空闲的空间（PE）可被使用且足够大，则甚至不需要另外的分区或者磁盘。 1lsblk -f /dev/vda 新增磁盘挂载Linux 分区命令parted简单使用步骤由于fdisk命令无法对大于2T的硬盘进行分区（MBR分区表只支持2T以下磁盘，大于2T的磁盘必须使用GPT分区表），所以需要用到parted命令实现。这里将一个12T的硬盘分成2个分区，一个7.5T,另一个4.5T，并格式化成ext4挂载。 使用parted将硬盘分为两个主分区啊 12345678910parted /dev/sdb #进入交互模式GNU Parted 1.8.1 Using /dev/sdb Welcome to GNU Parted! Type ‘help’ to view a list of commands.(parted) mklabel gpt # 将MBR磁盘格式化为GPT(parted) print #打印当前分区，由于还没有创建，所以看不到(parted) mkpart primary 0 5TB # 分一个5T的主分区(parted) mkpart primary 5TB 8TB # 再分一个3T的主分区(parted) print #再次打印分区查看信息(parted) quit #退出#使用parted命令分区后的磁盘无法再用fdisk进行分区操作 将分区格式化为ext4格式 12[root@localhost ~]# mkfs.ext4 /dev/sdb1[root@localhost ~]# mkfs.ext4 /dev/sdb2 挂载分区 1234567[root@localhost]# mount -t ext4 /dev/sdb1 /bk[root@localhost]# mount -t ext4 /dev/sdb2 /mail[root@localhost ~]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/sdb1 ext4 4.1T 194M 3.9T 1% /bk/dev/sdb2 ext4 6.8T 179M 6.4T 1% /mail 修改vi /etc/fstab，使其开机自动挂载 12/dev/sdb1 /bk ext4 defaults 1 2/dev/sdb2 /mail ext4 defaults 1 2","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Centos7.x","slug":"Centos7-x","permalink":"/tags/Centos7-x/"},{"name":"磁盘管理及扩展","slug":"磁盘管理及扩展","permalink":"/tags/磁盘管理及扩展/"}]},{"title":"Gson使用技巧","slug":"Gson使用技巧","date":"2019-05-22T07:29:44.000Z","updated":"2019-05-22T07:36:30.343Z","comments":true,"path":"2019/05/22/Gson使用技巧/","link":"","permalink":"/2019/05/22/Gson使用技巧/","excerpt":"","text":"Gson获取json字符串中key对应的值字符串 ： //得到服务器返回的具体内容 1final String res = response.body().string(); 例1：{&quot;code&quot;:100,&quot;msg&quot;:&quot;处理成功！&quot;,&quot;extend&quot;:{&quot;jsonString&quot;:{&quot;userId&quot;:1,&quot;userName&quot;:&quot;123&quot;,&quot;userPwd&quot;:&quot;123&quot;}}} 12345678910jsonObject = (JsonObject) new JsonParser().parse(res).getAsJsonObject();// 获取 code：jsonObject.get(\"code\").getAsInt();// 获取 userName：jsonObject.get(\"extend\") .getAsJsonObject().get(\"jsonString\") .getAsJsonObject().get(\"userName\") .getAsString() 例2：{&quot;code&quot;:100,&quot;msg&quot;:&quot;处理成功！&quot;,&quot;extend&quot;:{&quot;jsonString&quot;:[{&quot;userId&quot;:1,&quot;userName&quot;:&quot;123&quot;,&quot;userPwd&quot;:&quot;123&quot;}]}} 1234567891011jsonObject = (JsonObject) new JsonParser().parse(res).getAsJsonObject();// 获取 code：String code = jsonObject.get(\"code\").getAsInt();// 获取 userName：String userName = jsonObject.get(\"extend\") .getAsJsonObject().get(\"jsonString\") .getAsJsonArray().get(0) .getAsJsonObject().get(\"userName\") .getAsString()","categories":[{"name":"Gson","slug":"Gson","permalink":"/categories/Gson/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}]},{"title":"java调用外部接口","slug":"java调用外部接口","date":"2019-05-22T07:24:59.000Z","updated":"2019-05-22T07:28:42.223Z","comments":true,"path":"2019/05/22/java调用外部接口/","link":"","permalink":"/2019/05/22/java调用外部接口/","excerpt":"","text":"Java调用外部接口的方法，最终返回接口response的信息12345678910111213141516String strURL = \"这里是你要调用的接口地址\";URL url = new URL(strURL);HttpURLConnection httpConn = (HttpURLConnection)url.openConnection();httpConn.setRequestMethod(\"GET\");httpConn.connect();BufferedReader reader = new BufferedReader( new InputStreamReader(httpConn.getInputStream()));String line;StringBuffer buffer = new StringBuffer();while ((line = reader.readLine()) != null) &#123; buffer.append(line);&#125;reader.close();httpConn.disconnect();System.out.println(buffer.toString()); 最终这里buffer.toString();就是接口response的值","categories":[{"name":"调用外部接口","slug":"调用外部接口","permalink":"/categories/调用外部接口/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}]},{"title":"Jboss在Linux下的使用技巧","slug":"Jboss在Linux下的使用技巧","date":"2019-05-10T08:52:52.000Z","updated":"2019-05-10T08:52:52.601Z","comments":true,"path":"2019/05/10/Jboss在Linux下的使用技巧/","link":"","permalink":"/2019/05/10/Jboss在Linux下的使用技巧/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux下远程连接MySQL数据库","slug":"Linux下远程连接MySQL数据库","date":"2019-05-08T15:43:12.000Z","updated":"2019-08-21T09:05:34.326Z","comments":true,"path":"2019/05/08/Linux下远程连接MySQL数据库/","link":"","permalink":"/2019/05/08/Linux下远程连接MySQL数据库/","excerpt":"","text":"在服务器端开启远程访问 首先进入mysql数据库 12mysql -uroot -pEnter password: #输入密码 然后输入下面两个命令： 123456789mysql&gt; grant all privileges on *.* to 'root'@'%' identified by 'password';Query OK, 0 rows affected, 1 warning (0.00 sec)# 如果该命令报错“ERROR 1819 (HY000): Your password does not satisfy the current policy requirements”，就先执行以下两个命令后再执行上面的命令mysql&gt; set global validate_password_policy=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_length=1;Query OK, 0 rows affected (0.01 sec) 1mysql&gt; flush privileges; 第一个*是数据库，可以改成允许访问的数据库名称 第二个 是数据库的表名称，代表允许访问任意的表 root代表远程登录使用的用户名，可以自定义 %代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了 password代表远程登录时使用的密码，可以自定义 flush privileges;这是让权限立即生效 修改my.cnf配置文件 这个是mysql的配置文件，如果你无标题文章找不到在哪里的话，可以输入find /* -name my.cnf 找到通过vim编辑该文件，找到bind-address = 127.0.0.1这一句（如果没有就不管），然后在前面加个#号注释掉，保存退出 重启服务 123service mysql restart# 或者systemctl restart mysqld 开放3306端口（端口以自己实际情况为准） 123456# 查看开发端口情况firewall-cmd --list-all# 开发3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanent# 重启防火墙systemctl restart firewalld 在本地远程连接 在终端输入： 1mysql -h 服务器ip地址 -P 3306 -u root -p 然后输入密码即可。 也可以使用连接工具连接，例如Navicat","categories":[{"name":"MySQL","slug":"MySQL","permalink":"/categories/MySQL/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"远程连接","slug":"远程连接","permalink":"/tags/远程连接/"}]},{"title":"IntelliJIDEA tomcat在浏览器js乱码问题解决","slug":"IntelliJIDEA-tomcat在浏览器js乱码问题解决","date":"2019-04-28T03:30:05.000Z","updated":"2019-04-28T03:57:34.814Z","comments":true,"path":"2019/04/28/IntelliJIDEA-tomcat在浏览器js乱码问题解决/","link":"","permalink":"/2019/04/28/IntelliJIDEA-tomcat在浏览器js乱码问题解决/","excerpt":"","text":"在配置Tomcat的时候添加参数1-Dfile.encoding=UTF-8 修改idea64.exe.vmoptions和idea.exe.vmoptions文件找到idea安装目录bin目录下如下图所示两个文件，用编辑器打开，在文件末尾添加 -Dfile.encoding=UTF-8 ，然后重启idea，再打开浏览器就会发现中文已经可以正常显示了","categories":[{"name":"IDEA","slug":"IDEA","permalink":"/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"/tags/Tomcat/"},{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"},{"name":"中文乱码","slug":"中文乱码","permalink":"/tags/中文乱码/"}]},{"title":"手把手教你用frp实现内网穿透","slug":"手把手教你用frp实现内网穿透","date":"2019-04-12T07:26:19.000Z","updated":"2019-10-25T09:28:08.355Z","comments":true,"path":"2019/04/12/手把手教你用frp实现内网穿透/","link":"","permalink":"/2019/04/12/手把手教你用frp实现内网穿透/","excerpt":"","text":"frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 数据准备： 公网IP: X.X.X.X 内网电脑使用的是两台win10-64系统（公司+家里） 公网电脑为linux-64系统。 服务端配置文件下载下载地址：frp下载 具有公网IP的电脑将作为frp服务端(frps)，首先去项目地址的releases页面下载与服务端系统匹配的文件并解压 123456# 进入home目录cd /home# 下载对应的frp作为服务端wget https://github.com/fatedier/frp/releases/download/v0.26.0/frp_0.26.0_linux_amd64.tar.gz# 解压tar -zxvf frp_0.26.0_linux_amd64.tar.gz 编辑配置文件1234# 进入frpcd frp_0.26.0_linux_amd64/# 编辑frps.ini配置文件（一般不需要更改）vim frps.ini 编辑frps.ini为以下内容： bind_port为客户端与服务端进行通信的端口。其它更丰富的配置可参考frps_full.ini和项目帮助文档。 启动服务端进行到解压后的frp目录，然后通过./frps -c frps.ini命令即可启动服务端，如下图所示： 12345cd /home/frp_0.26.0_linux_amd64/# 前台启动（终端关闭进程终端）./frps -c frps.ini# 后台启动nohup ./frps -c frps.ini 设置开机启动和后台运行上一步中的frps占据了整个命令窗口，所以接下来要考虑如何让它在后台运行并且开机自启：参考Nan&#39;s Blog的《系统开机启动脚本》文章。 客户端配置文件下载具有内网IP的电脑将作为客户端(frpc)，在releases页面下载frp_0.16.0_windows_amd64.zip解压 编辑配置文件编辑frpc.ini为以下内容： 12345678910111213141516171819[common]# sever_addr配置为公网电脑的IPserver_addr = X.X.X.X# server_port与frps.ini（服务端）中的bind_port一致server_port = 7000# 两台或者多条客户端“ssh”要不一样，否则会有冲突导致启动失败# 举例：[ssh-home]、[ssh-company][ssh]type = tcplocal_ip = 127.0.0.1# 本地客户端对应的端口# windows填3389，linux系统填22local_port = 3389# 对应云端服务器的端口# 注：# 1，所有remote_port对应的端口必须在云端服务器中开放，否则无法进行访问# 2，两台或者多台客户端remote_port必须不一样remote_port = 6000 启动客户端双击frpc.exe或者用命令 frpc -c frpc.ini即可启动客户端，如下图所示： 注意：这时候很可能启动不了，一般情况是因为服务器端（linux）7000端口没开放： 123456# 查看端口开放情况firewall-cmd --list-all# 添加开放端口firewall-cmd --zone=public --add-port=7000/tcp --permanent# 重启防火墙systemctl restart firewalld 然后再执行frpc -c frpc.ini就可以正常启动连接了。 设置开机启动和后台运行参考Nan&#39;s Blog的《系统开机启动脚本》文章。","categories":[{"name":"内网穿透","slug":"内网穿透","permalink":"/categories/内网穿透/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"frp","slug":"frp","permalink":"/tags/frp/"},{"name":"Windows","slug":"Windows","permalink":"/tags/Windows/"}]},{"title":"CloudStack介绍","slug":"CloudStack介绍","date":"2019-04-04T06:27:56.000Z","updated":"2020-06-24T07:57:37.342Z","comments":true,"path":"2019/04/04/CloudStack介绍/","link":"","permalink":"/2019/04/04/CloudStack介绍/","excerpt":"","text":"基本上，云计算只是一种把 IT 资源当作服务来提供的手段。几乎所有 IT 资源都可以作为云服务来提供：应用程序、计算能力、存储容量、联网、编程工具，以至于通信服务和协作工具。 云计算最早为 Google、Amazon 等其他扩建基础设施的大型互联网服务提供商所采用。于是产生一种架构：大规模扩展、水平分布的系统资源，抽象为虚拟 IT 服务，并作为持续配置、合用的资源进行管理。 就最终用户而言，云计算意味着没有硬件购置成本、没有需要管理的软件许可证或升级、不需要雇佣新的员工或咨询人员、不需要租赁设施、没有任何种类的基建投资，而且还没有隐性成本。只是一种用仪表测量出来的、根据使用情况支付的订购费或固定的订购费。只是用您所需的量，而且只按使用量付费。 云计算结构图如下： 基础设施当做服务（IaaS）基础设施当作服务 (IaaS) 处于最低层级，而且是一种作为标准化服务在网上提供基本存储和计算能力的手段。服务器、存储系统、交换机、路由器和其他系统协作 (例如，通过虚拟化技术) 处理特定类型的工作负载 — 从批处理到峰值负载期间的服务器/存储扩大。 最著名的商业示例是 Amazon Web 服务 (AWS)，其 EC2 和 S3 服务分别提供基本计算和存储服务。国内代表阿里云、腾讯云、百度云、金山云等。 优势： 利用率更高 — 在虚拟化之前，企业数据中心的服务器和存储利用率一般平均不到 50% (事实上，通常利用率为 10% 到 15%)。通过虚拟化，可以把工作负载封装一并转移到空闲或使用不足的系统，这就意味着可以整合现有系统，因而可以延迟或避免购买更多服务器容量。 资源整合 — 虚拟化使得整合多个 IT 资源成为可能。除服务器和存储整合之外，虚拟化提供一个整合系统架构、应用程序基础设施、数据和数据库、接口、网络、桌面系统甚至业务流程，因而可以节约成本和提高效率。 节省电能/成本 — 运行企业级数据中心所需的电能不再无限制地使用，而成本呈螺旋式上升趋势。在服务器硬件上每花一美元，就会在电费上增加一美元 (包括服务器运行和散热方面的成本)。利用虚拟化进行整合使得降低总能耗和节约大量资金成为可能。 节约空间 — 服务器膨胀仍然是多数企业数据中心面临的一个严重问题，可扩大数据中心并不总是一个良好的选择，因为每增大一平方米空间，就会平均增加很多成本。虚拟化通过把多个虚拟系统整合到较少物理系统上，可以缓解空间压力。 灾难恢复 (Disaster recovery) /业务连续 (Business Continuity) — 虚拟化可提高总体服务级利用率，并提供灾难恢复解决方案新选项。 CloudStack 介绍官网：http://cloudstack.apache.org/ CloudStack是一个开源的具有高可用性及扩展性的云计算平台CloudStack 是一个开源的云操作系统，它可以帮助用户利用自己的硬件提供类似于Amazon EC2那样的公共云服务。CloudStack可以通过组织和协调用户的虚拟化资源，构建一个和谐的环境。 CloudStack是一个开源的具有高可用性及扩展性的云计算平台CloudStack 是一个开源的云操作系统，它可以帮助用户利用自己的硬件提供类似于Amazon EC2那样的公共云服务。CloudStack可以通过组织和协调用户的虚拟化资源，构建一个和谐的环境。 Cloudstack支持管理大部分主流的hypervisors，如KVM，XenServer，VMware，Oracle VM，Xen等。 CloudStack 部署图如下： Zone：Zone 对应于现实中的一个数据中心，它是 CloudStack 中最大的一个单元。 即从包含关系上来说，一个 zone 包含多个 pod，一个 pod 包含多个 cluster，一个 cluster 包含多个 host。 提供点（Pods）：一个提供点通常代表一个机架，机柜里面的主机在同一个子网，每个区域中必须包含一个或多个提供点，提供点中包含主机和主存储服务器， CloudStack 的内部管理通信配置一个预留 IP 地址范围。预留的 IP 范围对云中的每个区域来说必须唯一。 集群（Clusters）：Cluster 是多个主机组成的一个集群。 ​ 同一个cluster中的主机有相同的硬件，相同的 Hypervisor，和共用同样的存储。同一个 cluster 中的虚拟机，可以实现无中断服务地从一个主机迁移到另外一个上。 ​ 集群由一个或多个宿主机和一个或多个主要存储服务器构成。集群的大小取决于下层虚拟机软件。大多数情况下基本无建议。当使用VMware时，每个VMware集群都被vCenter 服务器管理。管理员必须在本产品中登记vCenter。每个zone下可以有多个vCenter服务器。每个vCenter服务器可能管理多个VMware集群 主机（Hosts）： Host 就是运行的虚拟机（VM）主机。宿主机就是个独立的计算机。宿主机运行来宾虚拟机并提供其相应的计算资源。每个宿主机都装有虚拟机软件来运行来宾虚拟机。比如一个开启了kvm支持的服务器，一个思杰XenServer服务器，或者一个ESXi服务器都可以作为宿主机。 宿主机在CloudStack部署中属于最小的组织单元。宿主机包含于集群中，集群又属于提供点，而区域中包含提供点（就是在逻辑概念上zone&gt;pod&gt;cluster&gt;host），新增的宿主机可以随时添加以提供更多资源给来宾虚拟机，CloudStack自动探测宿主机的cpu数量和内存资源。宿主机对终端用户不可见。终端用户不能决定他们的虚拟机被分配到哪台宿主机。 CloudStack 中存在两种存储： Primary storage：一级存储与 cluster 关联，它为该 cluster 中的主机的全部虚拟机提供磁盘卷。一个 cluster 至少有一个一级存储，且在部署时位置要临近主机以提供高性能。 Secondary storage：二级存储与 zone 关联，它存储模板文件，ISO 镜像和磁盘卷快照。","categories":[{"name":"CloudStack","slug":"CloudStack","permalink":"/categories/CloudStack/"}],"tags":[{"name":"CloudStack","slug":"CloudStack","permalink":"/tags/CloudStack/"},{"name":"介绍","slug":"介绍","permalink":"/tags/介绍/"}]},{"title":"搭建http服务器-nginx","slug":"搭建http服务器-nginx","date":"2019-04-04T03:49:55.000Z","updated":"2020-02-25T07:18:14.233Z","comments":true,"path":"2019/04/04/搭建http服务器-nginx/","link":"","permalink":"/2019/04/04/搭建http服务器-nginx/","excerpt":"","text":"编译安装nginx参考：https://blog.csdn.net/w410589502/article/details/70787468 安装安装 nginx 1yum -y install nginx 这一步可能会遇到&quot;No package nginx available.&quot;问题，解决方法如下： 问题处理问题描述：见下图 问题原因： nginx位于第三方的yum源里面，而不在centos官方yum源里面 解决方法（一）： 安装epel(Extra Packages for Enterprise Linux) 去epel网站下载对应版本 我的系统是centos7.6，cpu是x86_64 123456789# 下载epelwget https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpmorwget https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-12.noarch.rpm# 安装epelrpm -ivh epel-release-7-11.noarch.rpmorrpm -ivh epel-release-7-12.noarch.rpm 再次执行 yum install nginx,则会提示安装成功了 解决方法（二）： 出现这个的原因是因为本地yum源中没有我们想要的nginx，那么我们就需要创建一个/etc/yum.repos.d/nginx.repo的文件，新增一个yum源 12345678vim /etc/yum.repos.d/nginx.repo#在文件中写入以下内容：[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 退出保存后，再次执行 yum install nginx,则会提示安装成功了 配置 删除/usr/share/nginx/html/目录下的所有文件 1rm -rf /usr/share/nginx/html/* 防火墙中加入允许80 端口访问 1234567891011121314## 加入80端口（--permanent永久生效，没有此参数重启后失效）firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --zone=public --add-port=1000-2000/tcp --permanent# 重新载入firewall-cmd --reload# 查看firewall-cmd --zone=public --query-port=80/tcp# 删除firewall-cmd --zone=public --remove-port=80/tcp --permanent## 附加：# 显示防火墙应用列表firewall-cmd --list-all 重启防火墙 1systemctl restart firewalld 编辑/etc/nginx/nginx.conf配置文件，加入如下信息（追加到末尾），使能够访问目录 123autoindex on;# 显示目录autoindex_exact_size on;# 显示文件大小autoindex_localtime on;# 显示文件时间 启动nginx 12systemctl start nginxsystemctl enable nginx 启用将镜像上传到/usr/share/nginx/html目录，在浏览器访问可以看见如下图所示的文件信息，点击可下载 附加Nginx 显示中文乱码解决需要修改nginx的server的配置内容，增加一行：charset utf-8; 情如下： 12345678910111213upstream you.domainName.com &#123; server 127.0.0.1:8081;&#125; server &#123; listen 80; server_name you.domainName.com; charset utf-8; location /examples &#123; return 403; &#125; ....&#125; 重启Nginx服务(nginx -s reload)。最后，刷新，一切正常！ 执行nginx -s reload的问题解决unknown directive &quot;stream&quot; in /etc/nginx/nginx.conf问题 在nginx.conf的第一行插入： 123load_module /usr/lib/nginx/modules/ngx_stream_module.so;# find / -name 'ngx_stream_module.so' -print 如果ngx_stream_module.so地址不对 12[root@localhost ~]# find / -name 'ngx_stream_module.so' -print/usr/lib64/nginx/modules/ngx_stream_module.so 然后换成真实地址即可！问题解决。 问题 重置（nginx -s reload）nginx出现这个错误 1nginx: [error] open() \"/usr/local/var/run/nginx.pid\" failed (2: No such file or directory) 解决方法：找到你的nginx.conf的文件夹目录，然后运行这个： 123# 例如：找到的nginx.conf的文件夹目录为：“/etc/nginx/nginx.conf”# 执行以下命令nginx -c /etc/nginx/nginx.conf 再运行nginx -s reload，就可以了","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"ngnix","slug":"ngnix","permalink":"/tags/ngnix/"}]},{"title":"CloudStack安装配置应用操作手册","slug":"CloudStack安装配置应用操作手册","date":"2019-04-03T09:32:32.000Z","updated":"2020-06-24T07:57:49.444Z","comments":true,"path":"2019/04/03/CloudStack安装配置应用操作手册/","link":"","permalink":"/2019/04/03/CloudStack安装配置应用操作手册/","excerpt":"","text":"CloudStack介绍介绍见： CloudStack介绍 CloudStack安装先决条件 至少两台（cloudstack-management和cloudstack-agent）支持并启用了硬件虚拟化的计算机。 一个CentOS的7.5 x86_64的ISO安装文件 网关位于xxx.xxx.xxx.1的A / 24网络，该网络上不应该有DHCP，运行CloudStack的计算机都不会有动态地址。同样，这是为了简单起见。 环境准备一套基本的CloudStack环境，包括一台CloudStack管理端（cloudstack-management），一个mysql数据库，若干台支持KVM虚拟化的计算节点（cloudstack-agent）以及一台用来做为二级存储的nfs服务器： 在实际生产中，mysql数据库和管理端都可能配备多台作为高可用，计算节点一般也是配置较高的物理服务器，但在实验环境，我们可以采用最小化安装模式，把mysql,nfs和管理端安装在同一台虚拟机上，使用一台支持KVM虚拟化的虚拟机用来作为计算节点 我们的环境本文使用两台虚拟机来搭建我们的环境，nfs,mysql和管理端都装在同一台虚拟机上，cloudstack-agent安装在一台开启了虚拟化支持的虚拟机上，部署架构如下： 定义 两台服务器的IP是： CloudStack管理端（cloudstack-management）：172.18.193.1 KVM虚拟化的计算节点（cloudstack-agent）：172.18.193.2 CloudStack管理端升级yum1yum -y upgrade 主机名CloudStack要求正确设置主机名。如果您在安装中使用了默认选项，那么您的主机名当前设置为localhost.localdomain。为了测试这个，我们将运行： 1hostname --fqdn 此时它可能会返回： 1localhost 要纠正这种情况 - 我们将通过编辑/etc/hosts文件来设置主机名，以便它遵循与此示例类似的格式： 12345678127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6172.18.193.1 mng.cloud.priv172.18.193.1 mng172.18.193.2 cloud1.cloud.priv172.18.193.2 cld172.18.0.1 gw61.139.2.69 dns 修改完该文件后，重新启动网络： 1systemctl restart network 现在使用hostname -fqdn命令重新检查并确保它返回FQDN响应 设置SELinux目前，要使CloudStack正常工作，SELinux必须设置为允许。我们希望为将来的引导配置它，并在当前运行的系统中对其进行修改。 要在运行的系统中将SELinux配置为允许，我们需要运行以下命令： 1setenforce 0 为了确保它保持在该状态，我们需要配置文件/etc/selinux/config以反映许可状态，如下例所示： 12345678910# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of these two values:# targeted - Targeted processes are protected,# mls - Multi Level Security protection.SELINUXTYPE=targeted NTP安装NTP配置是保持云服务器中所有时钟同步的必要条件。但是，默认情况下不安装NTP。所以我们将在此阶段安装和配置NTP。安装完成如下： 1yum -y install ntp 实际的默认配置适用于我们的目的，因此我们只需要启用它并将其设置为在启动时启动，如下所示： 12systemctl enable ntpdsystemctl start ntpd 配置CloudStack包存储库我们需要将机器配置为使用CloudStack软件包存储库。 要添加CloudStack存储库，请创建/etc/yum.repos.d/cloudstack.repo并插入以下信息。 12345[cloudstack]name=cloudstackbaseurl=http://download.cloudstack.org/centos/7/4.11/enabled=1gpgcheck=0 NFS 安装我们的配置将使用NFS进行主存储和二级存储。我们将继续为此目的设置两个NFS共享。我们首先安装nfs-utils。 1yum -y install nfs-utils 我们现在需要配置NFS以提供两个不同的共享。这在/etc/exports文件中相对容易处理。您应该确保它具有以下内容： 12/data/primary *(rw,async,no_root_squash,no_subtree_check)/data/secondary *(rw,async,no_root_squash,no_subtree_check) 您将注意到我们在系统上指定了两个目录（尚未存在）。我们将继续使用以下命令创建这些目录并在其上适当地设置权限： 12mkdir -p /data/primarymkdir /data/secondary CentOS 7.x版本默认使用NFSv4。NFSv4要求域设置在所有客户端上匹配。在我们的示例中，域是cloud.priv，因此请确保取消注释/etc/idmapd.conf中的域设置并设置如下： 1Domain = cloud.priv 现在，您需要在/etc/sysconfig/nfs文件的底部添加配置值（或者仅取消注释并设置它们） 123456LOCKD_TCPPORT=32803LOCKD_UDPPORT=32769MOUNTD_PORT=892RQUOTAD_PORT=875STATD_PORT=662STATD_OUTGOING_PORT=2020 现在我们需要禁用防火墙，这样它就不会阻止连接 12systemctl stop firewalldsystemctl disable firewalld 我们现在需要配置nfs服务以在启动时启动，并通过执行以下命令实际在主机上启动它： 1234systemctl enable rpcbindsystemctl enable nfssystemctl start rpcbindsystemctl start nfs 重新启动nfs 1systemctl restart nfs 测试nfs服务端是否能访问 在 agent端执行showmount -e 172.18.193.1 管理服务器安装数据库安装和配置我们将首先安装MySQL并配置一些选项，以确保它与CloudStack一起运行良好。 首先，由于CentOS 7不再提供MySQL二进制文件，我们需要添加一个存储库： 123wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum -y update 通过运行以下命令进行安装： 1yum -y install mysql-server 现在安装了MySQL，我们需要对/etc/my.cnf进行一些配置更改。具体来说，我们需要在[mysqld]部分添加以下选项： 12345innodb_rollback_on_timeout=1innodb_lock_wait_timeout=600max_connections=350log-bin=mysql-binbinlog-format = 'ROW' 现在MySQL已正确配置，我们可以启动它并将其配置为在启动时启动，如下所示： 12systemctl enable mysqldsystemctl start mysqld MySQL连接器安装使用官方MySQL软件包存储库安装Python MySQL连接器。/etc/yum.repos.d/mysql.repo使用以下内容创建文件： 12345[mysql-connectors-community]name=MySQL Community connectorsbaseurl=http://repo.mysql.com/yum/mysql-connectors-community/el/$releasever/$basearch/enabled=1gpgcheck=1 从MySQL导入GPG公钥： 1rpm --import http://repo.mysql.com/RPM-GPG-KEY-mysql 安装mysql-connector 1yum install mysql-connector-python 安装管理服务器我们现在要安装管理服务器。我们通过执行以下命令来做到这一点： 1yum -y install cloudstack-management 当yum -y install cloudstack-management命令不好使的时候，操作如下： 1234wget http://download.cloudstack.org/centos/7/4.11/cloudstack-management-4.11.2.0-1.el7.centos.x86_64.rpmwget http://download.cloudstack.org/centos/7/4.11/cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpmyum localinstall cloudstack-management-4.11.2.0-1.el7.centos.x86_64.rpm cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpm 安装了应用程序本身后，我们现在可以设置数据库，我们将使用以下命令和选项执行此操作： 1cloudstack-setup-databases cloud:password@localhost --deploy-as=root 完成此过程后，您应该看到“CloudStack has successfully initialized the database.”之类的消息。 既然已经创建了数据库，我们可以通过发出以下命令来设置管理服务器的最后一步： 1cloudstack-setup-management 系统模板设置CloudStack使用许多系统VM来提供访问虚拟机控制台，提供各种网络服务以及管理存储的各个方面的功能。当我们引导您的云时，此步骤将获取准备部署的系统映像。 现在我们需要下载系统VM模板并将其部署到我们刚刚挂载的共享。管理服务器包括用于正确操纵系统VMs映像的脚本。 12/usr/share/cloudstack-common/scripts/storage/secondary/cloud-install-sys-tmplt -m /data/secondary -u http://download.cloudstack.org/systemvm/4.11/systemvmtemplate-4.11.2-kvm.qcow2.bz2 -h kvm -F 这就结束了我们的管理服务器的安装 CloudStack计算节点升级yum1yum -y upgrade 配置网络要将其配置为在您的环境中工作。由于我们指定在此环境中不存在DHCP服务器，因此我们将手动配置您的网络接口。 在继续之前，请确保安装了“brctl”并且可用： 1yum install bridge-utils -y 通过控制台连接，您应该以root用户身份登录。我们将首先创建Cloudstack将用于网络的桥梁。创建并打开vi /etc/sysconfig/network-scripts/ifcfg-cloudbr1并添加以下设置： IP寻址 - 在本文档中，我们假设您将拥有一个用于CloudStack实施的/24网络。这可以是任何RFC 1918网络。 123456789101112DEVICE=cloudbr1TYPE=BridgeONBOOT=yesBOOTPROTO=noneIPV6INIT=noIPV6_AUTOCONF=noDELAY=5IPADDR=172.18.193.2PREFIX=16GATEWAY=172.18.0.1DNS1=61.139.2.69STP=yes 保存配置并退出。 打开vi /etc/sysconfig/network-scripts/ifcfg-em1配置文件并按如下所示进行配置： 接口名称仅用作示例。将em1替换为您的默认以太网接口名称。 12345DEVICE=em1TYPE=EthernetONBOOT=yesBOOTPROTO=noneBRIDGE=cloudbr1 现在我们已经正确设置了配置文件，我们需要运行一些命令来启动网络： 12systemctl enable networksystemctl restart network 请注意，如果您通过SSH连接，则会暂时（约5秒，具体取决于硬件）断开连接。如果断开连接，则配置中存在错误。 主机名CloudStack要求正确设置主机名。如果您在安装中使用了默认选项，那么您的主机名当前设置为localhost.localdomain。为了测试这个，我们将运行： 1hostname --fqdn 此时它可能会返回： 1localhost 要纠正这种情况 - 我们将通过编辑vi /etc/hosts文件来设置主机名，以便它遵循与此示例类似的格式： 123456789127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6172.18.193.1 mng.cloud.priv172.18.193.1 mng172.18.193.2 cloud1.cloud.priv172.18.193.2 cld1...#(这里按以上格式添加新增计算节点)172.18.0.1 gw61.139.2.69 dns 修改完该文件后，重新启动网络： 1systemctl restart network 现在使用hostname -fqdn命令重新检查并确保它返回FQDN响应（如下：） 12345678910111213141516171819202122232425262728293031323334hostname: invalid option -- 'q'Usage: hostname [-b] &#123;hostname|-F file&#125; set host name (from file) hostname [-a|-A|-d|-f|-i|-I|-s|-y] display formatted name hostname display host name &#123;yp,nis,&#125;domainname &#123;nisdomain|-F file&#125; set NIS domain name (from file) &#123;yp,nis,&#125;domainname display NIS domain name dnsdomainname display dns domain name hostname -V|--version|-h|--help print info and exitProgram name: &#123;yp,nis,&#125;domainname=hostname -y dnsdomainname=hostname -dProgram options: -a, --alias alias names -A, --all-fqdns all long host names (FQDNs) -b, --boot set default hostname if none available -d, --domain DNS domain name -f, --fqdn, --long long host name (FQDN) -F, --file read host name or NIS domain name from given file -i, --ip-address addresses for the host name -I, --all-ip-addresses all addresses for the host -s, --short short host name -y, --yp, --nis NIS/YP domain nameDescription: This command can get or set the host name or the NIS domain name. You can also get the DNS domain or the FQDN (fully qualified domain name). Unless you are using bind or NIS for host lookups you can change the FQDN (Fully Qualified Domain Name) and the DNS domain name (which is part of the FQDN) in the /etc/hosts file. 设置SELinux目前，要使CloudStack正常工作，SELinux必须设置为允许。我们希望为将来的引导配置它，并在当前运行的系统中对其进行修改。 要在运行的系统中将SELinux配置为允许，我们需要运行以下命令： 1setenforce 0 为了确保它保持在该状态，我们需要配置文件vi /etc/selinux/config以反映许可状态，如下例所示： 12345678910# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of these two values:# targeted - Targeted processes are protected,# mls - Multi Level Security protection.SELINUXTYPE=targeted NTP安装NTP配置是保持云服务器中所有时钟同步的必要条件。但是，默认情况下不安装NTP。所以我们将在此阶段安装和配置NTP。安装完成如下： 1yum -y install ntp 实际的默认配置适用于我们的目的，因此我们只需要启用它并将其设置为在启动时启动，如下所示： 12systemctl enable ntpdsystemctl start ntpd 配置CloudStack包存储库（可不做该操作）要添加CloudStack存储库，请创建vi /etc/yum.repos.d/cloudstack.repo并插入以下信息. 12345[cloudstack]name=cloudstackbaseurl=http://download.cloudstack.org/centos/7/4.11/enabled=1gpgcheck=0 KVM设置和安装KVM是我们将要使用的虚拟机管理程序 - 您可以使用相同的步骤将其他KVM节点添加到您的CloudStack环境中。 安装节点服务器1yum -y install cloudstack-agent 当yum -y install cloudstack-agent命令不好使的时候，操作如下： 123456# 下载wget http://download.cloudstack.org/centos/7/4.11/cloudstack-agent-4.11.2.0-1.el7.centos.x86_64.rpmwget http://download.cloudstack.org/centos/7/4.11/cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpm# 安装yum -y localinstall cloudstack-agent-4.11.2.0-1.el7.centos.x86_64.rpm cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpm 我们有两个不同的KVM部分需要配置，libvirt和QEMU。 QEMU配置KVM配置只在一个项目上相对简单。我们需要编辑QEMU VNC配置。这是通过编辑vi /etc/libvirt/qemu.conf并确保以下行存在并取消注释来完成的。 1vnc_listen=0.0.0.0 Libvirt配置CloudStack使用libvirt来管理虚拟机。因此，正确配置libvirt至关重要。Libvirt是云代理的依赖，应该已经安装。 为了实现实时迁移，libvirt必须监听不安全的TCP连接。我们还需要关闭libvirts尝试使用多播DNS广告。这两个设置都在vi /etc/libvirt/libvirtd.conf中 设置以下参数： 12345listen_tls = 0listen_tcp = 1tcp_port = \"16509\"auth_tcp = \"none\"mdns_adv = 0 在libvirtd.conf中打开“listen_tcp”是不够的，我们还要更改参数，我们还需要修改vi /etc/sysconfig/libvirtd： 取消注释以下行： 1LIBVIRTD_ARGS=-l 重启libvirt 1systemctl restart libvirtd 设置agent主机的vi /etc/cloudstack/agent/agent.properties123456789101112131415161718#Storage#Mon Aug 05 08:53:35 EDT 2019guest.network.device=cloudbr3 #关键点workers=5private.network.device=cloudbr3 #关键点port=8250resource=com.cloud.hypervisor.kvm.resource.LibvirtComputingResourcepod=1zone=1hypervisor.type=kvmguid=1338039a-7a8b-3e28-ad3b-0f327b0c853apublic.network.device=cloudbr3 #关键点cluster=1local.storage.uuid=094838a5-45f8-4395-87e2-f935acee06bakeystore.passphrase=qGPHZ4p2CBHq6WQ6domr.scripts.dir=scripts/network/domr/kvmLibvirtComputingResource.id=5host=172.18.193.1 #关键点 或者 1234567891011121314151617#Storage#Mon Aug 05 08:53:37 EDT 2019workers=5private.network.device=cloudbr2 #关键点port=8250resource=com.cloud.hypervisor.kvm.resource.LibvirtComputingResourcepod=1zone=1hypervisor.type=kvmguid=ae201417-3dbc-324b-bd5e-69aebfdb6f05cluster=1public.network.device=cloudbr2 #关键点local.storage.uuid=e45c631a-fb3d-4fb0-b9f6-f68a83dd1693domr.scripts.dir=scripts/network/domr/kvmkeystore.passphrase=k93EXpDZMnXvjRMZhost=172.18.193.1 #关键点LibvirtComputingResource.id=4 /etc/cloudstack/agent/agent.properties中的内容可以手动在agent上面执行添加主机的命令。具体添加主机的命令可以在management的日志中获得： 1234567cat /var/log/cloudstack/management/management-server.log | grep cloudstack-setup-agent# 输出（如果没有输出，就在也页面上添加下主机后再执行以上命令）2014-03-13 09:56:17,758 DEBUG [utils.ssh.SSHCmdHelper] (catalina-exec-11:null) Executing cmd: cloudstack-setup-agent -m 192.168.153.28 -z 2 -p 2 -c 2 -g 0d21492f-9565-329d-9a26-0c85f6d39d12 -a --pubNic=cloud0 --prvNic=cloud0 --guestNic=cloud02014-03-13 09:56:52,775 DEBUG [utils.ssh.SSHCmdHelper] (catalina-exec-11:null) cloudstack-setup-agent -m 192.168.153.28 -z 2 -p 2 -c 2 -g 0d21492f-9565-329d-9a26-0c85f6d39d12 -a --pubNic=cloud0 --prvNic=cloud0 --guestNic=cloud0 output:CloudStack Agent setup is done!2014-03-13 11:12:22,455 DEBUG [utils.ssh.SSHCmdHelper] (catalina-exec-12:null) Executing cmd: cloudstack-setup-agent -m 192.168.153.28 -z 3 -p 3 -c 3 -g 0d21492f-9565-329d-9a26-0c85f6d39d12 -a --pubNic=cloud0 --prvNic=cloud0 --guestNic=cloud02014-03-13 11:12:57,267 DEBUG [utils.ssh.SSHCmdHelper] (catalina-exec-12:null) cloudstack-setup-agent -m 192.168.153.28 -z 3 -p 3 -c 3 -g 0d21492f-9565-329d-9a26-0c85f6d39d12 -a --pubNic=cloud0 --prvNic=cloud0 --guestNic=cloud0 output:CloudStack Agent setup is done! 比如我上面的例子,得到如下命令，并在agent上面执行： 12345678910[root@kvm01 ~]# cloudstack-setup-agent -m 172.18.193.1 -z 1 -p 1 -c 1 -g 4b68fece-7efd-3f85-9450-e875eaa6fb29 -a -s --pubNic=cloudbr0 --prvNic=cloudbr0 --guestNic=cloudbr0 --hypervisor=kvmStarting to configure your system:Configure SElinux ... [OK]Configure Network ... [OK]Configure Libvirt ... [OK]Configure Firewall ... [OK]Configure Nfs ... [OK]Configure cloudAgent ... [OK]CloudStack Agent setup is done![root@kvm01 ~]# KVM配置完成 为了完整起见，您应该检查KVM在您的计算机上是否正常运行： 123456lsmod | grep kvm# 输出kvm_intel 183705 47 kvm 615914 1 kvm_intelirqbypass 13503 37 kvm 这就结束了我们对KVM的安装和配置，现在我们将使用CloudStack UI来实际配置我们的云。 CloudStack系统配置访问地址： 12http://&lt;management-server-ip-address&gt;:8080/client# 即：http://172.18.193.1:8080/client 如果管理服务器是全新的安装,那么会出现一个安装向导。在稍后的访问中，你将看到一个登录界面,，你需要通过用户名和密码登入来查看你的仪表盘。 123用户名 -&gt; 你账号的用户ID。默认用户名是admin。密码 -&gt; 用户ID对应的密码。默认用户名的密码是password。域 -&gt; 如果你是root用户，此处留空即可。 CloudStack用户界面帮助云基础设施的用户查看和使用他们的云资源，包括虚拟机、模板和ISO、数据卷和快照、宾客网络，以及IP 地址。如果用户是一个或多个CloudStack项目的成员或管理员，用户界面能提供一个面向项目的视图。 选择”我以前是用过CloudStack，跳过此指南”按钮 选择“资源域” 选择“添加资源域” 选择“基本”网络，点击”下一步” 1234567# 配置内容如下:名称：Zone1IPV4 DNS1：61.139.2.69内部 DNS1：虚拟机选择“KVM”网络方案默认# 这些内容包括下面的填写仅为参考值。可根据实际情况进行修改 点击”下一步” 12# 配置内容如下:物理网络名称:默认 #也可键入cloudstack-management实际网络名称 点击”下一步” 123456# 配置内容如下:提供名称：Pod1预留的系统网关：172.18.0.1预留的系统网络掩码：255.255.0.0起始预留系统IP：172.18.193.3结束预留系统IP：172.18.193.254 点击”下一步” 12345# 配置内容如下:来宾网关：172.18.0.1来宾网络掩码：255.255.0.0来宾起始IP:172.18.194.1来宾结束IP：172.18.194.254 点击”下一步” 123# 配置内容如下:虚拟机管理程序：KVM集群名称：Cluster 点击”下一步” 12345# 配置内容如下:主机名称：172.18.193.2 #cloudstack-agent计算节点地址用户名：root #cloudstack-agent计算节点用户名密码：password #cloudstack-agent计算节点密码主机标签：可不填 点击”下一步” 1234567# 配置内容如下:名称：primary #不是固定的，自己根据需要进行区分即可范围：选择群集协议：选择nfs服务器：172.18.193.1路径：/data/primary #根据安装时的配置填写存储路径：可不填 点击”下一步” 12345# 配置内容如下:提供程序：选择NFS名称：secondary #不是固定的，自己根据需要进行区分即可服务器：172.18.193.1路径：/data/secondary #根据安装时的配置填写 点击”下一步” 点击“启动资源域” 成功后，先不启动资源域，我们可以先看下基础架构 此时系统VM为0 资源启动成功后，系统VM会出现2台 系统VM是不同于主机上创建的普通虚拟机的，他们是CloudStack云平台自带的用于完成自身的一些任务的虚拟机。 Secondary Storage VM：简称为SSVM，用于管理二级存储的相关操作，如模板跟镜像文件的上传与下载，快照，volumes的存放，第一次创建虚拟机时从二级存储拷贝模板到一级存储并且自动创建快照，每一个资源域可以有多个SSVM，当SSVM被删除或停止，它会自动被重建并启动。 Console Proxy VM：用于在web 界面上展示控制台。 通过查看控制台访问里面的虚拟机 CloudStack 虚拟机实例虚拟机实例默认的模板并没有被下载 修改全局设置secstorage.allowed.internal.sites设置 ，二级存储ISO镜像和模板可以下载，IP网段 重启服务systemctl restart cloudstack-management 搭建http服务器-nginx目的：注册ISO时需要填镜像的url，实时下载镜像，外网或者网速不是很好下载会很慢甚至下载失败，故搭建自己的http服务器以便在内网下载镜像，这样速度会快很多。 注 ：在cloudstack-management管理服务器节点搭建nginx 操作教程见：搭建http服务器-nginx 制作模板注册ISO 接下来按步骤走，就可以创建出第一个虚拟机了。","categories":[{"name":"CloudStack","slug":"CloudStack","permalink":"/categories/CloudStack/"}],"tags":[{"name":"虚拟机分配","slug":"虚拟机分配","permalink":"/tags/虚拟机分配/"},{"name":"安装指南","slug":"安装指南","permalink":"/tags/安装指南/"},{"name":"CloudStack","slug":"CloudStack","permalink":"/tags/CloudStack/"}]},{"title":"Java8 实现下载网页的完整代码","slug":"Java8-实现下载网页的完整代码","date":"2019-03-12T07:56:01.000Z","updated":"2019-03-12T08:22:42.205Z","comments":true,"path":"2019/03/12/Java8-实现下载网页的完整代码/","link":"","permalink":"/2019/03/12/Java8-实现下载网页的完整代码/","excerpt":"","text":"java8 实现网页下载，大致分为4步，分别是:给定目标网页链接-&gt;与目标主机建立连接-&gt;读入网页文件流-&gt;写入本地文件 。会用到java io 和 java net库。程序代码如下，留有注释。 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;import java.net.MalformedURLException;import java.net.URL;public class test &#123; public static void main(String[] args) &#123; try &#123; new test().downloadPage(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private String downloadPage() throws IOException &#123; // 目标网页链接 String url = \"https://hexo.io/zh-cn/\"; String inputLine = null; try &#123; URL pageUrl = new URL(url); BufferedReader br = new BufferedReader( new InputStreamReader(pageUrl.openStream(), \"utf-8\")); //程序文件目录建目录 download，用于存放下载的网页 File file = new File(\"D:\\\\Test\\\\maliang\\\\index.html\"); FileOutputStream out = new FileOutputStream(file); OutputStreamWriter write = new OutputStreamWriter(out, \"utf-8\"); // 将输入流读入到变量中，再写入到文件 while ((inputLine = br.readLine()) != null) &#123; write.write(inputLine); System.out.println(inputLine); &#125; br.close(); write.close(); System.err.println(\"下载完毕!\"); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; return url; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"/tags/Java8/"},{"name":"下载网页的完整代码","slug":"下载网页的完整代码","permalink":"/tags/下载网页的完整代码/"}]},{"title":"Linux服务器上搭建svn服务器","slug":"Linux服务器上搭建svn服务器","date":"2019-02-15T03:31:10.000Z","updated":"2019-12-06T16:28:58.478Z","comments":true,"path":"2019/02/15/Linux服务器上搭建svn服务器/","link":"","permalink":"/2019/02/15/Linux服务器上搭建svn服务器/","excerpt":"","text":"背景项目开发中需要版本控制，而我们经常使用的是在windows系统上搭建svn服务器，下面介绍在Linux系统（CentOS 7.3.1611）上搭建svn服务器。 使用yum安装svn使用yum安装svn，命令如下： 1yum -y install subversion 安装完成之后，验证svn安装是否成功 1svn help 若需查看svn安装位置，可以用以下命令 1rpm -ql subversion 新建仓库目录在/opt目录下面创建一个svn目录，用来作为svn存储目录，命令如下： 1mkdir /opt/svn 创建一个测试仓库执行如下命令，创建一个仓库 1svnadmin create /opt/svn/test/ 进入仓库目录下，查看仓库的文件，命令： 12cd /opt/svn/test/ #进入仓库目录ls #展示仓库文件 关于仓库文件的说明： hooks目录：放置hook脚步文件的目录locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端format目录：是一个文本文件，里边只放了一个整数，表示当前文件库配置的版本号conf目录：是这个仓库配置文件（仓库用户访问账户，权限） 配置SVN服务的配置文件svnserve.conf进入到conf文件夹下面，编辑svnserve.conf文件，命令如下： 123cd conflsvim svnserver.conf 在svnserver.conf文件中 anon-access前面的注释去掉，将对应的值设置为none auth-access前面的注释也去掉 password-db前面的注释也去掉 authz-db前面的注释也去掉 realm = /var/svn：指定认证域，即 /var/svn 目录 ，显示如下： 最重要的一点，去掉注释之后，配置项前面不能有空格。 配置访问的用户及密码编辑passwd文件，在文件的末尾加上自己需要添加的用户名和密码，显示如图： 1vim passwd 注意：用户和密码都是明文显示的 配置新用户的授权访问的文件编辑authz文件，在该文件中追加如下内容： 12345vim authz# 添加内容[/]flytzuhan=rw 防火墙3690端口开启123456# 显示防火墙应用列表firewall-cmd --list-all# 加入3690端口firewall-cmd --zone=public --add-port=3690/tcp --permanent# 重启防火墙systemctl restart firewalld 启动svn服务执行如下命令： 1svnserve -d -r /opt/svn/ 其中-d表示后台运行， -r指定根目录，这里需要注意：绝对不能将启动命令写成：svnserve -d -r /opt/svn/test/ 还有启动的时候可能会出现如下错误：svnserve: E000098: Can&#39;t bind server socket: Address already in use 这个是由于已经启动了SVN服务，所以需要先关闭进程，重新启动即可，命令如下： 12killall svnservesvnserve -d -r /opt/svn/ windows系统拉取代码可以在图形化界面中输入：svn://你的IP(公网)/test或者svn://你的IP(公网):3690/test链接svn 然后你就可以愉快的使用了~~~","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"svn","slug":"svn","permalink":"/tags/svn/"}]},{"title":"React上手技巧","slug":"React上手技巧","date":"2019-02-14T02:41:03.000Z","updated":"2019-02-14T03:11:54.199Z","comments":true,"path":"2019/02/14/React上手技巧/","link":"","permalink":"/2019/02/14/React上手技巧/","excerpt":"","text":"创建一个React应用程序参见：https://blog.csdn.net/tiangongkaiwu152368/article/details/80847494 安装node我们要用create-react-app来开发react，首先要通过包管理器安装create-react-app，而包管理器一般安装了nodejs后会自带的，所以我们的第一步是在我们的电脑上安装node。 请参考以下nodejs安装教程： Node.js安装配置 检测npm包是否可用安装好后，并且也配置进入了环境变量，然后我们来检测下你的npm包是否可用，打开cmd窗口，输入npm -v 进行检测，如下所示，若显示版本号则说明安装成功，环境变量也配置成功，可用开始安装creact-react-app进行react开发了。 使用 create-react-app 快速构建 React 开发环境create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。 create-react-app 自动创建的项目是基于 Webpack + ES6 。 执行以下命令创建项目： 1234npm install -g create-react-appcreate-react-app project_namecd project_name/npm start 参考：create-react-app 在浏览器中打开 http://localhost:3000/ ，结果如下图所示： 提示：安装好后，如果你想卸载，可以直接把install改为uninstal即可，也就是在前面个un就可以表示卸载了。有时候卸载后在安装可能会报写错，此时你直接定位的create-react-app安装目录，然后把这个目录删除一般就能解决了。 怎么运行别人写好的reactjs项目 首先安装nodejs最新稳定版，配置环境变量，使得node和npm命令能正常运行，自己去官方下载； 在项目下运行 npm install （功能：安装依赖） 然后看项目下的README.md，一般有指引教你如何运行。","categories":[{"name":"React","slug":"React","permalink":"/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"React","slug":"React","permalink":"/tags/React/"}]},{"title":"Linux下端口映射工具rinetd","slug":"Linux下端口映射工具rinetd","date":"2019-02-12T08:51:22.000Z","updated":"2019-02-12T09:30:58.619Z","comments":true,"path":"2019/02/12/Linux下端口映射工具rinetd/","link":"","permalink":"/2019/02/12/Linux下端口映射工具rinetd/","excerpt":"","text":"Linux下简单好用的工具rinetd，实现端口映射/转发/重定向 官网地址http://www.boutell.com/rinetd 软件下载1wget http://www.boutell.com/rinetd/http/rinetd.tar.gz 解压安装1234tar zxvf rinetd.tar.gzcd rinetdmakemake install 注意：执行make install时可能出现错误： 缺少目录/usr/man/man8 此时执行 mkdir /usr/man/man8后再执行make install即可 编辑配置123456vi /etc/rinetd.conf# 内容0.0.0.0 8080 172.19.94.3 80800.0.0.0 2222 192.168.0.103 33891.2.3.4 80 192.168.0.10 80 说明一下（0.0.0.0表示本机绑定所有可用地址）将所有发往本机8080端口的请求转发到172.19.94.3的8080端口将所有发往本机2222端口的请求转发到192.168.0.103的3389端口将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口 命令格式是bindaddress bindport connectaddress connectport绑定的地址 绑定的端口 连接的地址 连接的端口或[Source Address] [Source Port] [Destination Address] [Destination Port]源地址 源端口 目的地址 目的端口 启动程序1234rinetd -c /etc/rinetd.conf ##启动转发# 附加：pkill rinetd ##关闭进程 把命令rinetd -c /etc/rinetd.conf加到/etc/rc.local里面就可以开机自动运行 查看状态123netstat -antp | grep 8080 | grep -v grepnetstat -antp | grep rinetd | grep -v grep 需要注意 rinetd.conf中绑定的本机端口必须没有被其它程序占用 运行rinetd的系统防火墙应该打开绑定的本机端口（或者直接关闭防火墙？） 例如： 12-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 1111 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 2222 -j ACCEPT","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"映射","slug":"映射","permalink":"/tags/映射/"},{"name":"rinetd","slug":"rinetd","permalink":"/tags/rinetd/"}]},{"title":"工作以及自我学习计划","slug":"工作以及自我学习计划","date":"2019-01-31T08:38:41.000Z","updated":"2019-01-31T08:41:00.863Z","comments":true,"path":"2019/01/31/工作以及自我学习计划/","link":"","permalink":"/2019/01/31/工作以及自我学习计划/","excerpt":"","text":"人工智能-2019年工作计划","categories":[{"name":"乱语","slug":"乱语","permalink":"/categories/乱语/"}],"tags":[{"name":"学习计划","slug":"学习计划","permalink":"/tags/学习计划/"},{"name":"工作计划","slug":"工作计划","permalink":"/tags/工作计划/"}]},{"title":"让应用程序支持emoji字符","slug":"让应用程序支持emoji字符","date":"2019-01-31T03:00:44.000Z","updated":"2019-08-22T01:58:40.633Z","comments":true,"path":"2019/01/31/让应用程序支持emoji字符/","link":"","permalink":"/2019/01/31/让应用程序支持emoji字符/","excerpt":"","text":"实现什么是emoji？就是这些表情和符号： 😀😄💦😍😂😱😭😴👌 自iPhone从iOS 5在输入法中开始支持emoji以来，这些表情符号迅速风靡世界。但是很多Web网站竟然还不！支！持！！！ 那怎么才能支持emoji呢？其实代码一行都不用改，因为emoji符号实际上是文本，并不是图片，它们仅仅显示为图片而已。而且，emoji符号已经被标准化并编码到最新的Unicode标准中了，所以，要支持emoji，只需要底层软件系统支持就可以了。 服务器端要正确存储emoji符号，只需要确保Web程序和底层数据库能支持最新的Unicode标准就可以了。 如果使用MySQL作为数据库，需要升级到5.5.3或更新的版本，然后，把默认编码从原来的utf8改为utf8mb4，在my.cnf或者my.ini配置文件中修改如下： 123456[client]default-character-set = utf8mb4[mysqld]character-set-server = utf8mb4collation-server = utf8mb4_general_ci # 解释见附录 重启MySQL，然后使用以下命令查看编码，应该全部为utf8mb4（character_set_filesystem和character_set_system除外）： 1234567891011121314mysql&gt; show variables like '%char%';+--------------------------+--------------------------+| Variable_name | Value |+--------------------------+--------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.... |+--------------------------+--------------------------+8 rows in set (0.00 sec) 使用命令查看collation设置，应该全部是utf8mb4_general_ci： 123456789mysql&gt; show variables like '%coll%';+----------------------+--------------------+| Variable_name | Value |+----------------------+--------------------+| collation_connection | utf8mb4_general_ci || collation_database | utf8mb4_general_ci || collation_server | utf8mb4_general_ci |+----------------------+--------------------+3 rows in set (0.01 sec) 如果character_set_database还是为utf8，需要重启服务器。 现在，MySQL就可以正确存储emoji字符了。 Web软件 要支持emoji，需要Web软件也支持。目前，已知支持emoji的包括： Java 8 Node 最后，如果你的Web应用程序没有使用标准的UTF-8编码，而是使用了GBK等编码，想要支持emoji就只能呵呵了 附录utf8与utf8mb4 MySQL 5.5.3之后增加了utfmb4字符编码 支持BMP（Basic Multilingual Plane，基本多文种平面）和补充字符 最多使用四个字节存储字符 utf8mb4是utf8的超集并完全兼容utf8，能够用四个字节存储更多的字符。 标准的UTF-8字符集编码是可以使用1-4个字节去编码21位字符，这几乎包含了世界上所有能看见的语言。MySQL里面实现的utf8最长使用3个字符，包含了大多数字符但并不是所有。例如emoji和一些不常用的汉字，如“墅”，这些需要四个字节才能编码的就不支持。 字符集、连接字符集、排序字符集utf8mb4对应的排序字符集有utf8mb4_unicode_ci、utf8mb4_general_ci. utf8mb4_unicode_ci和utf8mb4_general_ci的对比： 准确性： utf8mb4_unicode_ci是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序 utf8mb4_general_ci没有实现Unicode排序规则，在遇到某些特殊语言或者字符集，排序结果可能不一致。 但是，在绝大多数情况下，这些特殊字符的顺序并不需要那么精确。 性能 utf8mb4_general_ci在比较和排序的时候更快 utf8mb4_unicode_ci在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。 但是在绝大多数情况下发，不会发生此类复杂比较。相比选择哪一种collation，使用者更应该关心字符集与排序规则在db里需要统一。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"/categories/MySQL/"}],"tags":[{"name":"emoji","slug":"emoji","permalink":"/tags/emoji/"},{"name":"utf8mb4","slug":"utf8mb4","permalink":"/tags/utf8mb4/"},{"name":"Web","slug":"Web","permalink":"/tags/Web/"}]},{"title":"JVM -verbose参数详解","slug":"JVM-verbose参数详解","date":"2019-01-28T11:50:55.000Z","updated":"2019-01-28T12:05:53.116Z","comments":true,"path":"2019/01/28/JVM-verbose参数详解/","link":"","permalink":"/2019/01/28/JVM-verbose参数详解/","excerpt":"","text":"java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息java -verbose:class在程序运行的时候有多少类被加载！你可以用verbose:class来监视，在命令行输入java -verbose:class XXX (XXX为程序名)你会在控制台看到加载的类的情况。 配置参数： verbose和verbose:class含义相同，输出虚拟机装入的类的信息，显示的信息格式如下： 12345678910[Opened D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.Object from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.io.Serializable from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar]... java –verbose:gc在虚拟机发生内存回收时在输出设备显示信息，格式如下： [Full GC 256K-&gt;160K(124096K), 0.0042708 secs] 该参数用来监视虚拟机内存回收的情况。 12345678910public class JvmVerbose &#123; /** * JVM -verbose[:class|gc|jni] 参数测试 * @param args */ public static void main(String[] args) &#123; JvmVerbose jvmVerbose = new JvmVerbose(); System.gc(); &#125;&#125; 在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为可达，程序编译后，执行命令： java -verbose:gc JvmVerbose 后结果为： 123[GC 647K-&gt;256K(124096K), 0.0274253 secs][Full GC 256K-&gt;160K(124096K), 0.0042708 secs] 箭头前后的数据256K和160K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有256K-160K=96K的对象容量被回收，括号内的数据124096K为堆内存的总容量，收集所需要的时间是0.0042708秒（这个时间在每次执行的时候会有所不同） java –verbose:jni-verbose:jni输出native方法调用的相关情况，一般用于诊断jni调用错误信息。在虚拟机调用native方法时输出设备显示信息，格式如下： [Dynamic-linking native methodjava.lang.Object.registerNatives ... JNI] 该参数用来监视虚拟机调用本地方法的情况，在发生jni错误时可为诊断提供便利。 小试身手： 123456public class Test &#123; public static void main(String args[])&#123; Test test = new Test(); System.gc(); &#125;&#125; 配置参数： 执行Test.class加载了以下这么多类 1234567891011121314151617181920212223242526[Opened C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Object from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.io.Serializable from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.String from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.reflect.GenericDeclaration from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.reflect.Type from C:\\Java\\jdk7\\jre\\lib\\rt.jar]...[Full GC 812K-&gt;442K(15872K), 0.0031244 secs] [Loaded sun.misc.Cleaner from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Shutdown from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Shutdown$Lock from C:\\Java\\jdk7\\jre\\lib\\rt.jar]...","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"/tags/eclipse/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"Maven生成javadoc(api文档)","slug":"Maven生成javadoc-api文档","date":"2019-01-24T02:16:22.000Z","updated":"2019-01-24T02:24:05.640Z","comments":true,"path":"2019/01/24/Maven生成javadoc-api文档/","link":"","permalink":"/2019/01/24/Maven生成javadoc-api文档/","excerpt":"","text":"pom配置123456789101112131415&lt;!-- properties与dependencys同级 --&gt;&lt;properties&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;configuration&gt; &lt;reportOutputDirectory&gt;../javadocs&lt;/reportOutputDirectory&gt; &lt;destDir&gt;easy-delivery&lt;/destDir&gt; &lt;/configuration&gt;&lt;/plugin&gt; 生成doc命令首先需要打开cmd，然后cd到项目目录下，然后执行下面命令即可 例： 123D:cd D:\\maliangnansheng\\IDEA_HKAI\\hkai-ocrmvn javadoc:javadoc 查看文件比如我的项目在hkai-ocr这个文件夹下面，doc也会生成在与hkai-ocr同级目录（也可以修改上面的配置） 打开生成的doc里index.html 就可以看到api页面","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"api","slug":"api","permalink":"/tags/api/"},{"name":"Maven","slug":"Maven","permalink":"/tags/Maven/"}]},{"title":"CentOS部署kodexplorer可道云搭建私有网盘","slug":"CentOS部署kodexplorer可道云搭建私有网盘","date":"2019-01-16T06:38:15.000Z","updated":"2019-01-16T07:50:17.841Z","comments":true,"path":"2019/01/16/CentOS部署kodexplorer可道云搭建私有网盘/","link":"","permalink":"/2019/01/16/CentOS部署kodexplorer可道云搭建私有网盘/","excerpt":"","text":"工具/原料 xampp 可道云kodexplorer PHP环境配置 可以在串口使用getconf LONG_BIT 命令来查看并确定linux操作系统版本 输出：32表面系统是32位。输出：64表面系统是64位。 下载与自己操作系统相适应版本的xampp [32bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/5.6.14/xampp-linux-5.6.14-4-installer.run&gt;（7.3.0没有32位版本的，自己找找哪个版本有）[64bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/7.3.0/xampp-linux-x64-7.3.0-0-installer.run 123mkdir /home/xamppcd /home/xampp/wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/7.3.0/xampp-linux-x64-7.3.0-0-installer.run 安装xampp，为私有云安装构建Apache和PHP环境 12chmod u+x xampp-linux-x64-7.3.0-0-installer.run./xampp-linux-x64-7.3.0-0-installer.run 删除包： 1rm -rf /home/xampp/ 启动xampp，执行/opt/lampp/lampp start启动服务 默认安装在/opt/lampp/下 1/opt/lampp/lampp start 下载和安装可道云kodexplorer 下载最新版本的可道云KodExplorer程序 下载地址：http://kodcloud.com/download.html 下载： 1234mkdir /home/kodexplorercd /home/kodexplorer/# 当时最新版wget http://static.kalcaddle.com/update/download/kodexplorer4.37.zip 将可道云kodexplorer.zip解压 1unzip kodexplorer4.37.zip 将解压后的内容拷贝至/opt/lampp/htdocs/目录下 123cp -r /home/kodexplorer/ /opt/lampp/htdocs/chmod 777 /opt/lampp/htdocs/kodexplorerchmod -R 777 /opt/lampp/htdocs/kodexplorer/data/ 删除不用文件： 1rm -rf /home/kodexplorer/ 浏览器访问kodexplorer的index.php即可访问KodExplorer界面 即：http://IP地址/kodexplorer/index.php 例：http://172.19.15.52/kodexplorer/index.php","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"kodexplorer","slug":"kodexplorer","permalink":"/tags/kodexplorer/"},{"name":"部署","slug":"部署","permalink":"/tags/部署/"}]},{"title":"使用Java打开桌面文件","slug":"使用Java打开桌面文件","date":"2019-01-15T09:34:36.000Z","updated":"2019-01-15T09:59:44.143Z","comments":true,"path":"2019/01/15/使用Java打开桌面文件/","link":"","permalink":"/2019/01/15/使用Java打开桌面文件/","excerpt":"","text":"打开某一文件（默认软件打开）123456789101112public static void main(String[] args) &#123; try &#123; Desktop desktop = Desktop.getDesktop(); if (desktop.isSupported(Desktop.Action.OPEN)) &#123; desktop.open(new File(\"Your.pdf\")); //全路径 &#125; else &#123; System.out.println(\"Open is not supported\"); &#125; &#125; catch (IOException exp) &#123; exp.printStackTrace(); &#125;&#125; 指定某一软件打开对应的文件1234Runtime.getRuntime() .exec(\"WINWORD.EXE（使用啥软件打开）所在全路径 D:\\\\test.docx（文件全路径）\");//例：\"C:\\\\Program Files\\\\Microsoft Office\\\\root\\\\Office16\\\\WINWORD.EXE D:\\\\3.pdf\"","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"Desktop","slug":"Desktop","permalink":"/tags/Desktop/"}]},{"title":"pip的使用技巧","slug":"pip的使用技巧","date":"2019-01-12T06:57:20.000Z","updated":"2019-01-12T08:08:22.305Z","comments":true,"path":"2019/01/12/pip的使用技巧/","link":"","permalink":"/2019/01/12/pip的使用技巧/","excerpt":"","text":"如何使用pip安装特定版本的python第三方包python的包管理器pip特别好用，我们可以使用它来方便的安装第三方包，但是怎样使用pip来安装特定版本的第三方包呢？ 安装好python后，包管理器pip就已经安装好了，在终端中输入pip就可以查阅到pip一些常用用法，如： 12pip install package#这里package即为第三方包的名称，如tensorflow，使用这种安装方式会安装最新版本的包 12pip uninstall package#卸载包 12pip list#列举出当前环境安装的所有包 12pip show package#显示所安装包的信息 12pip install package==version#package：包名；version：版本号。如pip install tensorflow-gpu==1.12.0即是安装1.12.0版本的gpu版本的tensorflow 多版本Python共存时pip给指定版本的python安装package的方法在linux安装了多版本python时（例如python2.7和3.4），pip安装的包不一定是用户想要的位置，此时可以用 -t 选项来指定位置 查看pip指向123pip -V# 输出：pip 9.0.1 from /usr/lib/python2.7/site-packages/pip-9.0.1-py2.7.egg (python 2.7)# 发现指向python 2.7 所以我们的问题变成了怎么通过pip去指定安装到Python3.4下 解决方案 更改pip3指向（推荐） 这种方法可以一劳永逸地让之后的pip3安装都顺利一点 1234567891011121314151617181920212223242526272829303132331.查看pip在哪which pip# 输出：/usr/bin/pip2.查看python在哪which python# 输出：/usr/bin/python3.查看python3在哪which python3# 输出：/usr/local/bin/python34.编辑pip所在文件vim /usr/bin/pip# 我们可以看到如下：-----------------------------pip--------------------------------#!/usr/bin/python# EASY-INSTALL-ENTRY-SCRIPT: 'pip==9.0.1','console_scripts','pip'__requires__ = 'pip==9.0.1'import reimport sysfrom pkg_resources import load_entry_pointif __name__ == '__main__': sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0]) sys.exit( load_entry_point('pip==9.0.1', 'console_scripts', 'pip')() )-----------------------------pip-end----------------------------将第一行 #!/usr/bin/python 修改为#!/usr/local/bin/python3然后pip就指向python2了 强制安装到Python3.4环境下 1python3 -m pip install tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl 这样就可以指定安装到python3下了，不过用这种方法的话每次要安装都得这么做，不过因为我是在别人服务器上做，不好随便更改，因此采用这种方式。 用 -t 选项来指定安装位置 例如目标位置是/usr/local/lib/python3.4/site-packages/ ，要安装tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl这个包，则： 1pip install -t /usr/local/lib/python3.4/site-packages/ tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl 这一种方式安装一般会报Command &quot;python setup.py egg_info&quot; failed with error code 1这个错 。解决方案（经验）： 12python -m pip install --upgrade --force pip pip install setuptools==33.1.1","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"pip","slug":"pip","permalink":"/tags/pip/"}]},{"title":"Hibernate中更新非空域","slug":"Hibernate中更新非空域","date":"2019-01-10T01:27:16.000Z","updated":"2019-01-10T08:14:58.225Z","comments":true,"path":"2019/01/10/Hibernate中更新非空域/","link":"","permalink":"/2019/01/10/Hibernate中更新非空域/","excerpt":"","text":"Hibernate中更新非空域；传入一个对象，这个对象中有的域可能是null，但是我并不想覆盖原来的数据库中的有值的域。 我的实现方法： 12345678910111213141516171819202122232425262728public class BeanUtil &#123; /** * 复制src对象的非空属性值到target中 * @param src * @param target */ public static void copyNonNullProperties(Object src, Object target) &#123; BeanUtils.copyProperties(src, target, getNullPropertyNames(src)); &#125; /** * 获取对象中属性为空的属性 * @param source * @return */ public static String[] getNullPropertyNames (Object source) &#123; final BeanWrapper src = new BeanWrapperImpl(source); PropertyDescriptor[] pds = src.getPropertyDescriptors(); Set&lt;String&gt; emptyNames = new HashSet&lt;&gt;(); for(PropertyDescriptor pd : pds) &#123; Object srcValue = src.getPropertyValue(pd.getName()); if (srcValue == null) emptyNames.add(pd.getName()); &#125; String[] result = new String[emptyNames.size()]; return emptyNames.toArray(result); &#125;&#125; 如何调用： 123456实体类1：src （前端传来的数据）实体类1：existing （通过前端传来数据的id获取得到数据库表里的数据）//用src中不为空的属性替换existing中对应的属性copyNonNullProperties(src,existing);//调用hibernate的关系更新方法iModelConfigDAO.update(existing); iModelConfigDAO的实现类说明： 123456789101112public class ModelConfigDAOImpl implements IModelConfigDAO&#123; @Resource private SessionFactory sessionFactory; private Session getSession() &#123; return sessionFactory.getCurrentSession(); &#125; public void update(ModelConfig modelConfig) &#123; this.getSession().update(modelConfig); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"/tags/Hibernate/"}]},{"title":"系统开机启动脚本","slug":"系统开机启动脚本","date":"2019-01-07T08:18:31.000Z","updated":"2019-10-30T07:08:28.923Z","comments":true,"path":"2019/01/07/系统开机启动脚本/","link":"","permalink":"/2019/01/07/系统开机启动脚本/","excerpt":"","text":"ubuntu 18.04.1 开机启动脚本ubuntu18.04不再使用initd管理系统，改用systemd。个人觉得systemd很难用，改变太大，跟之前的完全不同 为了像以前一样，在/etc/rc.local中设置开机启动程序，需要以下几步： systemd默认读取/etc/systemd/system下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。一般系统安装完/lib/systemd/system/下会有rc-local.service文件，即我们需要的配置文件。 链接过来： 1ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service 打开脚本内容： 1cat /etc/systemd/system/rc-local.service 1234567891011121314151617181920212223# SPDX-License-Identifier: LGPL-2.1+## This file is part of systemd.## systemd is free software; you can redistribute it and/or modify it# under the terms of the GNU Lesser General Public License as published by# the Free Software Foundation; either version 2.1 of the License, or# (at your option) any later version.# This unit gets pulled automatically into multi-user.target by# systemd-rc-local-generator if /etc/rc.local is executable.[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no 一般正常的启动文件主要分成三部分： [Unit] 段: 启动顺序与依赖关系 [Service] 段: 启动行为,如何启动，启动类型[Install] 段: 定义如何安装这个配置文件，即怎样做到开机启动 可以看出，/etc/rc.local 的启动顺序是在网络后面，但是显然它少了 Install 段，也就没有定义如何做到开机启动，所以显然这样配置是无效的。 因此我们就需要在后面帮他加上 [Install] 段: 123[Install] WantedBy=multi-user.target Alias=rc-local.service 这里需要注意一下，ubuntu-18.04 默认是没有 /etc/rc.local 这个文件的，需要自己创建 创建/etc/rc.local文件（有的话不用再创建了） 1touch /etc/rc.local 赋可执行权限 1chmod 755 /etc/rc.local 编辑rc.local，添加需要开机启动的任务 12345678910111213141516171819#!/bin/sh -e# # rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will \"exit 0\" on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.########################手动添加的命令########################echo \"this is a test\" &gt; /usr/local/text.logsudo vncserver######################手动添加的命令-end######################exit 0 其中sudo vncserver就是需要开机启动的任务（注意：sudo写上有益无害，避免不必要的麻烦） echo &quot;this is a test&quot; &gt; /usr/local/text.log是测试开机脚本是否生效用的 执行reboot重启系统（查看 /usr/local/text.log 文件是否存在就知道开机脚本是否生效了） ubuntu - 一般情况开机启动脚本借鉴于此博客 先写一个脚本，里面写上执行要执行的命令，再使用update-rc.d 脚本名 defaults命令将改脚本添加到系统启动任务 12cd /etc/init.dvim tale 12345678910111213#!/bin/bash#program#先将jdk的环境准备好export JAVA_HOME=/usr/local/jdk1.8export JRE=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE/lib:.export PATH=$PATH:$JAVA_HOME/bin/:$JRE/bin#执行命令nohup java -jar /home/veir/tale/tale-least.jar &gt;/home/veir/tale/logs/tale.log &amp;exit 0 保存后，给脚本添加可执行权限 1chmod +x tale 添加开机启动服务 12update-rc.d tale defaults#defaults后面可以加一个数字，例如99，它表明一个优先级，越高表示执行的越晚 有一个需要注意，很多命令的执行需要一个系统的环境，例如上面的java -jar xxx就需要jdk的环境支持，然后很有可能，系统在执行此脚本时，jdk的环境还没有加载进来，所以就需要手动在该脚本中声明需要的环境 修改/etc/rc.local脚本/etc/rc.local是Linux系统启动后自动执行的一个脚本，默认情况下这个脚本里面没有任务。修改这个脚本可以启动你自己的应用。 修改方式很简单，在最后一行exit 0之前加上开启服务或应用的命令就好了 1vim /etc/rc.local 得到视图如下： 12345678910111213141516171819#!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will \"exit 0\" on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.########################手动添加的命令######################### 启动xampp-可道云可访问sudo /opt/lampp/lampp start######################手动添加的命令-end######################exit 0 centos/redhat - 一般情况开机启动脚本先写一个脚本，里面写上执行要执行的命令，再使用update-rc.d 脚本名 defaults命令将改脚本添加到系统启动任务 12cd /etc/init.dvim lampp.sh 1234#!/bin/bash# 启动xampp-可道云可访问sudo /opt/lampp/lampp start su -c ‘/etc/init.d/lampp.sh’ 保存后，给脚本添加可执行权限 1chmod +x lampp.sh 打开/etc/rc.d/rc.local或/etc/rc.local文件，在末尾增加/etc/init.d/lampp.sh 12345678910111213141516#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.########################手动添加的命令######################### 启动xampp-可道云可访问/etc/init.d/lampp.sh######################手动添加的命令-end###################### 在centos7(不仅仅)中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限 1chmod +x /etc/rc.d/rc.local 修改/etc/rc.local脚本/etc/rc.local是Linux系统启动后自动执行的一个脚本，默认情况下这个脚本里面没有任务。修改这个脚本可以启动你自己的应用。 修改方式很简单，在最后加上开启服务或应用的命令就好了 1vim /etc/rc.local 得到视图如下： 12345678910111213141516#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.########################手动添加的命令######################### 启动xampp-可道云可访问sudo /opt/lampp/lampp start######################手动添加的命令-end###################### 可在以上视图中发现有一句# Please note that you must run &#39;chmod +x /etc/rc.d/rc.local&#39; to ensure中文翻译请注意，您必须运行“chmod +x /etc/rc.d/rc.才能确保成功 - 意思很明显了！ 1chmod +x /etc/rc.d/rc.local 注：比如像启动Tomcat这种，前提是需要有jdk环境，所以配置自启动这类型的命令时必须要将其前置条件放在启动命令之前，例如： 12345678910111213141516# 编辑vim /etc/rc.local，配置如下：#########################准备jdk环境##########################export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_221 ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH#######################准备jdk环境-end################################################手动添加的命令######################### 启动bbs-ssm项目/home/bbs-ssm/tomcat9/bin/startup.sh# 启动crud-bbs项目/home/crud-bbs/tomcat9/bin/startup.sh######################手动添加的命令-end###################### Win10怎么添加开机启动项？方案一：开机启动文件夹亲测可用，推荐方案三 我们打开文件夹：C:\\Users（用户）\\Administrator（当前用户名）\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs（「开始」菜单）\\Programs（程序）\\Startup（启动 ）即可找到启动文件夹。如图： PS：也可以粘贴以下路径回车打开: %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 新建frpc.bat脚本，内容如下： 123e:cd E:\\Program Files\\frp_0.29.0_windows_amd64frpc -c frpc.ini 新建frpc.bat快捷方式 然后我们把frpc.bat的快捷方式，Win10开机后就可以自动运行了。如图： 方案二：任务计划程序未亲测，推荐方案三 在我的电脑 -&gt; 右键 -&gt; 管理 创建基本任务 下一步 下一步 下一步，选择开机启动脚本 下一步 完成。 然后就完成啦，可以试试，开机的时候，会不会自启动。 方案三：用nssm将frpc注册为Windows系统服务亲测可用，推荐优先使用该方案 下载nssm 官网：http://nssm.cc/download 解压至本地目录 根据操作系统选择32位或64位nssm，cd到nssm所在目录 我的系统是64位的： 服务注册（以注册frpc为例） 命令行输入： 1nssm install frpc # 回车 问题： 此时可能会抛出Administrator access is needed to install a service.意思是：需要管理员权限才能安装服务 当我检查用户帐户时，它表明我是“管理员”组中的用户名。难搞哦！ 解决 右键单击cmd快捷方式，以管理员身份运行 亲测可用 打开命令窗口后重新执行nssm install frpc命令 执行cmd / admin 未亲测 打开命令窗口后重新执行nssm install frpc命令 接下来会弹出一个框，在path处选择启动frpc的frpc.bat，点击Install service即可 服务启动 123456789nssm start frpc# 其他命令：nssm start &lt;servicename&gt;nssm stop &lt;servicename&gt;nssm restart &lt;servicename&gt;nssm status &lt;servicename&gt;nssm rotate &lt;servicename&gt;nssm remove &lt;servicename&gt;... 启动后，你将在本地计算机服务列表看到frpc服务。Win+R，services.msc","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"/tags/CentOS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"RedHat","slug":"RedHat","permalink":"/tags/RedHat/"},{"name":"开机启动","slug":"开机启动","permalink":"/tags/开机启动/"}]},{"title":"文件打包-解压-下载","slug":"文件打包-解压-下载","date":"2018-12-28T03:07:17.000Z","updated":"2019-03-13T07:36:49.686Z","comments":true,"path":"2018/12/28/文件打包-解压-下载/","link":"","permalink":"/2018/12/28/文件打包-解压-下载/","excerpt":"","text":"文件打包123456789101112131415161718192021222324252627282930313233/** * 文件打包 * 将传递过来的文件列表写入zip文件 * @param fileList 要打包的文件 * @param zipFileName 打包后的文件名 * @throws IOException */public static void downZipManyFile(List&lt;File&gt; fileList, String zipFileName) throws IOException &#123; BufferedInputStream br = null;//输入流 ZipOutputStream out = null; // 压缩文件输出流 ZipEntry zip = null; //用于表示 ZIP 文件条目。 int size =-1; byte[] buffer = new byte[2048];// 定义缓冲区 if(fileList.size()&gt;0)&#123; out = new ZipOutputStream(new FileOutputStream(zipFileName)); for (int i = 0; i &lt; fileList.size(); i++) &#123; File f =fileList.get(i); zip = new ZipEntry(f.getName()); out.putNextEntry(zip); br = new BufferedInputStream(new FileInputStream(f)); while((size=br.read(buffer))!=-1)&#123; out.write(buffer,0,size); out.flush(); &#125; &#125; zip.clone(); br.close(); out.close(); &#125;&#125; 多种压缩文件解压包含实现对.zip、.rar、.7z、.tar、.tar.gz的解压 Maven 1234567891011121314151617181920&lt;!-- .7z --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding-all-platforms&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .7z end --&gt; &lt;!-- .tar/.tar.gz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.10.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .tar/.tar.gz end --&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337/*功能：多种格式压缩文件解压(.zip、.rar、.7z、.tar、.tar.gz)*///使用gbk编码避免zip解压中文文件名乱码private static final String CHINESE_CHARSET = \"gbk\";//文件读取缓冲区大小private static final int CACHE_SIZE = 1024;//系统类型private static final String WINDOWS=\"windows\";private static final String LINUX=\"linux\";/** * 多种格式压缩文件解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void deCompress(String srcFileName, String destDir)&#123; //存储路径不存在则创建 File dFile=new File(destDir); if (!dFile.exists()) &#123; dFile.mkdirs(); &#125; if (srcFileName.toLowerCase().endsWith(\".zip\")) &#123; unZip(srcFileName, destDir); &#125; else if (srcFileName.toLowerCase().endsWith(\".rar\")) &#123; unRar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".7z\")) &#123; un7Z(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar\")) &#123; unTar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar.gz\")) &#123; unTarGz(srcFileName, destDir); &#125;&#125;/** * .zip格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unZip(String srcFileName, String destDir) &#123; try &#123; //解决中文乱码 ZipFile zip = new ZipFile(srcFileName, Charset.forName(CHINESE_CHARSET)); //循环遍历 for (Enumeration&lt;? extends ZipEntry&gt; entries = zip.entries(); entries.hasMoreElements();) &#123; ZipEntry entry = entries.nextElement(); String zipEntryName = entry.getName(); InputStream in = zip.getInputStream(entry); String outPath = (destDir +\"/\"+ zipEntryName).replaceAll(\"\\\\*\", \"/\"); // 判断路径是否存在,不存在则创建文件路径 File file = new File(outPath.substring(0, outPath.lastIndexOf('/'))); if (!file.exists()) &#123; file.mkdirs(); &#125; // 判断文件全路径是否为文件夹,如果是上面已经上传,不需要解压 if (new File(outPath).isDirectory()) &#123; continue; &#125; FileOutputStream out = new FileOutputStream(outPath); byte[] buf = new byte[CACHE_SIZE]; int len; while ((len = in.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; in.close(); out.close(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;/** * .rar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unRar(String srcFileName, String destDir)&#123; String cmd = null; String unRarCmd = null; try &#123; if (systemType().equals(WINDOWS)) &#123; //解压模板命令 unRarCmd = \"F:\\\\Program Files (x86)\\\\WinRAR\\\\WinRAR.exe x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; else if (systemType().equals(LINUX)) &#123; //解压模板命令 unRarCmd = \"unrar x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; //构造运行对象 Runtime rt = Runtime.getRuntime(); //在单独的进程中执行指定的字符串命令。 rt.exec(cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * .7z格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void un7Z(String srcFileName, String destDir)&#123; RandomAccessFile randomAccessFile = null; IInArchive inArchive = null; try &#123; randomAccessFile = new RandomAccessFile(srcFileName, \"r\"); inArchive = SevenZip. openInArchive(null,new RandomAccessFileInStream(randomAccessFile)); ISimpleInArchive simpleInArchive = inArchive.getSimpleInterface(); //遍历 for (ISimpleInArchiveItem item : simpleInArchive.getArchiveItems()) &#123; int[] hash = new int[] &#123; 0 &#125;; if (!item.isFolder()) &#123; ExtractOperationResult result; long[] sizeArray = new long[1]; //tarFile是遍历的每一个文件 File tarFile=new File(destDir+File.separator+item.getPath()); //tarFile父目录不存在，则创建 if (!tarFile.getParentFile().exists()) &#123; tarFile.getParentFile().mkdirs(); &#125; //创建tarFile文件 tarFile.createNewFile(); result = item.extractSlow(new ISequentialOutStream() &#123; public int write(byte[] data) throws SevenZipException &#123; FileOutputStream fos=null; try &#123; fos = new FileOutputStream(tarFile.getAbsolutePath()); //将数据写入fos fos.write(data); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; hash[0] ^= Arrays.hashCode(data); sizeArray[0] += data.length; return data.length; &#125; &#125;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; finally &#123; if (inArchive != null) &#123; try &#123; inArchive.close(); &#125; catch (SevenZipException e) &#123; e.printStackTrace(); &#125; &#125; if (randomAccessFile != null) &#123; try &#123; randomAccessFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * .tar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTar(String srcFileName, String destDir)&#123; FileInputStream fis = null; OutputStream fos = null; TarInputStream tarInputStream = null; try &#123; fis = new FileInputStream(new File(srcFileName)); tarInputStream = new TarInputStream(fis, CACHE_SIZE); TarEntry entry = null; while(true)&#123; entry = tarInputStream.getNextEntry(); if( entry == null)&#123; break; &#125; if(entry.isDirectory())&#123; System.out.println(entry.getName()); createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; fos = new FileOutputStream(new File(destDir + File.separator + entry.getName())); int count; byte data[] = new byte[CACHE_SIZE]; while ((count = tarInputStream.read(data)) != -1) &#123; fos.write(data, 0, count); &#125; fos.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fis != null)&#123; fis.close(); &#125; if(fos != null)&#123; fos.close(); &#125; if(tarInputStream != null)&#123; tarInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * .tar.gz解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTarGz(String srcFileName, String destDir)&#123; FileInputStream fileInputStream = null; BufferedInputStream bufferedInputStream = null; GZIPInputStream gzipIn = null; TarInputStream tarIn = null; OutputStream out = null; try &#123; fileInputStream = new FileInputStream(new File(srcFileName)); bufferedInputStream = new BufferedInputStream(fileInputStream); gzipIn = new GZIPInputStream(bufferedInputStream); tarIn = new TarInputStream(gzipIn, CACHE_SIZE); TarEntry entry = null; while((entry = tarIn.getNextEntry()) != null)&#123; if(entry.isDirectory())&#123; // 是目录 createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; // 是文件 File tempFIle = new File(destDir + File.separator + entry.getName()); createDirectory(tempFIle.getParent() + File.separator, null); out = new FileOutputStream(tempFIle); int len =0; byte[] b = new byte[CACHE_SIZE]; while ((len = tarIn.read(b)) != -1)&#123; out.write(b, 0, len); &#125; out.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(out != null)&#123; out.close(); &#125; if(tarIn != null)&#123; tarIn.close(); &#125; if(gzipIn != null)&#123; gzipIn.close(); &#125; if(bufferedInputStream != null)&#123; bufferedInputStream.close(); &#125; if(fileInputStream != null)&#123; fileInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * 构建目录 * @param outputDir 输出目录 * @param subDir 子目录 */private static void createDirectory(String outputDir, String subDir)&#123; File file = new File(outputDir); if(!(subDir == null || subDir.trim().equals(\"\"))) &#123;//子目录不为空 file = new File(outputDir + File.separator + subDir); &#125; if(!file.exists())&#123; if(!file.getParentFile().exists())&#123; file.getParentFile().mkdirs(); &#125; file.mkdirs(); &#125;&#125;/** * 判断程序运行在什么系统上 * @return 系统类型 */public static String systemType() &#123; Properties properties = System.getProperties(); String os = properties.getProperty(\"os.name\"); if (os != null &amp;&amp; os.toLowerCase().contains(WINDOWS))&#123; return WINDOWS; &#125;else if (os != null &amp;&amp; os.toLowerCase().contains(LINUX))&#123; return LINUX; &#125; return null;&#125;public static void main(String[] args) &#123; //deCompress(\"E:/Test/Test01.zip\",\"E:/Test/testZip\"); //deCompress(\"E:/Test/Test02.rar\",\"E:/Test/testRar\"); //deCompress(\"E:/Test/Test03.7z\",\"E:/Test/test7z\"); //deCompress(\"E:/Test/Test04.tar\",\"E:/Test/testTar\"); //deCompress(\"E:/Test/apache-tomcat-9.0.13-src.tar.gz\",\"E:/Test/testTarGz\");&#125; 从服务器下载文件下载已经打包好的文件123456789101112131415161718192021222324252627282930313233343536/** * 文件下载 * @param zipFileName zip文件全路径（含文件名） * @param response * @param isDelete 是否将生成的服务器端文件删除 * @return */public ReturnT&lt;?&gt; downloadFile(String zipFileName, HttpServletResponse response, boolean isDelete) &#123; try &#123; File file=new File(zipFileName); // 以流的形式下载文件。 BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file.getPath())); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); response.setContentType(\"application/octet-stream\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + new String(file.getName().getBytes(\"UTF-8\"),\"ISO-8859-1\")); toClient.write(buffer); toClient.flush(); toClient.close(); if(isDelete) &#123; //将生成的服务器端文件删除 file.delete(); &#125; return new ReturnT(HttpStatus.OK, \"下载成功\", null); &#125; catch (Exception e) &#123; logger.error(\"下载失败\",e); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125;&#125; 变打包边下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 下载-边打包边下载 * @param downloadName 压缩包的名字 * @param fileList 所有需要下载的文件列表 * @param request * @param response * @return */@Overridepublic ReturnT&lt;?&gt; downloadFile(String downloadName, List&lt;File&gt; fileList, HttpServletRequest request, HttpServletResponse response) &#123; //响应头的设置 response.reset(); response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"multipart/form-data\"); //设置压缩包的名字 //解决不同浏览器压缩包名字含有中文时乱码的问题 String agent = request.getHeader(\"USER-AGENT\"); try &#123; if (agent.contains(\"MSIE\")||agent.contains(\"Trident\")) &#123; downloadName = java.net.URLEncoder.encode(downloadName, \"UTF-8\"); &#125; else &#123; downloadName = new String(downloadName.getBytes(\"UTF-8\"),\"ISO-8859-1\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; response.setHeader(\"Content-Disposition\", \"attachment;fileName=\\\"\" + downloadName + \"\\\"\"); //设置压缩流：直接写入response，实现边压缩边下载 ZipOutputStream zipos = null; try &#123; zipos = new ZipOutputStream( new BufferedOutputStream(response.getOutputStream())); zipos.setMethod(ZipOutputStream.DEFLATED); //设置压缩方法 &#125; catch (Exception e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; //循环将文件写入压缩流 DataOutputStream os = null; for(int i = 0; i &lt; fileList.size(); i++ )&#123; File file = fileList.get(i); try &#123; //添加ZipEntry，并ZipEntry中写入文件流 //这里，加上i是防止要下载的文件有重名的导致下载失败 zipos.putNextEntry(new ZipEntry(i + file.getName())); os = new DataOutputStream(zipos); InputStream is = new FileInputStream(file); byte[] b = new byte[100]; int length = 0; while((length = is.read(b))!= -1)&#123; os.write(b, 0, length); &#125; is.close(); zipos.closeEntry(); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; &#125; //关闭流 try &#123; os.flush(); os.close(); zipos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; return new ReturnT(HttpStatus.OK, \"下载成功\", null);&#125; 其它文件操作获取单个文件的所有内容123456789101112131415161718192021222324/** * 获取单个文件的所有内容 * @param fileName 文件全路径 * @return */public static String readToString(String fileName) &#123; try &#123; File file = new File(fileName); Long filelength = file.length(); byte[] filecontent = new byte[filelength.intValue()]; FileInputStream in = new FileInputStream(file); in.read(filecontent); in.close(); return new String(filecontent, encoding); &#125; catch (FileNotFoundException e) &#123; logger.error(\"该文件不存在或路径错误\",e); e.printStackTrace(); return null; &#125; catch (IOException e) &#123; logger.error(\"读取文件出错\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的文件名列表(全路径)123456789101112131415161718192021222324252627282930/** * 获取多个文件文件列表(全路径) * @param fileDir 文件夹路径 * @param picturePath 图片相对路径 * @param request * @return 返回带域名的文件路径 */public static List&lt;String&gt; readToListPath(String fileDir, String picturePath, HttpServletRequest request) &#123; //获取带部署环境上下文的域名 StringBuffer url = request.getRequestURL(); String tempContextUrl = url .delete(url.length() - request.getRequestURI().length(), url.length()) .append(request.getContextPath()).toString(); List&lt;String&gt; fileNameList = new ArrayList&lt;&gt;(); try &#123; List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); if (fileList.size()==0)&#123; return fileNameList; &#125; for (File f1 : fileList) &#123; fileNameList.add(tempContextUrl+picturePath+\"/\"+f1.getName()); &#125; return fileNameList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件文件列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的内容列表123456789101112131415161718192021/** * 获取多个文件内容列表 * @param fileDir 文件所在路径 * @return */public static List&lt;String&gt; readToListAndString(String fileDir)&#123; try &#123; List&lt;String&gt; fileContentList = new ArrayList&lt;&gt;(); List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); for (File file : fileList)&#123; if(!readToString(file.toString()).equals(\"\"))&#123; fileContentList.add(readToString(file.toString())); &#125; &#125; return fileContentList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件内容列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 递归获取目录下的所有文件123456789101112131415161718192021222324252627282930/** * 递归获取目录下的所有文件 * @param fileDir 文件所在路径 * @return */public static List&lt;File&gt; getFilePath(String fileDir,String endsWith)&#123; List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); File file = new File(fileDir); File[] files = file.listFiles();// 获取目录下的所有文件或文件夹 if (files == null) &#123;// 如果目录为空，返回空 return null; &#125; // 遍历，目录下的所有文件 for (File f : files) &#123; if (f.isFile()) &#123; if(endsWith.equals(\"\")||endsWith==null)&#123; fileList.add(f); &#125;else &#123; if (f.getName().endsWith(endsWith))&#123; fileList.add(f); &#125; &#125; &#125; else if (f.isDirectory()) &#123; getFilePath(f.getAbsolutePath(),endsWith); &#125; &#125; return fileList;&#125; 递归删除文件（删除文件夹）12345678910111213141516171819/** * 递归删除目录下的所有文件及子目录下所有文件 * @param dir 目录路径 * @return */public static boolean deleteDir(File dir) &#123; if (dir.isDirectory()) &#123; String[] children = dir.list(); //递归删除目录中的子目录下 for (int i=0; i&lt;children.length; i++) &#123; boolean success = deleteDir(new File(dir, children[i])); if (!success) &#123; return false; &#125; &#125; &#125; // 目录此时为空或者是文件，可以删除 return dir.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"文件打包","slug":"文件打包","permalink":"/tags/文件打包/"},{"name":"压缩文件解压","slug":"压缩文件解压","permalink":"/tags/压缩文件解压/"}]},{"title":"linux环境下安装 openOffice 并启动服务","slug":"linux环境下安装-openOffice-并启动服务","date":"2018-12-25T02:07:07.000Z","updated":"2019-01-10T08:06:15.269Z","comments":true,"path":"2018/12/25/linux环境下安装-openOffice-并启动服务/","link":"","permalink":"/2018/12/25/linux环境下安装-openOffice-并启动服务/","excerpt":"","text":"背景故事这两天遇到一个大坑，客户要做office 文档在线预览功能，于是乎就要把office文档转换成pdf交给前端显示。 在某度找了一圈都说openOffice+jodconverter 可以搞定这个事情。代码倒是很好找，不过版本很多，各类jar包也很多，但尝试下来发现，转化效果很一般，复杂的excel也无法成功。有同事建议放到服务器上效果可能好些，于是就开始折腾在服务器上安装OpenOffice这个事情。网上各种找大神的博文，发现安装起来不是很顺畅，就写了这篇随笔，记录一下，遇到的问题，方便自己以后查看。 ​ openOffice转转word文档效果不错，转Excel的话就真的效果不行，简单的Excel能处理处理，复杂的就很慢很慢，而且效果极差。再说，实际上微软自己的office软件转pdf的效果也很差。 操作步骤 http://www.openoffice.org/zh-cn/download/ 去官网链接下载linux版本的openOffice 以4.1.6 版本为例。 将压缩包上传至服务器上，并进行解压安装。 12345tar -zxvf 对应的压缩包名字cd 进入解压后的 /zh-cn/RPMSyum localinstall *.rpmcd desktop-integrationrpm -ivh openoffice4.1.6-redhat-menus-4.1.6-9789.noarch.rpm 默认会安装在/opt目录下。 启动服务 123/opt/openoffice4/program/soffice -headless -accept=\"socket,host=127.0.0.1,port=8100;urp;\" -nofirststartwizard 临时启动nohup /opt/openoffice4/program/soffice -headless -accept=\"socket,host=127.0.0.1,port=8100;urp;\" -nofirststartwizard &amp; 后台启动 端口号根据自己项目实际来确定。 后台启动会一直占用内存，据各路大神说 大概100M，我自己没测过具体值不清楚。 有的程序是需要预先启动openOffice 服务的，有的则在代码里自己启动服务。 .查看进程 1netstat -lnp |grep 端口号 大概显示成这样就算启动完了。 1tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 14362/soffice.bin 问题装完openoffice后启动服务可能会报错：no suitable windowing system found, exiting 从字面上的意思就是缺少一个窗口化的系统。所以就安装一个。 1yum groupinstall \"X Window System\"","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"openOffice","slug":"openOffice","permalink":"/tags/openOffice/"},{"name":"安装","slug":"安装","permalink":"/tags/安装/"}]},{"title":"将Word(.doc)里的图片替换成文本","slug":"将Word-doc-里的图片替换成文本","date":"2018-12-20T03:23:24.000Z","updated":"2018-12-29T03:04:42.141Z","comments":true,"path":"2018/12/20/将Word-doc-里的图片替换成文本/","link":"","permalink":"/2018/12/20/将Word-doc-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖1234567891011121314151617181920212223242526&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt;&lt;!-- Jsoup-用以解析HTML --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Jsoup-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195public static void main(String argv[]) &#123; try &#123; //源文件全路径 String oldFileName = \"D:/Test/ml/test.doc\"; //目标文件全路径 String newFileName = \"D:/Test/ml/html_to_word.doc\"; //构造HTML生成全路径 String temporary = new File(oldFileName).getParent()+File.separator+\"temporary.html\"; //读取DOC生成获得html内容和图片集 Map&lt;String,Object&gt; map = convert2Html(oldFileName); //取得图片集 List&lt;String&gt; listPics = (List&lt;String&gt;) map.get(\"listPics\"); //取得生成的html内容 String htmlContent = (String) map.get(\"htmlContent\"); for (String pic : listPics)&#123; //有后缀名的图片才进行识别 if (pic.lastIndexOf(\".\") != -1)&#123; //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //文字替换图片 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;\"); &#125;else &#123;/*因为识别出来的非图片格式（即：无后缀名）的图片再放回doc时会出现 图片异常显示，所以以\"&lt;span&gt;&lt;/span&gt;\"进行占位*/ //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //占位 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&lt;/span&gt;\"); &#125; &#125; //输出HTML文件 writeFile(htmlContent, temporary); //HTML转Doc html2Doc(temporary,newFileName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 输出HTML文件 * @param content 从doc读取生成的html文本 * @param path 目标文件全路径 */public static void writeFile(String content, String path) &#123; FileOutputStream fos = null; BufferedWriter bw = null; org.jsoup.nodes.Document doc = Jsoup.parse(content); String styleOld=doc.getElementsByTag(\"style\").html(); //统一字体格式为宋体 styleOld=styleOld.replaceAll(\"font-family:.+(?=;\\\\b)\", \"font-family:SimSun\"); doc.getElementsByTag(\"head\").empty(); doc.getElementsByTag(\"head\") .append(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); doc.getElementsByTag(\"head\") .append(\" &lt;style type=\\\"text/css\\\"&gt;&lt;/style&gt;\"); doc.getElementsByTag(\"style\") .append(styleOld); /*正则表达式查询字体内容：font-family:.+(?=;\\b)*/ content=doc.html(); content=content .replace(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;\", \"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); try &#123; File file = new File(path); fos = new FileOutputStream(file); bw = new BufferedWriter(new OutputStreamWriter(fos,\"UTF-8\")); bw.write(content); &#125; catch (FileNotFoundException fnfe) &#123; fnfe.printStackTrace(); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; finally &#123; try &#123; if (bw != null) bw.close(); if (fos != null) fos.close(); &#125; catch (IOException ie) &#123; &#125; &#125;&#125;/** * 读取DOC生成获得html内容和图片集 * @param fileName 源文件全路径 * @return 返回的map中包含html内容和图片集 * @throws Exception */public static Map&lt;String,Object&gt; convert2Html(String fileName) throws Exception &#123; //存放html内容和图片集 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //保存图片集 List&lt;String&gt; listPics = new ArrayList&lt;&gt;(); //构造提取出来的图片保存路径以及HTML中&lt;img&gt;的图片源路径 String imgPath = new File(fileName).getParent()+ File.separator+\"img\"+File.separator; File file = new File(imgPath); //不存在，则创建 if (!file.exists())&#123; file.mkdirs(); &#125; HWPFDocument wordDocument = new HWPFDocument(new FileInputStream(fileName)); //WordToHtmlUtils.loadDoc(new FileInputStream(inputFile)); WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter( DocumentBuilderFactory.newInstance().newDocumentBuilder() .newDocument()); wordToHtmlConverter.setPicturesManager( new PicturesManager() &#123; public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches ) &#123; return imgPath.replace(\"\\\\\",\"/\") + suggestedName; &#125; &#125; ); wordToHtmlConverter.processDocument(wordDocument); //保存图片 List pics=wordDocument.getPicturesTable().getAllPictures(); if(pics!=null)&#123; for(int i=0;i&lt;pics.size();i++)&#123; Picture pic = (Picture)pics.get(i); try &#123; String picAbsolutePath = imgPath + pic.suggestFullFileName(); //将图片全路径存入listPics listPics.add(picAbsolutePath); pic.writeImageContent(new FileOutputStream(picAbsolutePath)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Document htmlDocument = wordToHtmlConverter.getDocument(); ByteArrayOutputStream out = new ByteArrayOutputStream(); DOMSource domSource = new DOMSource(htmlDocument); StreamResult streamResult = new StreamResult(out); TransformerFactory tf = TransformerFactory.newInstance(); Transformer serializer = tf.newTransformer(); serializer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); serializer.setOutputProperty(OutputKeys.INDENT, \"yes\"); serializer.setOutputProperty(OutputKeys.METHOD, \"HTML\"); serializer.transform(domSource, streamResult); out.close(); String htmlContent=new String(out.toByteArray()); //替换UEditor无法识别的转义字符 htmlContent=htmlContent.replaceAll(\"&amp;ldquo;\",\"\\\"\").replaceAll(\"&amp;rdquo;\",\"\\\"\") .replaceAll(\"&amp;mdash;\",\"-\"); map.put(\"htmlContent\",htmlContent); map.put(\"listPics\",listPics); return map;&#125;/** * html转doc * @param source * @param target * @throws Exception */public static void html2Doc(String source , String target) throws Exception &#123; //创建 POIFSFileSystem 对象 POIFSFileSystem poifs = new POIFSFileSystem(); //获取DirectoryEntry DirectoryEntry directory = poifs.getRoot(); //创建输出流 OutputStream out = new FileOutputStream(target); try &#123; //创建文档,1.格式\"WordDocument\",2.HTML文件输入流 directory.createDocument(\"WordDocument\", new FileInputStream(source)); //写入 poifs.writeFilesystem(out); //释放资源 out.close(); System.out.println(\"success\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"},{"name":"Jsoup","slug":"Jsoup","permalink":"/tags/Jsoup/"}]},{"title":"OpenOffice-实现文件格式之间的转换.md","slug":"OpenOffice-实现文件格式之间的转换","date":"2018-12-18T11:10:47.000Z","updated":"2018-12-18T12:50:46.786Z","comments":true,"path":"2018/12/18/OpenOffice-实现文件格式之间的转换/","link":"","permalink":"/2018/12/18/OpenOffice-实现文件格式之间的转换/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iTextPDF-实现向PDF追加内容","slug":"iTextPDF-实现向PDF追加内容","date":"2018-12-18T11:10:03.000Z","updated":"2018-12-18T12:49:51.129Z","comments":true,"path":"2018/12/18/iTextPDF-实现向PDF追加内容/","link":"","permalink":"/2018/12/18/iTextPDF-实现向PDF追加内容/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"将Word(.docx)-里的图片替换成文本","slug":"将Word-docx-里的图片替换成文本","date":"2018-12-18T11:08:31.000Z","updated":"2018-12-25T03:01:54.817Z","comments":true,"path":"2018/12/18/将Word-docx-里的图片替换成文本/","link":"","permalink":"/2018/12/18/将Word-docx-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖12345678910111213141516171819&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public static void main(String[] args) throws Exception &#123; textReplacePhoto(\"D:\\\\Test\\\\原报格式样例3.docx\", \"D:\\\\Test\\\\原报格式样例3-1.docx\",\"D:/Test/img\");&#125;/** * 将word里的图片全部替换成文本 * @param oldFileName 传入原文件的全路径（含文件名） * @param newFileName 保存修改后文件的全路径（含文件名） * @param picturePath 读取出来的图片保存路径 * @throws Exception */public static void textReplacePhoto(String oldFileName, String newFileName, String picturePath) throws Exception &#123; File newFile = new File(newFileName.replace(new File(newFileName).getName(),\"\")); //保存路径不存在，则创建 if (!newFile.exists())&#123; newFile.mkdirs(); &#125; if (oldFileName.endsWith(\".docx\"))&#123; //.docx文件的处理方法 //为了确定图片集中的某一张图片 int imgNum=0; //创建输入流 InputStream oldIs = new FileInputStream(oldFileName); //创建输出流 OutputStream newOs = new FileOutputStream(newFileName); //创建一个XWPFDocument XWPFDocument docx = new XWPFDocument(oldIs); //获取到该文档的所有段落集 List&lt;XWPFParagraph&gt; paras = docx.getParagraphs(); //获取到该文档的所有图片集 List&lt;XWPFPictureData&gt; pictures = docx.getAllPictures(); for (XWPFParagraph para:paras)&#123; //段落中所有XWPFRun List&lt;XWPFRun&gt; runList = para.getRuns(); for (int i=0;i&lt;runList.size();i++) &#123; XWPFRun run=runList.get(i); //判断该段落是否是图片 if (!run.getEmbeddedPictures().isEmpty())&#123; //存储读取到的图片,并获取图片全路径 String pictureName=savePictureDocx(pictures,picturePath,imgNum++); //实际有图片才进行以下操作 if (pictureName!=null)&#123; //删除图片 para.removeRun(i); //插入文字 para.insertNewRun(i).setText(\"&#123;&#123;title&#125;&#125;\"); //删除图片 deletePicture(pictureName); &#125; &#125; &#125; &#125; docx.write(newOs); docx.close(); oldIs.close(); newOs.flush(); newOs.close(); &#125;&#125;/** * 存储读取到的图片 - docx * @param pictures 图片集 * @param picturePath 图片保存路径 * @param imgNum 确定图片集中的某一张图片 * @return 图片全路径 * @throws IOException */public static String savePictureDocx(List&lt;XWPFPictureData&gt; pictures, String picturePath,int imgNum) throws IOException &#123; File pictureFile = new File(picturePath); //保存路径不存在，则创建 if (!pictureFile.exists())&#123; pictureFile.mkdirs(); &#125; List&lt;XWPFPictureData&gt; pictures = para.getDocument().getAllPictures(); if (pictures.size()!=0)&#123; XWPFPictureData picture = pictures.get(imgNum); String rawName = picture.getFileName(); String fileExt = rawName.substring(rawName.lastIndexOf(\".\")); String newName = System.currentTimeMillis() + UUID.randomUUID().toString() + fileExt; String pictureName = picturePath + File.separator + newName; FileOutputStream fos = new FileOutputStream(pictureName); fos.write(picture.getData()); fos.flush(); fos.close(); return pictureName; &#125; return null;&#125;/** * 删除临时存储的图片 * @param pictureName 图片全路径（含文件名） * @return */public static boolean deletePicture(String pictureName) &#123; File pictureFile = new File(pictureName); // 目录此时为空，可以删除 return pictureFile.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"}]},{"title":"用VNC搭建Ubuntu VNC可视化界面","slug":"用VNC搭建Ubuntu VNC可视化界面","date":"2018-12-10T11:48:46.000Z","updated":"2019-01-10T08:08:55.307Z","comments":true,"path":"2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","link":"","permalink":"/2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","excerpt":"","text":"安装配置软件 VNC的安装与配置安装之前先输入（获取最新套件的信息） 1apt-get update 输入以下命令安装VNC，安装过程中需要输入Y来确认 1apt-get install vnc4server 启动VNC（第一次启动需要设置密码） 1vncserver 开机启动请参考：ubuntu-18-04-1-开机启动脚本 设置vncservgnome 桌面环境安装与配置（可直接跳至第3步）安装x－windows的基础 1sudo apt-get install x-window-system-core 安装登录管理器 1sudo apt-get install gdm 安装Ubuntu的桌面 1sudo apt-get install ubuntu-desktop 安装gnome配套软件 1sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal 修改VNC配置文件 1sudo vi ~/.vnc/xstartup 修改为： 1234567891011#!/bin/sh# Uncomment the following two lines for normal desktop:export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrcunset DBUS_SESSION_BUS_ADDRESSgnome-panel &amp;gnmoe-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp; 杀掉原桌面进程，输入命令（其中的:1是桌面号）： 1vncserver -kill :1 输入以下命令生成新的会话： 1vncserver :1 ubuntu卸载gnome桌面（可直接跳至第3步） 之前安装好了ubuntu18.04，本来想装个gnome shell来美化一下桌面，结果出现了开机黑屏（灰屏）的现象，经网上查询发现是显卡驱动在gnome3的环境下产生了不兼容，具体解决方法我还没找到，情急之下只能先卸载掉gnome桌面环境。 卸载掉gnome-shell主程序1sudo apt-get remove gnome-shell 卸载掉gnome1sudo apt-get remove gnome 卸载不需要的依赖关系1sudo apt-get autoremove 彻底卸载删除gnome的相关配置文件1sudo apt-get purge gnome 清理安装gnome时候留下的缓存程序软件包12sudo apt-get autocleansudo apt-get clean ubuntu运行VNC Server无桌面时的解决方案配置vnc server实在是一个特别诡异的事，我在不同的ubuntu机器上配置服务时，总是遇到千奇百怪的问题，大部分情况下比较顺利，将~/.vnc/xstartup最后一句x-window-manager&amp;替换为gnome-session&amp;就能顺利地出现桌面，而有些则不行，需要改为gnome-session --session=ubuntu-2d&amp; 问题而今天遇到的ubuntu 18.04，则死活不行，用realvnc viewer连接之后，只有灰灰的一个背景，没有桌面，没有terminal。 查阅了很多博文，有说需要安装gnome-session-fallback的，有说需要安装gdm的，也有用kde的，除了kde我没有尝试，另外两种验证无效，依然只有一个灰色背景。 最后用xfce4桌面解决，选择些方案一是因为xfce相对较小，gnome-session死活不行的情况下，再将一个kde未免太过兴师动众，xfce我使用过一段时间，是一个相当轻量级的GUI环境，清爽易用，功能一点不含糊。决定之后，一次尝试即成功。 安装xfce1sudo apt-get install gnome-core xfce4 配置编辑~/.vnc/xstartup文件： 12345678#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp; 输入以下命令生成新的会话： 1vncserver :1 本地使用VNC连接 本地安装VNC后，使用ip地址:1（其中的:1是桌面号）的方式连接 输入之前设置的VNC密码后点击连接 附录 下载地址VNC Viewer和VNC Server","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"VNC","slug":"VNC","permalink":"/tags/VNC/"}]},{"title":"Linux下安装Java JDK8","slug":"Linux下安装Java-JDK8","date":"2018-12-10T11:44:56.000Z","updated":"2019-01-10T08:06:43.445Z","comments":true,"path":"2018/12/10/Linux下安装Java-JDK8/","link":"","permalink":"/2018/12/10/Linux下安装Java-JDK8/","excerpt":"","text":"手动下载压缩包安装oracle Java JDK 前往oracle Java官网下载JDK 解压缩到指定目录（以jdk-8u144-linux-x64.tar.gz为例） 创建目录: 1sudo mkdir /usr/lib/jvm 解压缩到该目录: 1sudo tar -zxvf jdk-7u60-linux-x64.gz -C /usr/lib/jvm 修改环境变量: 1sudo vi ~/.bashrc 在文件末尾追加下面内容： 12345#set oracle jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量马上生效： 1source ~/.bashrc 查看java版本，看看是否安装成功： 1java -version","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"}]},{"title":"Linux的使用技巧","slug":"Linux的使用技巧","date":"2018-12-10T11:21:02.000Z","updated":"2020-07-17T03:36:46.366Z","comments":true,"path":"2018/12/10/Linux的使用技巧/","link":"","permalink":"/2018/12/10/Linux的使用技巧/","excerpt":"","text":"修改用户名例：将admin改为test（ubuntu） 修改 /etc/passwd用户信息文件1vim /etc/passwd 123#admin:x:1001:1001:admin,,,:/home/admin:/bin/bash#把用户名admin改成rest#test:x:1001:1001:admin,,,:/home/test:/bin/bash 注： 12admin:x:1001:1001:admin,,,:/home/admin:/bin/bash中的admin,,,不可修改，若修改后重启，你将会因为密码错误而不能成功登入系统（只得去机房重新注册用户了） 修改 /etc/shadow用户密码文件1vim /etc/shadow 123#admin:Dnakfw28zf38w:8764:0:168:7:::#由于密码加密方式存放，只修改用户名即可（密码不变）#test:Dnakfw28zf38w:8764:0:168:7::: 再修改 /etc/group用户组文件1vim /etc/group 123#admin:x:1:root,bin,admin#修改admin组为test组#test:x:1:root,bin,test 修改用户的家目录1mv /home/admin /home/test xx is not in the sudoers file 问题解决首先利用whereis 命令查找sudoers配置文件的目录（默认会在/etc/sudoers) 1whereis sudoers 然后就可以利用vi编辑器来把用户添加到sudoers之中 1vi /etc/sudoers 然后找到root ALL=(ALL) ALL 或者 root ALL=(ALL:ALL) ALL所在的位置，把所要添加的用户添加到文件之中 下面是添加完的结果。 1234Allow root to run any commands anywhereroot ALL=(ALL) ALLmaliang ALL=(ALL) ALL（这一行是添加的内容，maliang是我的用户名） 修改用户密码在终端运行 1passwd username 123456改变口令为 username。(当前)UNIX 口令：&lt;输入现在的密码&gt; 输入新的 UNIX 口令： &lt;输入新密码&gt; 重新输入新的 UNIX 口令：&lt;重新输入新密码&gt;passwd：已成功更新密码 开启root用户和使用root用户登陆 以普通用户登录系统，创建root用户的密码 1sudo passwd root 修改文件sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf文件，增加两行： 12greeter-show-manual-login=trueallow-guest=false 保存 修改/etc/pam.d/gdm-autologin、/etc/pam.d/gdm-password文件和/root/.profile文件（ubuntu-18.04需要此步骤） 1vi /etc/pam.d/gdm-autologin 注释掉：auth required pam_succeed_if.so user != root quiet_success 保存 1vi /etc/pam.d/gdm-password 注释掉：auth required pam_succeed_if.so user != root quiet_success 保存 1vim /root/.profile 将文件末尾的mesg n || true这一行修改成tty -s &amp;&amp; mesg n || true 保存 重启系统，输入root用户名和密码，登录系统 解决Ubuntu18.04不能用Xshell使用root用户登录 今天使用Xshell6连接Ubuntu18.04时，连接普通用户可以，但是连接root用户不行（但是实体机或者虚拟机可以root用户登录） 解决方案是： 在Ubuntu18.04中 修改 /etc/ssh/sshd_config这个文件： 1vim /etc/ssh/sshd_config 这是没修改前的： 123456789...# Authentication:#LoginGraceTime 2m#PermitRootLogin prohibit-password#StrictModes yes#MaxAuthTries 6#MaxSessions 10... 修改后的： 12345678910...# Authentication:LoginGraceTime 2m#PermitRootLogin prohibit-passwordPermitRootLogin yesStrictModes yes#MaxAuthTries 6#MaxSessions 10... 然后再在终端输入一下命令：/etc/init.d/ssh restart 来重启ssh服务 重新使用root连接，就可以了 找出文件所在的位置1whereis sudoers（你要找的文件名） linux find 命令查找文件和文件夹查找目录：find /（查找目录范围） -name &#39;查找关键字&#39; -type d查找文件：find /（查找目录范围） -name &#39;查找关键字&#39; -print 查看端口占用并杀死(kill)Linux1234# 查看sudo netstat -tlnp|grep 9090# 查看ps aux|grep yum 12# 杀死kill -9 31540 Window 第一步，打开cmd命令窗口，输入命令，根据端口号查找对应的进程号 1netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80 结果如下： 发现 8080 端口被 PID(进程号)为 9268 的进程占用。 第二步， 据进程号寻找进程名称 1tasklist | findstr 9268 根据进程号从任务管理器中查找该程序，手动杀死即可。 但是我发现，【有时候】在任务管理器中找不到该程序。只好从命令行杀死该程序了，命令如下： 1taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程 这样就把占用8080端口的进程给干掉了，终于可以愉快的不用重启电脑了。 如何从Yum库下载rpm包但不安装方法一（推荐） 12# 将一个包（包含所有依赖）下载到一个指定的目录(如/opt/gccmkdir/)：yum install -y gcc --downloadonly --downloaddir=/opt/gccmkdir/ 方法二 12# --resolve 表示为下载依赖yumdownloader lsof --resolve --destdir=/data/mydepot/ 方法三（推荐） 12345# 把/etc/yum.conf配置中的keepcache=0参数修改为keepcache=1# 再yum 下载：yum install -y gcc#默认情况下，RPM包会保存在下面的目录中:/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages apt-get 与 yum安装有啥区别rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 1234yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：安装：yum install &lt;package_name&gt; 卸载：yum remove &lt;package_name&gt; 更新：yum update &lt;package_name&gt; 1234apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理：安装：apt-get install &lt;package_name&gt; 卸载：apt-get remove &lt;package_name&gt; 更新：apt-get update &lt;package_name&gt; 安装rpm包进入系统下存放对应.rpm文件的目录，执行 12cd /opt/gccmkdir/rpm -Uvh *.rpm --nodeps --force 注：rpm -Uvh *.rpm –nodeps –force -Uvh就是升级软件包–Update *.rpm就是所有的.rpm包； –nodeps就是安装时不检查依赖关系，比如你这个rpm需要A，但是你没装A，这样你的包就装不上，用了–nodeps你就能装上了； –force就是强制安装，比如你装过这个rpm的版本1，如果你想装这个rpm的版本2，就需要用–force强制安装。 查看Linux版本方法方法一 123456# lsb_release -aLSB Version: :core-3.1-ia32:core-3.1-noarch:graphics-3.1-ia32:graphics-3.1-noarchDistributor ID: CentOSDescription: CentOS release 5.4 (Final)Release: 5.4Codename: Final 方法二 12# cat /etc/redhat-releaseCentOS release 5.4 (Final) 方法三 12# rpm -q centos-releasecentos-release-5-4.el5.centos.1 查看物理CPU个数、核数、逻辑CPU个数、CPU信息（型号）、内存信息1234567891011121314151617# 总核数 = 物理CPU个数 * 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数# 查看物理CPU个数cat /proc/cpuinfo| grep \"physical id\"| sort| uniq| wc -l# 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep \"cpu cores\"| uniq# 查看逻辑CPU的个数cat /proc/cpuinfo| grep \"processor\"| wc -l# 查看CPU信息（型号）cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c# 查看内 存信息cat /proc/meminfo linux运行jar包要运行java的项目需要先将项目打包成war包或者jar包，打包成war包需要将war包部署到tomcat服务器上才能运行。而打包成jar包可以直接使用java命令执行。在linux系统中运行jar包主要有以下四种方式。 1java -jar XXX.jar 这是最基本的jar包执行方式，但是当我们用ctrl+c中断或者关闭窗口时，程序也会中断执行。 1java -jar XXX.jar &amp; &amp;代表在后台运行，使用ctrl+c不会中断程序的运行，但是关闭窗口会中断程序的运行。 1nohup java -jar XXX.jar &amp; 使用这种方式运行的程序日志会输出到当前目录下的nohup.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 1nohup java -jar XXX.jar &gt;temp.out &amp; ‘&gt;temp.out’的意思是将日志输出重定向到temp.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 XShell上传、下载本地文件到linux服务器在linux主机上，安装上传下载工具包rz及sz; 如果不知道你要安装包的具体名称，可以使用yum provides */name 进行查找系统自带软件包的信息 123456[root@host ~]# yum provides */rz...lrzsz-0.12.20-36.el7.x86_64 : The lrz and lsz modem communications programsRepo : baseMatched from:Filename : /usr/bin/rz 一般会列出软件包的名称及版本，还有安装路径；查询到软件包名后，使用yum install -y 包名 进行安装。 lrzsz包安装完成后包括上传rz、下载sz命令 1[root@host ~]# yum install -y lrzsz 上传命令为rz；下再命令为sz 12#上传（windows-&gt;linux）文件-弹出窗口选择需要上传的文件[root@host ~]# rz 12#指定下载（linux-&gt;windows）哪个文件-弹出窗口选择需要保存的路径[root@host ~]# sz 文件名称 ubuntu安装ssh服务SSH分客户端openssh-client和openssh-server 如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo apt-get install openssh-client） 如果要使本机开放SSH服务就需要安装openssh-serversudo（apt-get install openssh-server） 1apt-get install openssh-server 有时候当你执行sudo apt-get XXX这种命令时出现类似下面的输出错误： 12E: Could not get lock /var/lib/dpkg/lock - open (11 Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/) is another process using it? 或者 12345E: Could not ge lock /var/lib/apt/lists/lock - open (11: Resource temporarilyunavailable)E: Unable to lock directory /var/lib/apt/lists/ E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解释 出现这个问题的原因是，还有一个线程在使用apt-get进行下载的操作。但是奇怪的是，我就是没有找到其他使用了apt-get指令的终端界面。那么如何解决这个问题呢，难道要重新启动电脑吗，重启电脑是可以解决这个问题，但是我接下来教你的方法，才是真正的解决方法。 解决办法 先搜索所有运行着的线程 1ps -A | grep apt-get 你会得到类似下面的输出： 123root 752 0.0 0.0 4508 1628 ? Ss 01:13 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily_apt 2098 0.1 0.1 49572 5524 ? S 01:18 0:06 /usr/lib/apt/methods/httpaobo 4425 0.0 0.0 18484 980 pts/1 S+ 02:13 0:00 grep --color=auto apt 第2列就是线程号(kill processnumber)。我们将apt相关的进程给关闭掉，需要使用sudo权限： 1sudo kill 2098 输出： bash: kill: (2098) - Operation not permitted 然后确认sshserver是否启动了： 1ps -e |grep ssh 如果看到sshd那说明ssh-server已经启动了 CentOS7中找不到ifconfig和netstat命令把net-tools包装上就好了 1yum install net-tools 用ifconfig或者ip a命令，获取不到IP地址问题描述：用ifconfig或者ip a命令，获取不到ip地址，即网卡未启动，无法用Xshell远程连接。 解决方案： 进入/etc/sysconfig/network-scripts目录，发现有一个或多个ifcfg-...，即网卡（驱动）存在但未启用。 1ls /etc/sysconfig/network-scripts 修改/etc/sysconfig/network-scripts/ifcfg-...文件， 把ONBOOT=no改为ONBOOT=yes保存退出wq 123vi /etc/sysconfig/network-scripts/ifcfg-em1...# 把`ONBOOT=no`改为`ONBOOT=yes`保存退出 service network restart重启。出现： 1Restarting network (via systemctl): [ 确定 ] OK 输入ifconfig或者ip a命令，出现ip地址。用Xshell连接成功。 CentOS下彻底删除MySQL和重新安装MySQL删除MySQL12345yum remove mysql mysql-server mysql-libs mysql-server;find / -name mysql 将找到的相关东西delete(rm -rf ...)掉；rpm -qa|grep mysql(查询出来的东东yum remove掉) 安装MySQL1yum install mysql mysql-server mysql-libs mysql-server 如何判断Linux是32位还是64位方法1：getconf LONG_BIT 查看 1getconf LONG_BIT 方法2：uname命令查看 12uname -auname -m 方法3: arch命令查看 1arch 方法4: file命令查看 12file /sbin/initfile /bin/ls 方法5: 通过查看CPU的信息来判定Linux系统是否是64位操作系统 12# 如果结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bitcat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 怎样查看MySql数据库物理文件存放位置1mysql&gt; show global variables like \"%datadir%\"; CentOS7查看修改时区 timedatectl查看时间各种状态 1234567Local time: 四 2014-12-25 10:52:10 CSTUniversal time: 四 2014-12-25 02:52:10 UTCRTC time: 四 2014-12-25 02:52:10Timezone: Asia/Shanghai (CST, +0800)NTP enabled: yesNTP synchronized: yesRTC in local TZ: no timedatectl list-timezones: 列出所有时区 timedatectl set-local-rtc 1 将硬件时钟调整为与本地时钟一致, 0 为设置为 UTC 时间 timedatectl set-timezone Asia/Shanghai 设置系统时区为上海 校准时间 123yum -y install ntp#通过阿里云时间服务器校准时间ntpdate ntp1.aliyun.com Linux文件和目录的权限文件权限12345678910111213141516171819202122232425262728在linux系统中,文件或目录的权限可以分为3种:r:4 读w:2 写x:1 执行(运行)－：对应数值0数字 4 、2 和 1表示读、写、执行权限rwx = 4 + 2 + 1 = 7 (可读写运行）rw = 4 + 2 = 6 （可读写不可运行）rx = 4 +1 = 5 （可读可运行不可写）示例:最高权限777:(4+2+1) (4+2+1) (4+2+1)第一个7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限第二个7:表示当前文件的所属组（同组用户）权限,7=4+2+1 可读可写可执行权限第三个7:表示当前文件的组外权限,7=4+2+1 可读可写可执行权限示例:755:(4+2+1) (4+1) (4+1)第一个7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限第二个5:表示当前文件的所属组（同组用户）权限,5=4+1 可读可执行权限第三个5:表示当前文件的组外权限,5=4+1 可读可执行权限示例:644:(4+2) (4) (4)第一个6:表示当前文件的拥有者的权限,6=4+2 可读可写不可执行权限第二个4:表示当前文件的所属组（同组用户）权限,4=4 可读权限第三个4:表示当前文件的组外权限,4=4 可读权限 查看文件的权限(ls -l 或 ls ll 或 ls -al)12345678910111213141516171819202122232425262728293031323334353637383940414243[root@yisu-5d5ba64634728 bin]# ls -lltotal 828#####1#### #2# #3# #4## ##5## #####6###### ####7#######-rw-r-----. 1 root root 35065 Aug 15 2019 bootstrap.jar-rw-r-----. 1 root root 15900 Aug 15 2019 catalina.bat-rwxr-x---. 1 root root 23464 Aug 15 2019 catalina.sh-rw-r-----. 1 root root 1664 Aug 15 2019 catalina-tasks.xml-rw-r-----. 1 root root 2123 Aug 15 2019 ciphers.bat-rwxr-x---. 1 root root 1997 Aug 15 2019 ciphers.sh-rw-r-----. 1 root root 24938 Aug 15 2019 commons-daemon.jar-rw-r-----. 1 root root 169835 Aug 15 2019 commons-daemon-native.tar.gz-rw-r-----. 1 root root 2040 Aug 15 2019 configtest.bat-rwxr-x---. 1 root root 1922 Aug 15 2019 configtest.sh-rwxr-x---. 1 root root 8513 Aug 15 2019 daemon.sh-rw-r-----. 1 root root 2091 Aug 15 2019 digest.bat-rwxr-x---. 1 root root 1965 Aug 15 2019 digest.sh-rw-r-----. 1 root root 3606 Aug 15 2019 makebase.bat-rwxr-x---. 1 root root 3382 Aug 15 2019 makebase.sh-rw-r-----. 1 root root 3460 Aug 15 2019 setclasspath.bat-rwxr-x---. 1 root root 3708 Aug 15 2019 setclasspath.sh-rw-r-----. 1 root root 2020 Aug 15 2019 shutdown.bat-rwxr-x---. 1 root root 1902 Aug 15 2019 shutdown.sh-rw-r-----. 1 root root 2022 Aug 15 2019 startup.bat-rwxr-x---. 1 root root 1904 Aug 15 2019 startup.sh-rw-r-----. 1 root root 47882 Aug 15 2019 tomcat-juli.jar-rw-r-----. 1 root root 419428 Aug 15 2019 tomcat-native.tar.gz-rw-r-----. 1 root root 4574 Aug 15 2019 tool-wrapper.bat-rwxr-x---. 1 root root 5515 Aug 15 2019 tool-wrapper.sh-rw-r-----. 1 root root 2026 Aug 15 2019 version.bat-rwxr-x---. 1 root root 1908 Aug 15 2019 version.sh# 总共分为7大列：第一列：文件类型，1-代表普通文件 d-代表目录第二列：文件节点数（node）第三列：表示文件拥有者root用户第四列：表示文件所属组root用户组第五列：显示文件大小，默认是字节byte，可以通过命令 ls -lh 更人性化地查看文件大小第六列：文件最后修改时间第七咧：文件或目录的名称# 测试[root@yisu-5d5ba64634728 bin]# ls -lh version.sh -rwxr-x---. 1 root root 1.9K Aug 15 2019 version.sh 设置文件/目录的权限(ls -l 或 ls ll 或 ls -al)12345# 语法： chomd 755 文件名# 例如：chmod -R 755 /home/ftpuser Warning:Permanently added (RSA) to the list of known hostsvi /etc/ssh/ssh_config 找到#StrictHostKeyChecking ask去掉注释，并把ask改为no即可","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"CentOS","slug":"CentOS","permalink":"/tags/CentOS/"},{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"RedHat","slug":"RedHat","permalink":"/tags/RedHat/"}]}]}