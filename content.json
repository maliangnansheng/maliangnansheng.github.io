{"meta":{"title":"Nan's Blog","subtitle":"弱者才言命，强者只言运！","description":"克己复礼","author":"马亮南生","url":""},"pages":[{"title":"标签","date":"2018-12-06T11:46:40.000Z","updated":"2018-12-10T08:58:50.994Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-06T11:48:02.000Z","updated":"2018-12-10T08:59:19.994Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM -verbose参数详解","slug":"JVM-verbose参数详解","date":"2019-01-28T11:50:55.000Z","updated":"2019-01-28T12:05:53.116Z","comments":true,"path":"2019/01/28/JVM-verbose参数详解/","link":"","permalink":"/2019/01/28/JVM-verbose参数详解/","excerpt":"","text":"java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息java -verbose:class在程序运行的时候有多少类被加载！你可以用verbose:class来监视，在命令行输入java -verbose:class XXX (XXX为程序名)你会在控制台看到加载的类的情况。 配置参数： verbose和verbose:class含义相同，输出虚拟机装入的类的信息，显示的信息格式如下： 12345678910[Opened D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.Object from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.io.Serializable from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar]... java –verbose:gc在虚拟机发生内存回收时在输出设备显示信息，格式如下： [Full GC 256K-&gt;160K(124096K), 0.0042708 secs] 该参数用来监视虚拟机内存回收的情况。 12345678910public class JvmVerbose &#123; /** * JVM -verbose[:class|gc|jni] 参数测试 * @param args */ public static void main(String[] args) &#123; JvmVerbose jvmVerbose = new JvmVerbose(); System.gc(); &#125;&#125; 在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为可达，程序编译后，执行命令： java -verbose:gc JvmVerbose 后结果为： 123[GC 647K-&gt;256K(124096K), 0.0274253 secs][Full GC 256K-&gt;160K(124096K), 0.0042708 secs] 箭头前后的数据256K和160K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有256K-160K=96K的对象容量被回收，括号内的数据124096K为堆内存的总容量，收集所需要的时间是0.0042708秒（这个时间在每次执行的时候会有所不同） java –verbose:jni-verbose:jni输出native方法调用的相关情况，一般用于诊断jni调用错误信息。在虚拟机调用native方法时输出设备显示信息，格式如下： [Dynamic-linking native methodjava.lang.Object.registerNatives ... JNI] 该参数用来监视虚拟机调用本地方法的情况，在发生jni错误时可为诊断提供便利。 小试身手： 123456public class Test &#123; public static void main(String args[])&#123; Test test = new Test(); System.gc(); &#125;&#125; 配置参数： 执行Test.class加载了以下这么多类 1234567891011121314151617181920212223242526[Opened C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Object from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.io.Serializable from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.String from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.reflect.GenericDeclaration from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.reflect.Type from C:\\Java\\jdk7\\jre\\lib\\rt.jar]...[Full GC 812K-&gt;442K(15872K), 0.0031244 secs] [Loaded sun.misc.Cleaner from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Shutdown from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Shutdown$Lock from C:\\Java\\jdk7\\jre\\lib\\rt.jar]...","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"/tags/eclipse/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"Maven生成javadoc(api文档)","slug":"Maven生成javadoc-api文档","date":"2019-01-24T02:16:22.000Z","updated":"2019-01-24T02:24:05.640Z","comments":true,"path":"2019/01/24/Maven生成javadoc-api文档/","link":"","permalink":"/2019/01/24/Maven生成javadoc-api文档/","excerpt":"","text":"pom配置123456789101112131415&lt;!-- properties与dependencys同级 --&gt;&lt;properties&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;configuration&gt; &lt;reportOutputDirectory&gt;../javadocs&lt;/reportOutputDirectory&gt; &lt;destDir&gt;easy-delivery&lt;/destDir&gt; &lt;/configuration&gt;&lt;/plugin&gt; 生成doc命令首先需要打开cmd，然后cd到项目目录下，然后执行下面命令即可 例： 123D:cd D:\\maliangnansheng\\IDEA_HKAI\\hkai-ocrmvn javadoc:javadoc 查看文件比如我的项目在hkai-ocr这个文件夹下面，doc也会生成在与hkai-ocr同级目录（也可以修改上面的配置） 打开生成的doc里index.html 就可以看到api页面","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"/tags/Maven/"},{"name":"api","slug":"api","permalink":"/tags/api/"}]},{"title":"CentOS部署kodexplorer可道云搭建私有网盘","slug":"CentOS部署kodexplorer可道云搭建私有网盘","date":"2019-01-16T06:38:15.000Z","updated":"2019-01-16T07:50:17.841Z","comments":true,"path":"2019/01/16/CentOS部署kodexplorer可道云搭建私有网盘/","link":"","permalink":"/2019/01/16/CentOS部署kodexplorer可道云搭建私有网盘/","excerpt":"","text":"工具/原料 xampp 可道云kodexplorer PHP环境配置 可以在串口使用getconf LONG_BIT 命令来查看并确定linux操作系统版本 输出：32表面系统是32位。输出：64表面系统是64位。 下载与自己操作系统相适应版本的xampp [32bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/5.6.14/xampp-linux-5.6.14-4-installer.run&gt;（7.3.0没有32位版本的，自己找找哪个版本有）[64bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/7.3.0/xampp-linux-x64-7.3.0-0-installer.run 123mkdir /home/xamppcd /home/xampp/wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/7.3.0/xampp-linux-x64-7.3.0-0-installer.run 安装xampp，为私有云安装构建Apache和PHP环境 12chmod u+x xampp-linux-x64-7.3.0-0-installer.run./xampp-linux-x64-7.3.0-0-installer.run 删除包： 1rm -rf /home/xampp/ 启动xampp，执行/opt/lampp/lampp start启动服务 默认安装在/opt/lampp/下 1/opt/lampp/lampp start 下载和安装可道云kodexplorer 下载最新版本的可道云KodExplorer程序 下载地址：http://kodcloud.com/download.html 下载： 1234mkdir /home/kodexplorercd /home/kodexplorer/# 当时最新版wget http://static.kalcaddle.com/update/download/kodexplorer4.37.zip 将可道云kodexplorer.zip解压 1unzip kodexplorer4.37.zip 将解压后的内容拷贝至/opt/lampp/htdocs/目录下 123cp -r /home/kodexplorer/ /opt/lampp/htdocs/chmod 777 /opt/lampp/htdocs/kodexplorerchmod -R 777 /opt/lampp/htdocs/kodexplorer/data/ 删除不用文件： 1rm -rf /home/kodexplorer/ 浏览器访问kodexplorer的index.php即可访问KodExplorer界面 即：http://IP地址/kodexplorer/index.php 例：http://172.19.15.52/kodexplorer/index.php","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"kodexplorer","slug":"kodexplorer","permalink":"/tags/kodexplorer/"},{"name":"部署","slug":"部署","permalink":"/tags/部署/"}]},{"title":"使用Java打开桌面文件","slug":"使用Java打开桌面文件","date":"2019-01-15T09:34:36.000Z","updated":"2019-01-15T09:59:44.143Z","comments":true,"path":"2019/01/15/使用Java打开桌面文件/","link":"","permalink":"/2019/01/15/使用Java打开桌面文件/","excerpt":"","text":"打开某一文件（默认软件打开）123456789101112public static void main(String[] args) &#123; try &#123; Desktop desktop = Desktop.getDesktop(); if (desktop.isSupported(Desktop.Action.OPEN)) &#123; desktop.open(new File(\"Your.pdf\")); //全路径 &#125; else &#123; System.out.println(\"Open is not supported\"); &#125; &#125; catch (IOException exp) &#123; exp.printStackTrace(); &#125;&#125; 指定某一软件打开对应的文件1234Runtime.getRuntime() .exec(\"WINWORD.EXE（使用啥软件打开）所在全路径 D:\\\\test.docx（文件全路径）\");//例：\"C:\\\\Program Files\\\\Microsoft Office\\\\root\\\\Office16\\\\WINWORD.EXE D:\\\\3.pdf\"","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"Desktop","slug":"Desktop","permalink":"/tags/Desktop/"}]},{"title":"pip的使用技巧","slug":"pip的使用技巧","date":"2019-01-12T06:57:20.000Z","updated":"2019-01-12T08:08:22.305Z","comments":true,"path":"2019/01/12/pip的使用技巧/","link":"","permalink":"/2019/01/12/pip的使用技巧/","excerpt":"","text":"如何使用pip安装特定版本的python第三方包python的包管理器pip特别好用，我们可以使用它来方便的安装第三方包，但是怎样使用pip来安装特定版本的第三方包呢？ 安装好python后，包管理器pip就已经安装好了，在终端中输入pip就可以查阅到pip一些常用用法，如： 12pip install package#这里package即为第三方包的名称，如tensorflow，使用这种安装方式会安装最新版本的包 12pip uninstall package#卸载包 12pip list#列举出当前环境安装的所有包 12pip show package#显示所安装包的信息 12pip install package==version#package：包名；version：版本号。如pip install tensorflow-gpu==1.12.0即是安装1.12.0版本的gpu版本的tensorflow 多版本Python共存时pip给指定版本的python安装package的方法在linux安装了多版本python时（例如python2.7和3.4），pip安装的包不一定是用户想要的位置，此时可以用 -t 选项来指定位置 查看pip指向123pip -V# 输出：pip 9.0.1 from /usr/lib/python2.7/site-packages/pip-9.0.1-py2.7.egg (python 2.7)# 发现指向python 2.7 所以我们的问题变成了怎么通过pip去指定安装到Python3.4下 解决方案 更改pip3指向（推荐） 这种方法可以一劳永逸地让之后的pip3安装都顺利一点 1234567891011121314151617181920212223242526272829303132331.查看pip在哪which pip# 输出：/usr/bin/pip2.查看python在哪which python# 输出：/usr/bin/python3.查看python3在哪which python3# 输出：/usr/local/bin/python34.编辑pip所在文件vim /usr/bin/pip# 我们可以看到如下：-----------------------------pip--------------------------------#!/usr/bin/python# EASY-INSTALL-ENTRY-SCRIPT: 'pip==9.0.1','console_scripts','pip'__requires__ = 'pip==9.0.1'import reimport sysfrom pkg_resources import load_entry_pointif __name__ == '__main__': sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0]) sys.exit( load_entry_point('pip==9.0.1', 'console_scripts', 'pip')() )-----------------------------pip-end----------------------------将第一行 #!/usr/bin/python 修改为#!/usr/local/bin/python3然后pip就指向python2了 强制安装到Python3.4环境下 1python3 -m pip install tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl 这样就可以指定安装到python3下了，不过用这种方法的话每次要安装都得这么做，不过因为我是在别人服务器上做，不好随便更改，因此采用这种方式。 用 -t 选项来指定安装位置 例如目标位置是/usr/local/lib/python3.4/site-packages/ ，要安装tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl这个包，则： 1pip install -t /usr/local/lib/python3.4/site-packages/ tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl 这一种方式安装一般会报Command &quot;python setup.py egg_info&quot; failed with error code 1这个错 。解决方案（经验）： 12python -m pip install --upgrade --force pip pip install setuptools==33.1.1","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"pip","slug":"pip","permalink":"/tags/pip/"}]},{"title":"Hibernate中更新非空域","slug":"Hibernate中更新非空域","date":"2019-01-10T01:27:16.000Z","updated":"2019-01-10T08:14:58.225Z","comments":true,"path":"2019/01/10/Hibernate中更新非空域/","link":"","permalink":"/2019/01/10/Hibernate中更新非空域/","excerpt":"","text":"Hibernate中更新非空域；传入一个对象，这个对象中有的域可能是null，但是我并不想覆盖原来的数据库中的有值的域。 我的实现方法： 12345678910111213141516171819202122232425262728public class BeanUtil &#123; /** * 复制src对象的非空属性值到target中 * @param src * @param target */ public static void copyNonNullProperties(Object src, Object target) &#123; BeanUtils.copyProperties(src, target, getNullPropertyNames(src)); &#125; /** * 获取对象中属性为空的属性 * @param source * @return */ public static String[] getNullPropertyNames (Object source) &#123; final BeanWrapper src = new BeanWrapperImpl(source); PropertyDescriptor[] pds = src.getPropertyDescriptors(); Set&lt;String&gt; emptyNames = new HashSet&lt;&gt;(); for(PropertyDescriptor pd : pds) &#123; Object srcValue = src.getPropertyValue(pd.getName()); if (srcValue == null) emptyNames.add(pd.getName()); &#125; String[] result = new String[emptyNames.size()]; return emptyNames.toArray(result); &#125;&#125; 如何调用： 123456实体类1：src （前端传来的数据）实体类1：existing （通过前端传来数据的id获取得到数据库表里的数据）//用src中不为空的属性替换existing中对应的属性copyNonNullProperties(src,existing);//调用hibernate的关系更新方法iModelConfigDAO.update(existing); iModelConfigDAO的实现类说明： 123456789101112public class ModelConfigDAOImpl implements IModelConfigDAO&#123; @Resource private SessionFactory sessionFactory; private Session getSession() &#123; return sessionFactory.getCurrentSession(); &#125; public void update(ModelConfig modelConfig) &#123; this.getSession().update(modelConfig); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"/tags/Hibernate/"}]},{"title":"ubuntu 18.04.1 开机启动脚本","slug":"ubuntu-18-04-1-开机启动脚本","date":"2019-01-07T08:18:31.000Z","updated":"2019-01-10T08:07:21.243Z","comments":true,"path":"2019/01/07/ubuntu-18-04-1-开机启动脚本/","link":"","permalink":"/2019/01/07/ubuntu-18-04-1-开机启动脚本/","excerpt":"","text":"ubuntu18.04不再使用initd管理系统，改用systemd。个人觉得systemd很难用，改变太大，跟之前的完全不同 为了像以前一样，在/etc/rc.local中设置开机启动程序，需要以下几步： systemd默认读取/etc/systemd/system下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。一般系统安装完/lib/systemd/system/下会有rc-local.service文件，即我们需要的配置文件。 链接过来： 1ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service 打开脚本内容： 1cat /etc/systemd/system/rc-local.service 1234567891011121314151617181920212223# SPDX-License-Identifier: LGPL-2.1+## This file is part of systemd.## systemd is free software; you can redistribute it and/or modify it# under the terms of the GNU Lesser General Public License as published by# the Free Software Foundation; either version 2.1 of the License, or# (at your option) any later version.# This unit gets pulled automatically into multi-user.target by# systemd-rc-local-generator if /etc/rc.local is executable.[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no 一般正常的启动文件主要分成三部分： [Unit] 段: 启动顺序与依赖关系 [Service] 段: 启动行为,如何启动，启动类型[Install] 段: 定义如何安装这个配置文件，即怎样做到开机启动 可以看出，/etc/rc.local 的启动顺序是在网络后面，但是显然它少了 Install 段，也就没有定义如何做到开机启动，所以显然这样配置是无效的。 因此我们就需要在后面帮他加上 [Install] 段: 123[Install] WantedBy=multi-user.target Alias=rc-local.service 这里需要注意一下，ubuntu-18.04 默认是没有 /etc/rc.local 这个文件的，需要自己创建 创建/etc/rc.local文件（有的话不用再创建了） 1touch /etc/rc.local 赋可执行权限 1chmod 755 /etc/rc.local 编辑rc.local，添加需要开机启动的任务 123456789101112131415#!/bin/sh -e# # rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will \"exit 0\" on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.echo \"this is a test\" &gt; /usr/local/text.logsudo vncserverexit 0 其中sudo vncserver就是需要开机启动的任务（注意：sudo写上有益无害，避免不必要的麻烦） echo &quot;this is a test&quot; &gt; /usr/local/text.log是测试开机脚本是否生效用的 执行reboot重启系统（查看 /usr/local/text.log 文件是否存在就知道开机脚本是否生效了）","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"开机启动","slug":"开机启动","permalink":"/tags/开机启动/"}]},{"title":"文件打包-解压-下载","slug":"文件打包-解压-下载","date":"2018-12-28T03:07:17.000Z","updated":"2018-12-29T03:17:03.749Z","comments":true,"path":"2018/12/28/文件打包-解压-下载/","link":"","permalink":"/2018/12/28/文件打包-解压-下载/","excerpt":"","text":"文件打包123456789101112131415161718192021222324252627282930313233/** * 文件打包 * 将传递过来的文件列表写入zip文件 * @param fileList 要打包的文件 * @param zipFileName 打包后的文件名 * @throws IOException */public static void downZipManyFile(List&lt;File&gt; fileList, String zipFileName) throws IOException &#123; BufferedInputStream br = null;//输入流 ZipOutputStream out = null; // 压缩文件输出流 ZipEntry zip = null; //用于表示 ZIP 文件条目。 int size =-1; byte[] buffer = new byte[2048];// 定义缓冲区 if(fileList.size()&gt;0)&#123; out = new ZipOutputStream(new FileOutputStream(zipFileName)); for (int i = 0; i &lt; fileList.size(); i++) &#123; File f =fileList.get(i); zip = new ZipEntry(f.getName()); out.putNextEntry(zip); br = new BufferedInputStream(new FileInputStream(f)); while((size=br.read(buffer))!=-1)&#123; out.write(buffer,0,size); out.flush(); &#125; &#125; zip.clone(); br.close(); out.close(); &#125;&#125; 多种压缩文件解压包含实现对.zip、.rar、.7z、.tar、.tar.gz的解压 Maven 1234567891011121314151617181920&lt;!-- .7z --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding-all-platforms&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .7z end --&gt; &lt;!-- .tar/.tar.gz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.10.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .tar/.tar.gz end --&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337/*功能：多种格式压缩文件解压(.zip、.rar、.7z、.tar、.tar.gz)*///使用gbk编码避免zip解压中文文件名乱码private static final String CHINESE_CHARSET = \"gbk\";//文件读取缓冲区大小private static final int CACHE_SIZE = 1024;//系统类型private static final String WINDOWS=\"windows\";private static final String LINUX=\"linux\";/** * 多种格式压缩文件解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void deCompress(String srcFileName, String destDir)&#123; //存储路径不存在则创建 File dFile=new File(destDir); if (!dFile.exists()) &#123; dFile.mkdirs(); &#125; if (srcFileName.toLowerCase().endsWith(\".zip\")) &#123; unZip(srcFileName, destDir); &#125; else if (srcFileName.toLowerCase().endsWith(\".rar\")) &#123; unRar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".7z\")) &#123; un7Z(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar\")) &#123; unTar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar.gz\")) &#123; unTarGz(srcFileName, destDir); &#125;&#125;/** * .zip格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unZip(String srcFileName, String destDir) &#123; try &#123; //解决中文乱码 ZipFile zip = new ZipFile(srcFileName, Charset.forName(CHINESE_CHARSET)); //循环遍历 for (Enumeration&lt;? extends ZipEntry&gt; entries = zip.entries(); entries.hasMoreElements();) &#123; ZipEntry entry = entries.nextElement(); String zipEntryName = entry.getName(); InputStream in = zip.getInputStream(entry); String outPath = (destDir +\"/\"+ zipEntryName).replaceAll(\"\\\\*\", \"/\"); // 判断路径是否存在,不存在则创建文件路径 File file = new File(outPath.substring(0, outPath.lastIndexOf('/'))); if (!file.exists()) &#123; file.mkdirs(); &#125; // 判断文件全路径是否为文件夹,如果是上面已经上传,不需要解压 if (new File(outPath).isDirectory()) &#123; continue; &#125; FileOutputStream out = new FileOutputStream(outPath); byte[] buf = new byte[CACHE_SIZE]; int len; while ((len = in.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; in.close(); out.close(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;/** * .rar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unRar(String srcFileName, String destDir)&#123; String cmd = null; String unRarCmd = null; try &#123; if (systemType().equals(WINDOWS)) &#123; //解压模板命令 unRarCmd = \"F:\\\\Program Files (x86)\\\\WinRAR\\\\WinRAR.exe x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; else if (systemType().equals(LINUX)) &#123; //解压模板命令 unRarCmd = \"unrar x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; //构造运行对象 Runtime rt = Runtime.getRuntime(); //在单独的进程中执行指定的字符串命令。 rt.exec(cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * .7z格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void un7Z(String srcFileName, String destDir)&#123; RandomAccessFile randomAccessFile = null; IInArchive inArchive = null; try &#123; randomAccessFile = new RandomAccessFile(srcFileName, \"r\"); inArchive = SevenZip. openInArchive(null,new RandomAccessFileInStream(randomAccessFile)); ISimpleInArchive simpleInArchive = inArchive.getSimpleInterface(); //遍历 for (ISimpleInArchiveItem item : simpleInArchive.getArchiveItems()) &#123; int[] hash = new int[] &#123; 0 &#125;; if (!item.isFolder()) &#123; ExtractOperationResult result; long[] sizeArray = new long[1]; //tarFile是遍历的每一个文件 File tarFile=new File(destDir+File.separator+item.getPath()); //tarFile父目录不存在，则创建 if (!tarFile.getParentFile().exists()) &#123; tarFile.getParentFile().mkdirs(); &#125; //创建tarFile文件 tarFile.createNewFile(); result = item.extractSlow(new ISequentialOutStream() &#123; public int write(byte[] data) throws SevenZipException &#123; FileOutputStream fos=null; try &#123; fos = new FileOutputStream(tarFile.getAbsolutePath()); //将数据写入fos fos.write(data); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; hash[0] ^= Arrays.hashCode(data); sizeArray[0] += data.length; return data.length; &#125; &#125;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; finally &#123; if (inArchive != null) &#123; try &#123; inArchive.close(); &#125; catch (SevenZipException e) &#123; e.printStackTrace(); &#125; &#125; if (randomAccessFile != null) &#123; try &#123; randomAccessFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * .tar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTar(String srcFileName, String destDir)&#123; FileInputStream fis = null; OutputStream fos = null; TarInputStream tarInputStream = null; try &#123; fis = new FileInputStream(new File(srcFileName)); tarInputStream = new TarInputStream(fis, CACHE_SIZE); TarEntry entry = null; while(true)&#123; entry = tarInputStream.getNextEntry(); if( entry == null)&#123; break; &#125; if(entry.isDirectory())&#123; System.out.println(entry.getName()); createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; fos = new FileOutputStream(new File(destDir + File.separator + entry.getName())); int count; byte data[] = new byte[CACHE_SIZE]; while ((count = tarInputStream.read(data)) != -1) &#123; fos.write(data, 0, count); &#125; fos.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fis != null)&#123; fis.close(); &#125; if(fos != null)&#123; fos.close(); &#125; if(tarInputStream != null)&#123; tarInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * .tar.gz解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTarGz(String srcFileName, String destDir)&#123; FileInputStream fileInputStream = null; BufferedInputStream bufferedInputStream = null; GZIPInputStream gzipIn = null; TarInputStream tarIn = null; OutputStream out = null; try &#123; fileInputStream = new FileInputStream(new File(srcFileName)); bufferedInputStream = new BufferedInputStream(fileInputStream); gzipIn = new GZIPInputStream(bufferedInputStream); tarIn = new TarInputStream(gzipIn, CACHE_SIZE); TarEntry entry = null; while((entry = tarIn.getNextEntry()) != null)&#123; if(entry.isDirectory())&#123; // 是目录 createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; // 是文件 File tempFIle = new File(destDir + File.separator + entry.getName()); createDirectory(tempFIle.getParent() + File.separator, null); out = new FileOutputStream(tempFIle); int len =0; byte[] b = new byte[CACHE_SIZE]; while ((len = tarIn.read(b)) != -1)&#123; out.write(b, 0, len); &#125; out.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(out != null)&#123; out.close(); &#125; if(tarIn != null)&#123; tarIn.close(); &#125; if(gzipIn != null)&#123; gzipIn.close(); &#125; if(bufferedInputStream != null)&#123; bufferedInputStream.close(); &#125; if(fileInputStream != null)&#123; fileInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * 构建目录 * @param outputDir 输出目录 * @param subDir 子目录 */private static void createDirectory(String outputDir, String subDir)&#123; File file = new File(outputDir); if(!(subDir == null || subDir.trim().equals(\"\"))) &#123;//子目录不为空 file = new File(outputDir + File.separator + subDir); &#125; if(!file.exists())&#123; if(!file.getParentFile().exists())&#123; file.getParentFile().mkdirs(); &#125; file.mkdirs(); &#125;&#125;/** * 判断程序运行在什么系统上 * @return 系统类型 */public static String systemType() &#123; Properties properties = System.getProperties(); String os = properties.getProperty(\"os.name\"); if (os != null &amp;&amp; os.toLowerCase().contains(WINDOWS))&#123; return WINDOWS; &#125;else if (os != null &amp;&amp; os.toLowerCase().contains(LINUX))&#123; return LINUX; &#125; return null;&#125;public static void main(String[] args) &#123; //deCompress(\"E:/Test/Test01.zip\",\"E:/Test/testZip\"); //deCompress(\"E:/Test/Test02.rar\",\"E:/Test/testRar\"); //deCompress(\"E:/Test/Test03.7z\",\"E:/Test/test7z\"); //deCompress(\"E:/Test/Test04.tar\",\"E:/Test/testTar\"); //deCompress(\"E:/Test/apache-tomcat-9.0.13-src.tar.gz\",\"E:/Test/testTarGz\");&#125; 从服务器下载文件123456789101112131415161718192021222324252627282930313233343536/** * 文件下载 * @param zipFileName zip文件全路径（含文件名） * @param response * @param isDelete 是否将生成的服务器端文件删除 * @return */public ReturnT&lt;?&gt; downloadFile(String zipFileName, HttpServletResponse response, boolean isDelete) &#123; try &#123; File file=new File(zipFileName); // 以流的形式下载文件。 BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file.getPath())); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); response.setContentType(\"application/octet-stream\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + new String(file.getName().getBytes(\"UTF-8\"),\"ISO-8859-1\")); toClient.write(buffer); toClient.flush(); toClient.close(); if(isDelete) &#123; //将生成的服务器端文件删除 file.delete(); &#125; return new ReturnT(HttpStatus.OK, \"下载成功\", null); &#125; catch (Exception e) &#123; logger.error(\"下载失败\",e); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125;&#125; 其它文件操作获取单个文件的所有内容123456789101112131415161718192021222324/** * 获取单个文件的所有内容 * @param fileName 文件全路径 * @return */public static String readToString(String fileName) &#123; try &#123; File file = new File(fileName); Long filelength = file.length(); byte[] filecontent = new byte[filelength.intValue()]; FileInputStream in = new FileInputStream(file); in.read(filecontent); in.close(); return new String(filecontent, encoding); &#125; catch (FileNotFoundException e) &#123; logger.error(\"该文件不存在或路径错误\",e); e.printStackTrace(); return null; &#125; catch (IOException e) &#123; logger.error(\"读取文件出错\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的文件名列表(全路径)123456789101112131415161718192021222324252627282930/** * 获取多个文件文件列表(全路径) * @param fileDir 文件夹路径 * @param picturePath 图片相对路径 * @param request * @return 返回带域名的文件路径 */public static List&lt;String&gt; readToListPath(String fileDir, String picturePath, HttpServletRequest request) &#123; //获取带部署环境上下文的域名 StringBuffer url = request.getRequestURL(); String tempContextUrl = url .delete(url.length() - request.getRequestURI().length(), url.length()) .append(request.getContextPath()).toString(); List&lt;String&gt; fileNameList = new ArrayList&lt;&gt;(); try &#123; List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); if (fileList.size()==0)&#123; return fileNameList; &#125; for (File f1 : fileList) &#123; fileNameList.add(tempContextUrl+picturePath+\"/\"+f1.getName()); &#125; return fileNameList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件文件列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的内容列表123456789101112131415161718192021/** * 获取多个文件内容列表 * @param fileDir 文件所在路径 * @return */public static List&lt;String&gt; readToListAndString(String fileDir)&#123; try &#123; List&lt;String&gt; fileContentList = new ArrayList&lt;&gt;(); List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); for (File file : fileList)&#123; if(!readToString(file.toString()).equals(\"\"))&#123; fileContentList.add(readToString(file.toString())); &#125; &#125; return fileContentList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件内容列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 递归获取目录下的所有文件123456789101112131415161718192021222324252627282930/** * 递归获取目录下的所有文件 * @param fileDir 文件所在路径 * @return */public static List&lt;File&gt; getFilePath(String fileDir,String endsWith)&#123; List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); File file = new File(fileDir); File[] files = file.listFiles();// 获取目录下的所有文件或文件夹 if (files == null) &#123;// 如果目录为空，返回空 return null; &#125; // 遍历，目录下的所有文件 for (File f : files) &#123; if (f.isFile()) &#123; if(endsWith.equals(\"\")||endsWith==null)&#123; fileList.add(f); &#125;else &#123; if (f.getName().endsWith(endsWith))&#123; fileList.add(f); &#125; &#125; &#125; else if (f.isDirectory()) &#123; getFilePath(f.getAbsolutePath(),endsWith); &#125; &#125; return fileList;&#125; 递归删除文件（删除文件夹）12345678910111213141516171819/** * 递归删除目录下的所有文件及子目录下所有文件 * @param dir 目录路径 * @return */public static boolean deleteDir(File dir) &#123; if (dir.isDirectory()) &#123; String[] children = dir.list(); //递归删除目录中的子目录下 for (int i=0; i&lt;children.length; i++) &#123; boolean success = deleteDir(new File(dir, children[i])); if (!success) &#123; return false; &#125; &#125; &#125; // 目录此时为空或者是文件，可以删除 return dir.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"文件打包","slug":"文件打包","permalink":"/tags/文件打包/"},{"name":"压缩文件解压","slug":"压缩文件解压","permalink":"/tags/压缩文件解压/"}]},{"title":"linux环境下安装 openOffice 并启动服务","slug":"linux环境下安装-openOffice-并启动服务","date":"2018-12-25T02:07:07.000Z","updated":"2019-01-10T08:06:15.269Z","comments":true,"path":"2018/12/25/linux环境下安装-openOffice-并启动服务/","link":"","permalink":"/2018/12/25/linux环境下安装-openOffice-并启动服务/","excerpt":"","text":"背景故事这两天遇到一个大坑，客户要做office 文档在线预览功能，于是乎就要把office文档转换成pdf交给前端显示。 在某度找了一圈都说openOffice+jodconverter 可以搞定这个事情。代码倒是很好找，不过版本很多，各类jar包也很多，但尝试下来发现，转化效果很一般，复杂的excel也无法成功。有同事建议放到服务器上效果可能好些，于是就开始折腾在服务器上安装OpenOffice这个事情。网上各种找大神的博文，发现安装起来不是很顺畅，就写了这篇随笔，记录一下，遇到的问题，方便自己以后查看。 ​ openOffice转转word文档效果不错，转Excel的话就真的效果不行，简单的Excel能处理处理，复杂的就很慢很慢，而且效果极差。再说，实际上微软自己的office软件转pdf的效果也很差。 操作步骤 http://www.openoffice.org/zh-cn/download/ 去官网链接下载linux版本的openOffice 以4.1.6 版本为例。 将压缩包上传至服务器上，并进行解压安装。 12345tar -zxvf 对应的压缩包名字cd 进入解压后的 /zh-cn/RPMSyum localinstall *.rpmcd desktop-integrationrpm -ivh openoffice4.1.6-redhat-menus-4.1.6-9789.noarch.rpm 默认会安装在/opt目录下。 启动服务 123/opt/openoffice4/program/soffice -headless -accept=\"socket,host=127.0.0.1,port=8100;urp;\" -nofirststartwizard 临时启动nohup /opt/openoffice4/program/soffice -headless -accept=\"socket,host=127.0.0.1,port=8100;urp;\" -nofirststartwizard &amp; 后台启动 端口号根据自己项目实际来确定。 后台启动会一直占用内存，据各路大神说 大概100M，我自己没测过具体值不清楚。 有的程序是需要预先启动openOffice 服务的，有的则在代码里自己启动服务。 .查看进程 1netstat -lnp |grep 端口号 大概显示成这样就算启动完了。 1tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 14362/soffice.bin 问题装完openoffice后启动服务可能会报错：no suitable windowing system found, exiting 从字面上的意思就是缺少一个窗口化的系统。所以就安装一个。 1yum groupinstall \"X Window System\"","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"openOffice","slug":"openOffice","permalink":"/tags/openOffice/"},{"name":"安装","slug":"安装","permalink":"/tags/安装/"}]},{"title":"将Word(.doc)里的图片替换成文本","slug":"将Word-doc-里的图片替换成文本","date":"2018-12-20T03:23:24.000Z","updated":"2018-12-29T03:04:42.141Z","comments":true,"path":"2018/12/20/将Word-doc-里的图片替换成文本/","link":"","permalink":"/2018/12/20/将Word-doc-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖1234567891011121314151617181920212223242526&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt;&lt;!-- Jsoup-用以解析HTML --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Jsoup-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195public static void main(String argv[]) &#123; try &#123; //源文件全路径 String oldFileName = \"D:/Test/ml/test.doc\"; //目标文件全路径 String newFileName = \"D:/Test/ml/html_to_word.doc\"; //构造HTML生成全路径 String temporary = new File(oldFileName).getParent()+File.separator+\"temporary.html\"; //读取DOC生成获得html内容和图片集 Map&lt;String,Object&gt; map = convert2Html(oldFileName); //取得图片集 List&lt;String&gt; listPics = (List&lt;String&gt;) map.get(\"listPics\"); //取得生成的html内容 String htmlContent = (String) map.get(\"htmlContent\"); for (String pic : listPics)&#123; //有后缀名的图片才进行识别 if (pic.lastIndexOf(\".\") != -1)&#123; //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //文字替换图片 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;\"); &#125;else &#123;/*因为识别出来的非图片格式（即：无后缀名）的图片再放回doc时会出现 图片异常显示，所以以\"&lt;span&gt;&lt;/span&gt;\"进行占位*/ //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //占位 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&lt;/span&gt;\"); &#125; &#125; //输出HTML文件 writeFile(htmlContent, temporary); //HTML转Doc html2Doc(temporary,newFileName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 输出HTML文件 * @param content 从doc读取生成的html文本 * @param path 目标文件全路径 */public static void writeFile(String content, String path) &#123; FileOutputStream fos = null; BufferedWriter bw = null; org.jsoup.nodes.Document doc = Jsoup.parse(content); String styleOld=doc.getElementsByTag(\"style\").html(); //统一字体格式为宋体 styleOld=styleOld.replaceAll(\"font-family:.+(?=;\\\\b)\", \"font-family:SimSun\"); doc.getElementsByTag(\"head\").empty(); doc.getElementsByTag(\"head\") .append(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); doc.getElementsByTag(\"head\") .append(\" &lt;style type=\\\"text/css\\\"&gt;&lt;/style&gt;\"); doc.getElementsByTag(\"style\") .append(styleOld); /*正则表达式查询字体内容：font-family:.+(?=;\\b)*/ content=doc.html(); content=content .replace(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;\", \"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); try &#123; File file = new File(path); fos = new FileOutputStream(file); bw = new BufferedWriter(new OutputStreamWriter(fos,\"UTF-8\")); bw.write(content); &#125; catch (FileNotFoundException fnfe) &#123; fnfe.printStackTrace(); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; finally &#123; try &#123; if (bw != null) bw.close(); if (fos != null) fos.close(); &#125; catch (IOException ie) &#123; &#125; &#125;&#125;/** * 读取DOC生成获得html内容和图片集 * @param fileName 源文件全路径 * @return 返回的map中包含html内容和图片集 * @throws Exception */public static Map&lt;String,Object&gt; convert2Html(String fileName) throws Exception &#123; //存放html内容和图片集 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //保存图片集 List&lt;String&gt; listPics = new ArrayList&lt;&gt;(); //构造提取出来的图片保存路径以及HTML中&lt;img&gt;的图片源路径 String imgPath = new File(fileName).getParent()+ File.separator+\"img\"+File.separator; File file = new File(imgPath); //不存在，则创建 if (!file.exists())&#123; file.mkdirs(); &#125; HWPFDocument wordDocument = new HWPFDocument(new FileInputStream(fileName)); //WordToHtmlUtils.loadDoc(new FileInputStream(inputFile)); WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter( DocumentBuilderFactory.newInstance().newDocumentBuilder() .newDocument()); wordToHtmlConverter.setPicturesManager( new PicturesManager() &#123; public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches ) &#123; return imgPath.replace(\"\\\\\",\"/\") + suggestedName; &#125; &#125; ); wordToHtmlConverter.processDocument(wordDocument); //保存图片 List pics=wordDocument.getPicturesTable().getAllPictures(); if(pics!=null)&#123; for(int i=0;i&lt;pics.size();i++)&#123; Picture pic = (Picture)pics.get(i); try &#123; String picAbsolutePath = imgPath + pic.suggestFullFileName(); //将图片全路径存入listPics listPics.add(picAbsolutePath); pic.writeImageContent(new FileOutputStream(picAbsolutePath)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Document htmlDocument = wordToHtmlConverter.getDocument(); ByteArrayOutputStream out = new ByteArrayOutputStream(); DOMSource domSource = new DOMSource(htmlDocument); StreamResult streamResult = new StreamResult(out); TransformerFactory tf = TransformerFactory.newInstance(); Transformer serializer = tf.newTransformer(); serializer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); serializer.setOutputProperty(OutputKeys.INDENT, \"yes\"); serializer.setOutputProperty(OutputKeys.METHOD, \"HTML\"); serializer.transform(domSource, streamResult); out.close(); String htmlContent=new String(out.toByteArray()); //替换UEditor无法识别的转义字符 htmlContent=htmlContent.replaceAll(\"&amp;ldquo;\",\"\\\"\").replaceAll(\"&amp;rdquo;\",\"\\\"\") .replaceAll(\"&amp;mdash;\",\"-\"); map.put(\"htmlContent\",htmlContent); map.put(\"listPics\",listPics); return map;&#125;/** * html转doc * @param source * @param target * @throws Exception */public static void html2Doc(String source , String target) throws Exception &#123; //创建 POIFSFileSystem 对象 POIFSFileSystem poifs = new POIFSFileSystem(); //获取DirectoryEntry DirectoryEntry directory = poifs.getRoot(); //创建输出流 OutputStream out = new FileOutputStream(target); try &#123; //创建文档,1.格式\"WordDocument\",2.HTML文件输入流 directory.createDocument(\"WordDocument\", new FileInputStream(source)); //写入 poifs.writeFilesystem(out); //释放资源 out.close(); System.out.println(\"success\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"},{"name":"Jsoup","slug":"Jsoup","permalink":"/tags/Jsoup/"}]},{"title":"OpenOffice-实现文件格式之间的转换.md","slug":"OpenOffice-实现文件格式之间的转换","date":"2018-12-18T11:10:47.000Z","updated":"2018-12-18T12:50:46.786Z","comments":true,"path":"2018/12/18/OpenOffice-实现文件格式之间的转换/","link":"","permalink":"/2018/12/18/OpenOffice-实现文件格式之间的转换/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iTextPDF-实现向PDF追加内容","slug":"iTextPDF-实现向PDF追加内容","date":"2018-12-18T11:10:03.000Z","updated":"2018-12-18T12:49:51.129Z","comments":true,"path":"2018/12/18/iTextPDF-实现向PDF追加内容/","link":"","permalink":"/2018/12/18/iTextPDF-实现向PDF追加内容/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"将Word(.docx)-里的图片替换成文本","slug":"将Word-docx-里的图片替换成文本","date":"2018-12-18T11:08:31.000Z","updated":"2018-12-25T03:01:54.817Z","comments":true,"path":"2018/12/18/将Word-docx-里的图片替换成文本/","link":"","permalink":"/2018/12/18/将Word-docx-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖12345678910111213141516171819&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public static void main(String[] args) throws Exception &#123; textReplacePhoto(\"D:\\\\Test\\\\原报格式样例3.docx\", \"D:\\\\Test\\\\原报格式样例3-1.docx\",\"D:/Test/img\");&#125;/** * 将word里的图片全部替换成文本 * @param oldFileName 传入原文件的全路径（含文件名） * @param newFileName 保存修改后文件的全路径（含文件名） * @param picturePath 读取出来的图片保存路径 * @throws Exception */public static void textReplacePhoto(String oldFileName, String newFileName, String picturePath) throws Exception &#123; File newFile = new File(newFileName.replace(new File(newFileName).getName(),\"\")); //保存路径不存在，则创建 if (!newFile.exists())&#123; newFile.mkdirs(); &#125; if (oldFileName.endsWith(\".docx\"))&#123; //.docx文件的处理方法 //为了确定图片集中的某一张图片 int imgNum=0; //创建输入流 InputStream oldIs = new FileInputStream(oldFileName); //创建输出流 OutputStream newOs = new FileOutputStream(newFileName); //创建一个XWPFDocument XWPFDocument docx = new XWPFDocument(oldIs); //获取到该文档的所有段落集 List&lt;XWPFParagraph&gt; paras = docx.getParagraphs(); //获取到该文档的所有图片集 List&lt;XWPFPictureData&gt; pictures = docx.getAllPictures(); for (XWPFParagraph para:paras)&#123; //段落中所有XWPFRun List&lt;XWPFRun&gt; runList = para.getRuns(); for (int i=0;i&lt;runList.size();i++) &#123; XWPFRun run=runList.get(i); //判断该段落是否是图片 if (!run.getEmbeddedPictures().isEmpty())&#123; //存储读取到的图片,并获取图片全路径 String pictureName=savePictureDocx(pictures,picturePath,imgNum++); //实际有图片才进行以下操作 if (pictureName!=null)&#123; //删除图片 para.removeRun(i); //插入文字 para.insertNewRun(i).setText(\"&#123;&#123;title&#125;&#125;\"); //删除图片 deletePicture(pictureName); &#125; &#125; &#125; &#125; docx.write(newOs); docx.close(); oldIs.close(); newOs.flush(); newOs.close(); &#125;&#125;/** * 存储读取到的图片 - docx * @param pictures 图片集 * @param picturePath 图片保存路径 * @param imgNum 确定图片集中的某一张图片 * @return 图片全路径 * @throws IOException */public static String savePictureDocx(List&lt;XWPFPictureData&gt; pictures, String picturePath,int imgNum) throws IOException &#123; File pictureFile = new File(picturePath); //保存路径不存在，则创建 if (!pictureFile.exists())&#123; pictureFile.mkdirs(); &#125; List&lt;XWPFPictureData&gt; pictures = para.getDocument().getAllPictures(); if (pictures.size()!=0)&#123; XWPFPictureData picture = pictures.get(imgNum); String rawName = picture.getFileName(); String fileExt = rawName.substring(rawName.lastIndexOf(\".\")); String newName = System.currentTimeMillis() + UUID.randomUUID().toString() + fileExt; String pictureName = picturePath + File.separator + newName; FileOutputStream fos = new FileOutputStream(pictureName); fos.write(picture.getData()); fos.flush(); fos.close(); return pictureName; &#125; return null;&#125;/** * 删除临时存储的图片 * @param pictureName 图片全路径（含文件名） * @return */public static boolean deletePicture(String pictureName) &#123; File pictureFile = new File(pictureName); // 目录此时为空，可以删除 return pictureFile.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"}]},{"title":"用VNC搭建Ubuntu VNC可视化界面","slug":"用VNC搭建Ubuntu VNC可视化界面","date":"2018-12-10T11:48:46.000Z","updated":"2019-01-10T08:08:55.307Z","comments":true,"path":"2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","link":"","permalink":"/2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","excerpt":"","text":"安装配置软件 VNC的安装与配置安装之前先输入（获取最新套件的信息） 1apt-get update 输入以下命令安装VNC，安装过程中需要输入Y来确认 1apt-get install vnc4server 启动VNC（第一次启动需要设置密码） 1vncserver 开机启动请参考：ubuntu-18-04-1-开机启动脚本 设置vncservgnome 桌面环境安装与配置（可直接跳至第3步）安装x－windows的基础 1sudo apt-get install x-window-system-core 安装登录管理器 1sudo apt-get install gdm 安装Ubuntu的桌面 1sudo apt-get install ubuntu-desktop 安装gnome配套软件 1sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal 修改VNC配置文件 1sudo vi ~/.vnc/xstartup 修改为： 1234567891011#!/bin/sh# Uncomment the following two lines for normal desktop:export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrcunset DBUS_SESSION_BUS_ADDRESSgnome-panel &amp;gnmoe-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp; 杀掉原桌面进程，输入命令（其中的:1是桌面号）： 1vncserver -kill :1 输入以下命令生成新的会话： 1vncserver :1 ubuntu卸载gnome桌面（可直接跳至第3步） 之前安装好了ubuntu18.04，本来想装个gnome shell来美化一下桌面，结果出现了开机黑屏（灰屏）的现象，经网上查询发现是显卡驱动在gnome3的环境下产生了不兼容，具体解决方法我还没找到，情急之下只能先卸载掉gnome桌面环境。 卸载掉gnome-shell主程序1sudo apt-get remove gnome-shell 卸载掉gnome1sudo apt-get remove gnome 卸载不需要的依赖关系1sudo apt-get autoremove 彻底卸载删除gnome的相关配置文件1sudo apt-get purge gnome 清理安装gnome时候留下的缓存程序软件包12sudo apt-get autocleansudo apt-get clean ubuntu运行VNC Server无桌面时的解决方案配置vnc server实在是一个特别诡异的事，我在不同的ubuntu机器上配置服务时，总是遇到千奇百怪的问题，大部分情况下比较顺利，将~/.vnc/xstartup最后一句x-window-manager&amp;替换为gnome-session&amp;就能顺利地出现桌面，而有些则不行，需要改为gnome-session --session=ubuntu-2d&amp; 问题而今天遇到的ubuntu 18.04，则死活不行，用realvnc viewer连接之后，只有灰灰的一个背景，没有桌面，没有terminal。 查阅了很多博文，有说需要安装gnome-session-fallback的，有说需要安装gdm的，也有用kde的，除了kde我没有尝试，另外两种验证无效，依然只有一个灰色背景。 最后用xfce4桌面解决，选择些方案一是因为xfce相对较小，gnome-session死活不行的情况下，再将一个kde未免太过兴师动众，xfce我使用过一段时间，是一个相当轻量级的GUI环境，清爽易用，功能一点不含糊。决定之后，一次尝试即成功。 安装xfce1sudo apt-get install gnome-core xfce4 配置编辑~/.vnc/xstartup文件： 12345678#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp; 输入以下命令生成新的会话： 1vncserver :1 本地使用VNC连接 本地安装VNC后，使用ip地址:1（其中的:1是桌面号）的方式连接 输入之前设置的VNC密码后点击连接 附录 下载地址VNC Viewer和VNC Server","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"VNC","slug":"VNC","permalink":"/tags/VNC/"}]},{"title":"Linux下安装Java JDK8","slug":"Linux下安装Java-JDK8","date":"2018-12-10T11:44:56.000Z","updated":"2019-01-10T08:06:43.445Z","comments":true,"path":"2018/12/10/Linux下安装Java-JDK8/","link":"","permalink":"/2018/12/10/Linux下安装Java-JDK8/","excerpt":"","text":"手动下载压缩包安装oracle Java JDK 前往oracle Java官网下载JDK 解压缩到指定目录（以jdk-8u144-linux-x64.tar.gz为例） 创建目录: 1sudo mkdir /usr/lib/jvm 解压缩到该目录: 1sudo tar -zxvf jdk-7u60-linux-x64.gz -C /usr/lib/jvm 修改环境变量: 1sudo vi ~/.bashrc 在文件末尾追加下面内容： 12345#set oracle jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量马上生效： 1source ~/.bashrc 查看java版本，看看是否安装成功： 1java -version","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"}]},{"title":"Linux的使用技巧","slug":"Linux的使用技巧","date":"2018-12-10T11:21:02.000Z","updated":"2019-01-12T08:08:49.831Z","comments":true,"path":"2018/12/10/Linux的使用技巧/","link":"","permalink":"/2018/12/10/Linux的使用技巧/","excerpt":"","text":"修改用户名例：将admin改为test（ubuntu） 修改 /etc/passwd用户信息文件1vim /etc/passwd 123#admin:x:1001:1001:admin,,,:/home/admin:/bin/bash#把用户名admin改成rest#test:x:1001:1001:admin,,,:/home/test:/bin/bash 注： 12admin:x:1001:1001:admin,,,:/home/admin:/bin/bash中的admin,,,不可修改，若修改后重启，你将会因为密码错误而不能成功登入系统（只得去机房重新注册用户了） 修改 /etc/shadow用户密码文件1vim /etc/shadow 123#admin:Dnakfw28zf38w:8764:0:168:7:::#由于密码加密方式存放，只修改用户名即可（密码不变）#test:Dnakfw28zf38w:8764:0:168:7::: 再修改 /etc/group用户组文件1vim /etc/group 123#admin:x:1:root,bin,admin#修改admin组为test组#test:x:1:root,bin,test 修改用户的家目录1mv /home/admin /home/test xx is not in the sudoers file 问题解决首先利用whereis 命令查找sudoers配置文件的目录（默认会在/etc/sudoers) 1whereis sudoers 然后就可以利用vi编辑器来把用户添加到sudoers之中 1vi /etc/sudoers 然后找到root ALL=(ALL) ALL 或者 root ALL=(ALL:ALL) ALL所在的位置，把所要添加的用户添加到文件之中 下面是添加完的结果。 1234Allow root to run any commands anywhereroot ALL=(ALL) ALLmaliang ALL=(ALL) ALL（这一行是添加的内容，maliang是我的用户名） 修改用户密码在终端运行 1passwd username 123456改变口令为 username。(当前)UNIX 口令：&lt;输入现在的密码&gt; 输入新的 UNIX 口令： &lt;输入新密码&gt; 重新输入新的 UNIX 口令：&lt;重新输入新密码&gt;passwd：已成功更新密码 开启root用户和使用root用户登陆 以普通用户登录系统，创建root用户的密码 1sudo passwd root 修改文件sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf文件，增加两行： 12greeter-show-manual-login=trueallow-guest=false 保存 修改/etc/pam.d/gdm-autologin、/etc/pam.d/gdm-password文件和/root/.profile文件（ubuntu-18.04需要此步骤） 1vi /etc/pam.d/gdm-autologin 注释掉：auth required pam_succeed_if.so user != root quiet_success 保存 1vi /etc/pam.d/gdm-password 注释掉：auth required pam_succeed_if.so user != root quiet_success 保存 1vim /root/.profile 将文件末尾的mesg n || true这一行修改成tty -s &amp;&amp; mesg n || true 保存 重启系统，输入root用户名和密码，登录系统 解决Ubuntu18.04不能用Xshell使用root用户登录 今天使用Xshell6连接Ubuntu18.04时，连接普通用户可以，但是连接root用户不行（但是实体机或者虚拟机可以root用户登录） 解决方案是： 在Ubuntu18.04中 修改 /etc/ssh/sshd_config这个文件： 1vim /etc/ssh/sshd_config 这是没修改前的： 123456789...# Authentication:#LoginGraceTime 2m#PermitRootLogin prohibit-password#StrictModes yes#MaxAuthTries 6#MaxSessions 10... 修改后的： 12345678910...# Authentication:LoginGraceTime 2m#PermitRootLogin prohibit-passwordPermitRootLogin yesStrictModes yes#MaxAuthTries 6#MaxSessions 10... 然后再在终端输入一下命令：/etc/init.d/ssh restart 来重启ssh服务 重新使用root连接，就可以了 找出文件所在的位置1whereis sudoers（你要找的文件名） 查看端口占用并杀死(kill)12# 查看sudo netstat -tlnp|grep 9090 12# 杀死kill -9 31540 如何从Yum库下载rpm包但不安装方法一（推荐） 12# 将一个包（包含所有依赖）下载到一个指定的目录(如/opt/gccmkdir/)：yum install -y gcc --downloadonly --downloaddir=/opt/gccmkdir/ 方法二 12# --resolve 表示为下载依赖yumdownloader lsof --resolve --destdir=/data/mydepot/ 方法三（推荐） 12345# 把/etc/yum.conf配置中的keepcache=0参数修改为keepcache=1# 再yum 下载：yum install -y gcc#默认情况下，RPM包会保存在下面的目录中:/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages apt-get 与 yum安装有啥区别rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 1234yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：安装：yum install &lt;package_name&gt; 卸载：yum remove &lt;package_name&gt; 更新：yum update &lt;package_name&gt; 1234apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理：安装：apt-get install &lt;package_name&gt; 卸载：apt-get remove &lt;package_name&gt; 更新：apt-get update &lt;package_name&gt; 安装rpm包进入系统下存放对应.rpm文件的目录，执行 12cd /opt/gccmkdir/rpm -Uvh *.rpm --nodeps --force 注：rpm -Uvh *.rpm –nodeps –force -Uvh就是升级软件包–Update *.rpm就是所有的.rpm包； –nodeps就是安装时不检查依赖关系，比如你这个rpm需要A，但是你没装A，这样你的包就装不上，用了–nodeps你就能装上了； –force就是强制安装，比如你装过这个rpm的版本1，如果你想装这个rpm的版本2，就需要用–force强制安装。 查看Linux版本方法方法一 123456# lsb_release -aLSB Version: :core-3.1-ia32:core-3.1-noarch:graphics-3.1-ia32:graphics-3.1-noarchDistributor ID: CentOSDescription: CentOS release 5.4 (Final)Release: 5.4Codename: Final 方法二 12# cat /etc/redhat-releaseCentOS release 5.4 (Final) 方法三 12# rpm -q centos-releasecentos-release-5-4.el5.centos.1 linux运行jar包要运行java的项目需要先将项目打包成war包或者jar包，打包成war包需要将war包部署到tomcat服务器上才能运行。而打包成jar包可以直接使用java命令执行。在linux系统中运行jar包主要有以下四种方式。 1java -jar XXX.jar 这是最基本的jar包执行方式，但是当我们用ctrl+c中断或者关闭窗口时，程序也会中断执行。 1java -jar XXX.jar &amp; &amp;代表在后台运行，使用ctrl+c不会中断程序的运行，但是关闭窗口会中断程序的运行。 1nohup java -jar XXX.jar &amp; 使用这种方式运行的程序日志会输出到当前目录下的nohup.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 1nohup java -jar XXX.jar &gt;temp.out &amp; ‘&gt;temp.out’的意思是将日志输出重定向到temp.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 XShell上传、下载本地文件到linux服务器在linux主机上，安装上传下载工具包rz及sz; 如果不知道你要安装包的具体名称，可以使用yum provides */name 进行查找系统自带软件包的信息 123456[root@host ~]# yum provides */rz...lrzsz-0.12.20-36.el7.x86_64 : The lrz and lsz modem communications programsRepo : baseMatched from:Filename : /usr/bin/rz 一般会列出软件包的名称及版本，还有安装路径；查询到软件包名后，使用yum install -y 包名 进行安装。 lrzsz包安装完成后包括上传rz、下载sz命令 1[root@host ~]# yum install -y lrzsz 上传命令为rz；下再命令为sz 12#上传（windows-&gt;linux）文件-弹出窗口选择需要上传的文件[root@host ~]# rz 12#指定下载（linux-&gt;windows）哪个文件-弹出窗口选择需要保存的路径[root@host ~]# sz 文件名称 ubuntu安装ssh服务SSH分客户端openssh-client和openssh-server 如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo apt-get install openssh-client） 如果要使本机开放SSH服务就需要安装openssh-serversudo（apt-get install openssh-server） 1apt-get install openssh-server 有时候当你执行sudo apt-get XXX这种命令时出现类似下面的输出错误： 12E: Could not get lock /var/lib/dpkg/lock - open (11 Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/) is another process using it? 或者 12345E: Could not ge lock /var/lib/apt/lists/lock - open (11: Resource temporarilyunavailable)E: Unable to lock directory /var/lib/apt/lists/ E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解释 出现这个问题的原因是，还有一个线程在使用apt-get进行下载的操作。但是奇怪的是，我就是没有找到其他使用了apt-get指令的终端界面。那么如何解决这个问题呢，难道要重新启动电脑吗，重启电脑是可以解决这个问题，但是我接下来教你的方法，才是真正的解决方法。 解决办法 先搜索所有运行着的线程 1ps -A | grep apt-get 你会得到类似下面的输出： 123root 752 0.0 0.0 4508 1628 ? Ss 01:13 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily_apt 2098 0.1 0.1 49572 5524 ? S 01:18 0:06 /usr/lib/apt/methods/httpaobo 4425 0.0 0.0 18484 980 pts/1 S+ 02:13 0:00 grep --color=auto apt 第2列就是线程号(kill processnumber)。我们将apt相关的进程给关闭掉，需要使用sudo权限： 1sudo kill 2098 输出： bash: kill: (2098) - Operation not permitted 然后确认sshserver是否启动了： 1ps -e |grep ssh 如果看到sshd那说明ssh-server已经启动了 CentOS7中找不到ifconfig和netstat命令把net-tools包装上就好了 1yum install net-tools 用ifconfig或者ip a命令，获取不到IP地址问题描述：用ifconfig或者ip a命令，获取不到ip地址，即网卡未启动，无法用Xshell远程连接。 解决方案： 进入/etc/sysconfig/network-scripts目录，发现有一个或多个ifcfg-...，即网卡（驱动）存在但未启用。 1ls /etc/sysconfig/network-scripts 修改/etc/sysconfig/network-scripts/ifcfg-...文件， 把ONBOOT=no改为ONBOOT=yes保存退出wq 123vi /etc/sysconfig/network-scripts/ifcfg-em1...# 把`ONBOOT=no`改为`ONBOOT=yes`保存退出 service network restart重启。出现： 1Restarting network (via systemctl): [ 确定 ] OK 输入ifconfig或者ip a命令，出现ip地址。用Xshell连接成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"/tags/CentOS/"},{"name":"RedHat","slug":"RedHat","permalink":"/tags/RedHat/"}]}]}