{"meta":{"title":"Nan's Blog","subtitle":"弱者才言命，强者只言运！","description":"克己复礼","author":"马亮南生","url":""},"pages":[{"title":"分类","date":"2018-12-06T11:48:02.000Z","updated":"2018-12-10T08:59:19.994Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-06T11:46:40.000Z","updated":"2018-12-10T08:58:50.994Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CloudStack API编程指南","slug":"CloudStack-API编程指南","date":"2019-07-02T02:09:30.000Z","updated":"2019-07-02T02:26:31.194Z","comments":true,"path":"2019/07/02/CloudStack-API编程指南/","link":"","permalink":"/2019/07/02/CloudStack-API编程指南/","excerpt":"","text":"来源：https://blog.csdn.net/u012124304/article/details/76152234 角色CloudStack API支持三种角色访问： 根域管理员 域管理员 普通用户 提交API请求所有CloudStack API请求都是以HTTP GET/POST的形式提交，一个请求包含下面三部分： API的URL地址：即web服务API的入口地址(如： http://localhost:8080/client/api) 命令：你想要执行的web服务命令，如启动一个虚拟机 参数：该命令所需要的必要或可选参数 一个API请求的例子如下： 1234567891011121314http://localhost:8080/client/api?command=deployVirtualMachine&amp;serviceOfferingId=1&amp;diskOfferingId=1&amp;templateId=2&amp;zoneId=4&amp;apiKey=miVr6X7u6bN_sdahOBpjNejPgEsT35eXqjB8CG20YI3yaxXcgpyuaIRmFI_EJTVwZ0nUkkJbPmY3y2bciKwFQ&amp;signature=Lxx1DM40AjcXU%2FcaiK8RAP0O1hU%3D#第1行就是CloudStack API的URL； ####第2行表示我们想要执行的命令； ###第3-6行是该命令所需的参数，命令和参数的详情具体可以参考API文档； ##第7行是唯一标识用户的账户的API Key； #第8行是用来认证用户账户执行API命令权限的签名的哈希值 API请求的签名不管你是通过HTTP还是HTTPS的方式访问CloudStack API，都必须对请求进行签名从而让CloudStack能确认调用者已经被认证和授权执行该命令。在进行签名之前先确认你拥有API Key和管理员提供给你的账户的私钥。 以上面的API请求为例子，每个API请求都包含以下几个部分： 基本的URL：http://localhost:8080 API的路径：处理请求的API Servlet的路径：/client/api? 命令字符串：包括命令，命令的参数以及标志用户账户的API Key，需要注意的是，参数的键是不区分大小写的，而参数的值是区分大小写的 签名：使用用户的私钥和HMAC SHA-1哈希算法生成的签名 生成签名的步骤： 命令字符串中的每个键值对（以&amp;分隔开），URL对每个值进行编码从而使其能通过HTTP GET安全地发送 将命令字符串的字母全部转换成小写，并且对键值对按字母顺序进行排序，结果类似下面的形式： 123456apikey=mivr6x7u6bn_sdahobpjnejpgest35exq-jb8cg20yi3yaxxcgpyuairmfi_ejtvwz0nukkjbpmy3y2bcikwfq&amp;command=deployvirtualmachine&amp;diskofferingid=1&amp;serviceofferingid=1&amp;templateid=2&amp;zoneid=4 将排序好的命令字符串和用户的私钥使用HMAC SHA-1哈希算法进行编码，在使用Base64将结果字节数组编码成UTF-8形式，最终得到的签名为：Lxx1DM40AjcXU%2FcaiK8RAP0O1hU%3D 设置API调用失效时间在不安全的通道如HTTP上，我们可以设置一个API调用逾期时间戳来防止重播攻击（replay attacks），服务器会追踪这个时间戳，并拒绝超过这个期限的后续的所有API调用。在API请求中加入以下参数可实现这个特性： signatureVersion=3 expires=YYYY-MM-DDThh:mm:ssZ 限制API调用频率避免对管理服务器的恶意攻击，防止性能下降以及对所有账户提供一致性，当API调用超过一定阈值后会向这些调用返回错误信息。调用者需要等待一段时间后重试一下。可以通过一下全局参数来设置API的调用频率限制： api.throttling.enabled：默认为false，即不限制API调用频率 api.throttling.interval ：以秒为单位 api.throttling.max：每个间隔周期接受的最大请求数 api.throttling.cachesize：存放API调用计数器的缓存，每个账户需要一个cache来存放该账户运行的API总数 API调用频率限制的不足之处： 存在多个管理服务器的时候，不同管理服务器的cache之间不是同步的，所以可能出现允许通过的请求数比设置的值要大的情况，最糟糕的情况下可能出现允许通过的请求数为：限制值*管理服务器数量 尽管如此，CloudStack还是可以有效地避免恶意攻击导致的服务拒绝 API响应CloudStack支持两种响应格式：XML和JSON，默认的响应是XML，可以在请求URL中使用&amp;response=json来设置JSON格式的响应。使用JSON格式时，如果一个响应的键没有值，则该键不会出现在响应中，而XML仍会返回一个空的元素。 最大返回结果页对于每个云，一个命令在一个页面中返回的结果数有一个默认的上限，以此来防止云服务器过载和防止DOS攻击。每个云的默认上限值是不同的，通过全局参数default.page.size来配置。如果云上有许多用户运行了许多虚拟机的话，可以把这个值设置大一点，但要小心不要设置得太大了。 错误处理如果在处理一个API请求的时候发生了错误，会返回特定格式的响应。每个错误信息响应包含一个错误代码和一个文本描述可能出错的原因。如果用户的签名错误或没有权限导致请求被拒绝会返回一个HTTP 401错误 异步命令异步命令可以隐式地执行那些耗时很长的任务，如创建一个快照。它和同步命令有以下几点不同： API引用以一个a来区分 提交后会马上返回一个任务ID 如果是创建资源的命令，在返回任务ID的同时还会返回资源ID 使用异步命令的关键在于Job ID，它在命令被执行后马上返回。使用Job ID，通过queryAsyncJobResult命令我们可以周期性地检查任务的状态，这个命令返回3种可能的任务状态 0-Job表示程序还在进行 1-Job表示成功地完成了 2-Job表示执行失败 查询命令执行状态的命令：command=queryAsyncJobResult&amp;jobId=1","categories":[{"name":"CloudStack","slug":"CloudStack","permalink":"/categories/CloudStack/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"/tags/云计算/"},{"name":"api","slug":"api","permalink":"/tags/api/"}]},{"title":"VPS搭建属于自己的SS代理","slug":"VPS搭建属于自己的SS代理","date":"2019-06-10T08:09:06.000Z","updated":"2019-06-10T08:40:53.564Z","comments":true,"path":"2019/06/10/VPS搭建属于自己的SS代理/","link":"","permalink":"/2019/06/10/VPS搭建属于自己的SS代理/","excerpt":"","text":"安装shadowsocks第一条命令1234# 下载脚本shadowsocks.shwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh# 等待下载完成... 第二条命令12# 为shadowsocks.sh添加执行权限chmod +x shadowsocks.sh 第三条命令123./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log# 中间会提示我们输入一些信息 中间会提示你输入你的SS server的账号，和端口。不输入就是默认。跑完命令后会出来你的SS客户端的信息。特别注意，由于iphone端的目前只支持到cfb，所以我们选择aes-256-cfb，即7，这一步按回车继续然后需要几分钟的安装过程，请耐心等待出现下面的画面！","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"/categories/shadowsocks/"}],"tags":[{"name":"vps","slug":"vps","permalink":"/tags/vps/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"/tags/shadowsocks/"},{"name":"翻墙","slug":"翻墙","permalink":"/tags/翻墙/"}]},{"title":"Centos7.x中磁盘管理及扩展","slug":"Centos7-x中磁盘管理及扩展","date":"2019-05-28T06:51:39.000Z","updated":"2019-05-28T09:21:20.090Z","comments":true,"path":"2019/05/28/Centos7-x中磁盘管理及扩展/","link":"","permalink":"/2019/05/28/Centos7-x中磁盘管理及扩展/","excerpt":"","text":"前提要求：虚拟机：centos7.x 在安装Centos系统时，磁盘选择为LVM逻辑卷。当选择为LVM后才能创建逻辑卷等（必须） 数据格式选择的是xfs，很多讲解使用的是ext3，但以后xfs的优势会比ext越来越大。（可选） LVM是Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对硬盘分区进行管理的一种机制。LVM是建立在硬盘和分区上的逻辑层，它允许跨硬盘、分区创建逻辑卷并创建文件系统，可以很方便执行增加、扩展、删除等操作。 物理卷（PV）物理卷（Physical Volume,PV）：就是指硬盘分区，也可以是整个硬盘或已创建的软RAID，是LVM的基本存储设备。在创建逻辑卷之前需要先创建物理卷，然后将多个物理卷组合创建卷组，最后在卷组的基础上创建逻辑卷。 可以将空白硬盘或分区加入主机，系统识别到新的硬盘sdb后，使用pvcreate对硬盘创建PV。 添加新硬盘或直接扩展分区的方式：`直接扩展/或直接新添加一个硬盘 12lsblk #列出系统上所有的磁盘df -h #检查文件系统的磁盘空间占用情况 可以看出磁盘vda还有200多G的空白磁盘没有挂载。 12345678910111213fdisk /dev/vda #回车p #回车n #回车默认 #回车默认 #回车默认 #回车默认 #回车t #回车默认 #回车8e #回车p #回车w #回车reboot #回车 12pvcreate /dev/vda3 #创建物理卷pvdisplay 卷组（VG）卷组（Volume Group,VG）：是由一个或多个物理卷所组成的存储池，在卷组上能创建一个或多个逻辑卷。现在使用vgcreate命令对上文创建的PV（单个物理卷）创建卷组。 12vgcreate -s 10M vg0 /dev/vda3 #创建卷组vg0,指定物理块PE大小10M,并将pv:/dev/vda3加入vg0vgdisplay # 查看所有卷组的信息.后面接具体卷组名,可查看指定卷组信息 1pvdisplay # 查看所当前物理卷的信息.后面可接具体物理卷设备,可查看指定物理卷信息 创建逻辑卷（LV）逻辑卷（Logical Volume,LV）：类似于非LVM系统中的硬盘分区，它建立在卷组之上，是一个标准的块设备，在逻辑卷之上可以建立文件系统。可以使用lvcreate命令创建逻辑卷 12345678910111213141516171819[root@hewanli-mysql ~]# lvcreate -n lv0 -l 100%vg vg0 #使用vg0的全部空间创建逻辑卷lv0 Logical volume \"lv0\" created.[root@hewanli-mysql ~]# lvdisplay --- Logical volume --- LV Path /dev/vg0/lv0 LV Name lv0 VG Name vg0 LV UUID uz1Ej1-mC6D-9MBf-Sdbc-2UQS-frMm-AsuzbC LV Write Access read/write LV Creation host, time hewanli-mysql, 2019-05-28 03:44:32 -0400 LV Status available # open 0 LV Size 249.99 GiB Current LE 25599 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:3 12345pvdisplaylsblk -f /dev/vda#会在/dev下生成一个新的设备文件：ll /dev/vg0/lv0ll /dev/dm-0 文件系统在逻辑卷lv0创建完成后还需要创建文件系统并挂载到指定目录才能够使用,当然还需要将挂载信息写入/etc/fstab文件 123456789mkfs.xfs /dev/vg0/lv0 # 创建文件系统lsblk /dev/vda -flsblk /dev/vg0/lv0 -fmkdir /data &amp;&amp; mount /dev/vg0/lv0 /data # 将逻辑卷挂载到制定目录df -T # 查看挂载点blkid /dev/vg0/lv0 #注意UUID，下面命令会使用df -T /dev/vg0/lv0echo \"UUID=2fb5642b-0167-4709-9d35-85a407b4801a /data xfs defaults 0 0\" &gt;&gt; /etc/fstab #UUID填自己的（上面命令结果有输出）cat /etc/fstab | egrep \"UUID\" 12lsblk #列出系统上所有的磁盘df -h #检查文件系统的磁盘空间占用情况 扩展逻辑卷我们可以很方便的多逻辑卷进行扩展，不论是使用新的空白磁盘还是已有的空白分区。其大致实现原理为：对空白分区创建物理卷，然后将物理卷加入到需要扩展逻辑卷所在的卷组，最后扩大逻辑卷空间。如果逻辑卷所在的卷组还有空闲的空间（PE）可被使用且足够大，则甚至不需要另外的分区或者磁盘。 1lsblk -f /dev/vda","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Centos7.x","slug":"Centos7-x","permalink":"/tags/Centos7-x/"},{"name":"磁盘管理及扩展","slug":"磁盘管理及扩展","permalink":"/tags/磁盘管理及扩展/"}]},{"title":"Gson使用技巧","slug":"Gson使用技巧","date":"2019-05-22T07:29:44.000Z","updated":"2019-05-22T07:36:30.343Z","comments":true,"path":"2019/05/22/Gson使用技巧/","link":"","permalink":"/2019/05/22/Gson使用技巧/","excerpt":"","text":"Gson获取json字符串中key对应的值字符串 ： //得到服务器返回的具体内容 1final String res = response.body().string(); 例1：{&quot;code&quot;:100,&quot;msg&quot;:&quot;处理成功！&quot;,&quot;extend&quot;:{&quot;jsonString&quot;:{&quot;userId&quot;:1,&quot;userName&quot;:&quot;123&quot;,&quot;userPwd&quot;:&quot;123&quot;}}} 12345678910jsonObject = (JsonObject) new JsonParser().parse(res).getAsJsonObject();// 获取 code：jsonObject.get(\"code\").getAsInt();// 获取 userName：jsonObject.get(\"extend\") .getAsJsonObject().get(\"jsonString\") .getAsJsonObject().get(\"userName\") .getAsString() 例2：{&quot;code&quot;:100,&quot;msg&quot;:&quot;处理成功！&quot;,&quot;extend&quot;:{&quot;jsonString&quot;:[{&quot;userId&quot;:1,&quot;userName&quot;:&quot;123&quot;,&quot;userPwd&quot;:&quot;123&quot;}]}} 1234567891011jsonObject = (JsonObject) new JsonParser().parse(res).getAsJsonObject();// 获取 code：String code = jsonObject.get(\"code\").getAsInt();// 获取 userName：String userName = jsonObject.get(\"extend\") .getAsJsonObject().get(\"jsonString\") .getAsJsonArray().get(0) .getAsJsonObject().get(\"userName\") .getAsString()","categories":[{"name":"Gson","slug":"Gson","permalink":"/categories/Gson/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}]},{"title":"java调用外部接口","slug":"java调用外部接口","date":"2019-05-22T07:24:59.000Z","updated":"2019-05-22T07:28:42.223Z","comments":true,"path":"2019/05/22/java调用外部接口/","link":"","permalink":"/2019/05/22/java调用外部接口/","excerpt":"","text":"Java调用外部接口的方法，最终返回接口response的信息12345678910111213141516String strURL = \"这里是你要调用的接口地址\";URL url = new URL(strURL);HttpURLConnection httpConn = (HttpURLConnection)url.openConnection();httpConn.setRequestMethod(\"GET\");httpConn.connect();BufferedReader reader = new BufferedReader( new InputStreamReader(httpConn.getInputStream()));String line;StringBuffer buffer = new StringBuffer();while ((line = reader.readLine()) != null) &#123; buffer.append(line);&#125;reader.close();httpConn.disconnect();System.out.println(buffer.toString()); 最终这里buffer.toString();就是接口response的值","categories":[{"name":"调用外部接口","slug":"调用外部接口","permalink":"/categories/调用外部接口/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}]},{"title":"Jboss在Linux下的使用技巧","slug":"Jboss在Linux下的使用技巧","date":"2019-05-10T08:52:52.000Z","updated":"2019-05-10T08:52:52.601Z","comments":true,"path":"2019/05/10/Jboss在Linux下的使用技巧/","link":"","permalink":"/2019/05/10/Jboss在Linux下的使用技巧/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux下远程连接MySQL数据库","slug":"Linux下远程连接MySQL数据库","date":"2019-05-08T15:43:12.000Z","updated":"2019-05-08T15:52:13.343Z","comments":true,"path":"2019/05/08/Linux下远程连接MySQL数据库/","link":"","permalink":"/2019/05/08/Linux下远程连接MySQL数据库/","excerpt":"","text":"在服务器端开启远程访问 首先进入mysql数据库，然后输入下面两个命令： 1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;; 1flush privileges; 第一个*是数据库，可以改成允许访问的数据库名称 第二个 是数据库的表名称，代表允许访问任意的表 root代表远程登录使用的用户名，可以自定义 %代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了 password代表远程登录时使用的密码，可以自定义 flush privileges;这是让权限立即生效 修改my.cnf配置文件 这个是mysql的配置文件，如果你无标题文章找不到在哪里的话，可以输入find /* -name my.cnf 找到通过vim编辑该文件，找到bind-address = 127.0.0.1这一句（如果没有就不管），然后在前面加个#号注释掉，保存退出 重启服务 1service mysql restart 开放3306端口（端口以自己实际情况为准） 123firewall-cmd --zone=public --add-port=3306/tcp --permanent# 重启防火墙systemctl restart firewalld 在本地远程连接 在终端输入： 1mysql -h 服务器ip地址 -P 3306 -u root -p 然后输入密码即可。 也可以使用连接工具连接，例如Navicat","categories":[{"name":"MySQL","slug":"MySQL","permalink":"/categories/MySQL/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"远程连接","slug":"远程连接","permalink":"/tags/远程连接/"}]},{"title":"IntelliJIDEA tomcat在浏览器js乱码问题解决","slug":"IntelliJIDEA-tomcat在浏览器js乱码问题解决","date":"2019-04-28T03:30:05.000Z","updated":"2019-04-28T03:57:34.814Z","comments":true,"path":"2019/04/28/IntelliJIDEA-tomcat在浏览器js乱码问题解决/","link":"","permalink":"/2019/04/28/IntelliJIDEA-tomcat在浏览器js乱码问题解决/","excerpt":"","text":"在配置Tomcat的时候添加参数1-Dfile.encoding=UTF-8 修改idea64.exe.vmoptions和idea.exe.vmoptions文件找到idea安装目录bin目录下如下图所示两个文件，用编辑器打开，在文件末尾添加 -Dfile.encoding=UTF-8 ，然后重启idea，再打开浏览器就会发现中文已经可以正常显示了","categories":[{"name":"IDEA","slug":"IDEA","permalink":"/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"/tags/Tomcat/"},{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"},{"name":"中文乱码","slug":"中文乱码","permalink":"/tags/中文乱码/"}]},{"title":"手把手教你用frp实现内网穿透","slug":"手把手教你用frp实现内网穿透","date":"2019-04-12T07:26:19.000Z","updated":"2019-04-16T09:16:39.538Z","comments":true,"path":"2019/04/12/手把手教你用frp实现内网穿透/","link":"","permalink":"/2019/04/12/手把手教你用frp实现内网穿透/","excerpt":"","text":"frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 数据准备： 公网IP: X.X.X.X 内网电脑使用的是win10-64系统 公网电脑为linux-64系统。 服务端配置文件下载下载地址：frp下载 具有公网IP的电脑将作为frp服务端(frps)，首先去项目地址的releases页面下载与服务端系统匹配的文件并解压 123456# 进入home目录cd /home# 下载对应的frp作为服务端wget https://github.com/fatedier/frp/releases/download/v0.26.0/frp_0.26.0_linux_amd64.tar.gz# 解压tar -zxvf frp_0.26.0_linux_amd64.tar.gz 编辑配置文件1234# 进入frpcd frp_0.26.0_linux_amd64/# 编辑frps.ini配置文件vim frps.ini 编辑frps.ini为以下内容： bind_port为客户端与服务端进行通信的端口。其它更丰富的配置可参考frps_full.ini和项目帮助文档。 启动服务端进行到解压后的frp目录，然后通过./frps -c frps.ini命令即可启动服务端，如下图所示： 12cd /home/frp_0.26.0_linux_amd64/./frps -c frps.ini 设置开机启动和后台运行上一步中的frps占据了整个命令窗口，所以接下来要考虑如何让它在后台运行并且开机自启：首先通过vim /etc/systemd/system/frps.service命令新建文件并写入以下内容: 12345678910111213[Unit]Description=frps daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/home/frp_0.26.0_linux_amd64/frps -c /home/frp_0.26.0_linux_amd64/frps.iniRestart= alwaysRestartSec=1min[Install]WantedBy=multi-user.target 注意ExecStart中要配置成自己的路径.然后使用systemctl start|stop|restart frps即可操作frps, 用systemctl enable frps即可将frps设置为开机启动。 客户端配置文件下载具有内网IP的电脑将作为客户端(frpc)，在releases页面下载frp_0.16.0_windows_amd64.zip解压 编辑配置文件编辑frpc.ini为以下内容： 123456789[common]server_addr = X.X.X.Xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 注意： sever_addr配置为公网电脑的IP，server_port与frps.ini中的bind_port一致。 ssh为远程桌面的配置。 启动服务端双击frpc.exe或者用命令 frpc -c frpc.ini即可启动客户端，如下图所示： 注意：这时候很可能启动不了，一般情况是因为服务器端（linux）7000端口没开放： 123456# 查看端口开放情况firewall-cmd --list-all# 添加开放端口firewall-cmd --zone=public --add-port=7000/tcp --permanent# 重启防火墙systemctl restart firewalld 然后再执行frpc -c frpc.ini就可以正常启动连接了。 设置开机启动和后台运行同样的道理，我们也需要对客户端设置后台运行和开机自启。借助 winsw 工具可以将frpc注册为windows系统中的服务。 下载winsw最新版，为了方便将其重命名为winsw.exe, 将该文件和frpc.exe放在一起, 然后新建winsw.xml写入以下内容： 12345678&lt;service&gt; &lt;id&gt;frp&lt;/id&gt; &lt;name&gt;frp&lt;/name&gt; &lt;description&gt;用frp发布本地电脑网站到外网&lt;/description&gt; &lt;executable&gt;frpc&lt;/executable&gt; &lt;arguments&gt;-c frpc.ini&lt;/arguments&gt; &lt;logmode&gt;reset&lt;/logmode&gt;&lt;/service&gt; 下载winsw后，在window上安装 .net framework4 ，否则后面会出问题。（很重要） 然后使用winsw install和winsw start命令即可将frpc安装为系统服务。 win+r后通过services.msc进入到服务列表页面找到frp服务。","categories":[{"name":"内网穿透","slug":"内网穿透","permalink":"/categories/内网穿透/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"frp","slug":"frp","permalink":"/tags/frp/"},{"name":"Windows","slug":"Windows","permalink":"/tags/Windows/"}]},{"title":"CloudStack介绍","slug":"CloudStack介绍","date":"2019-04-04T06:27:56.000Z","updated":"2019-06-13T03:19:21.781Z","comments":true,"path":"2019/04/04/CloudStack介绍/","link":"","permalink":"/2019/04/04/CloudStack介绍/","excerpt":"","text":"基本上，云计算只是一种把 IT 资源当作服务来提供的手段。几乎所有 IT 资源都可以作为云服务来提供：应用程序、计算能力、存储容量、联网、编程工具，以至于通信服务和协作工具。 云计算最早为 Google、Amazon 等其他扩建基础设施的大型互联网服务提供商所采用。于是产生一种架构：大规模扩展、水平分布的系统资源，抽象为虚拟 IT 服务，并作为持续配置、合用的资源进行管理。 就最终用户而言，云计算意味着没有硬件购置成本、没有需要管理的软件许可证或升级、不需要雇佣新的员工或咨询人员、不需要租赁设施、没有任何种类的基建投资，而且还没有隐性成本。只是一种用仪表测量出来的、根据使用情况支付的订购费或固定的订购费。只是用您所需的量，而且只按使用量付费。 云计算结构图如下： 基础设施当做服务（IaaS）基础设施当作服务 (IaaS) 处于最低层级，而且是一种作为标准化服务在网上提供基本存储和计算能力的手段。服务器、存储系统、交换机、路由器和其他系统协作 (例如，通过虚拟化技术) 处理特定类型的工作负载 — 从批处理到峰值负载期间的服务器/存储扩大。 最著名的商业示例是 Amazon Web 服务 (AWS)，其 EC2 和 S3 服务分别提供基本计算和存储服务。国内代表阿里云、腾讯云、百度云、金山云等。 优势： 利用率更高 — 在虚拟化之前，企业数据中心的服务器和存储利用率一般平均不到 50% (事实上，通常利用率为 10% 到 15%)。通过虚拟化，可以把工作负载封装一并转移到空闲或使用不足的系统，这就意味着可以整合现有系统，因而可以延迟或避免购买更多服务器容量。 资源整合 — 虚拟化使得整合多个 IT 资源成为可能。除服务器和存储整合之外，虚拟化提供一个整合系统架构、应用程序基础设施、数据和数据库、接口、网络、桌面系统甚至业务流程，因而可以节约成本和提高效率。 节省电能/成本 — 运行企业级数据中心所需的电能不再无限制地使用，而成本呈螺旋式上升趋势。在服务器硬件上每花一美元，就会在电费上增加一美元 (包括服务器运行和散热方面的成本)。利用虚拟化进行整合使得降低总能耗和节约大量资金成为可能。 节约空间 — 服务器膨胀仍然是多数企业数据中心面临的一个严重问题，可扩大数据中心并不总是一个良好的选择，因为每增大一平方米空间，就会平均增加很多成本。虚拟化通过把多个虚拟系统整合到较少物理系统上，可以缓解空间压力。 灾难恢复 (Disaster recovery) /业务连续 (Business Continuity) — 虚拟化可提高总体服务级利用率，并提供灾难恢复解决方案新选项。 CloudStack 介绍官网：http://cloudstack.apache.org/ CloudStack是一个开源的具有高可用性及扩展性的云计算平台CloudStack 是一个开源的云操作系统，它可以帮助用户利用自己的硬件提供类似于Amazon EC2那样的公共云服务。CloudStack可以通过组织和协调用户的虚拟化资源，构建一个和谐的环境。 CloudStack是一个开源的具有高可用性及扩展性的云计算平台CloudStack 是一个开源的云操作系统，它可以帮助用户利用自己的硬件提供类似于Amazon EC2那样的公共云服务。CloudStack可以通过组织和协调用户的虚拟化资源，构建一个和谐的环境。 Cloudstack支持管理大部分主流的hypervisors，如KVM，XenServer，VMware，Oracle VM，Xen等。 CloudStack 部署图如下： Zone：Zone 对应于现实中的一个数据中心，它是 CloudStack 中最大的一个单元。 即从包含关系上来说，一个 zone 包含多个 pod，一个 pod 包含多个 cluster，一个 cluster 包含多个 host。 提供点（Pods）：一个提供点通常代表一个机架，机柜里面的主机在同一个子网，每个区域中必须包含一个或多个提供点，提供点中包含主机和主存储服务器， CloudStack 的内部管理通信配置一个预留 IP 地址范围。预留的 IP 范围对云中的每个区域来说必须唯一。 集群（Clusters）：Cluster 是多个主机组成的一个集群。 ​ 同一个cluster中的主机有相同的硬件，相同的 Hypervisor，和共用同样的存储。同一个 cluster 中的虚拟机，可以实现无中断服务地从一个主机迁移到另外一个上。 ​ 集群由一个或多个宿主机和一个或多个主要存储服务器构成。集群的大小取决于下层虚拟机软件。大多数情况下基本无建议。当使用VMware时，每个VMware集群都被vCenter 服务器管理。管理员必须在本产品中登记vCenter。每个zone下可以有多个vCenter服务器。每个vCenter服务器可能管理多个VMware集群 主机（Hosts）： Host 就是运行的虚拟机（VM）主机。宿主机就是个独立的计算机。宿主机运行来宾虚拟机并提供其相应的计算资源。每个宿主机都装有虚拟机软件来运行来宾虚拟机。比如一个开启了kvm支持的服务器，一个思杰XenServer服务器，或者一个ESXi服务器都可以作为宿主机。 宿主机在CloudStack部署中属于最小的组织单元。宿主机包含于集群中，集群又属于提供点，而区域中包含提供点（就是在逻辑概念上zone&gt;pod&gt;cluster&gt;host），新增的宿主机可以随时添加以提供更多资源给来宾虚拟机，CloudStack自动探测宿主机的cpu数量和内存资源。宿主机对终端用户不可见。终端用户不能决定他们的虚拟机被分配到哪台宿主机。 CloudStack 中存在两种存储： Primary storage：一级存储与 cluster 关联，它为该 cluster 中的主机的全部虚拟机提供磁盘卷。一个 cluster 至少有一个一级存储，且在部署时位置要临近主机以提供高性能。 Secondary storage：二级存储与 zone 关联，它存储模板文件，ISO 镜像和磁盘卷快照。","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"CloudStack","slug":"CloudStack","permalink":"/tags/CloudStack/"},{"name":"介绍","slug":"介绍","permalink":"/tags/介绍/"}]},{"title":"搭建http服务器-nginx","slug":"搭建http服务器-nginx","date":"2019-04-04T03:49:55.000Z","updated":"2019-05-15T09:58:46.255Z","comments":true,"path":"2019/04/04/搭建http服务器-nginx/","link":"","permalink":"/2019/04/04/搭建http服务器-nginx/","excerpt":"","text":"安装安装 nginx 1yum -y install nginx 这一步可能会遇到&quot;No package nginx available.&quot;问题，解决方法如下： 问题处理问题描述：见下图 问题原因： nginx位于第三方的yum源里面，而不在centos官方yum源里面 解决方法（一）： 安装epel(Extra Packages for Enterprise Linux) 去epel网站下载对应版本 我的系统是centos7.6，cpu是x86_64 12345# 下载epelwget https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpm# 安装epelrpm -ivh epel-release-7-11.noarch.rpm 再次执行 yum install nginx,则会提示安装成功了 解决方法（二）： 出现这个的原因是因为本地yum源中没有我们想要的nginx，那么我们就需要创建一个/etc/yum.repos.d/nginx.repo的文件，新增一个yum源 12345678vim /etc/yum.repos.d/nginx.repo#在文件中写入以下内容：[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 退出保存后，再次执行 yum install nginx,则会提示安装成功了 配置 删除/usr/share/nginx/html/目录下的所有文件 1rm -rf /usr/share/nginx/html/* 防火墙中加入允许80 端口访问 123456## 加入80端口firewall-cmd --zone=public --add-port=80/tcp --permanent## 附加：# 显示防火墙应用列表firewall-cmd --list-all 重启防火墙 1systemctl restart firewalld 编辑/etc/nginx/nginx.conf配置文件，加入如下信息（追加到末尾），使能够访问目录 123autoindex on;# 显示目录autoindex_exact_size on;# 显示文件大小autoindex_localtime on;# 显示文件时间 启动nginx 12systemctl start nginxsystemctl enable nginx 启用将镜像上传到/usr/share/nginx/html目录，在浏览器访问可以看见如下图所示的文件信息，点击可下载 附加Nginx 显示中文乱码解决需要修改nginx的server的配置内容，增加一行：charset utf-8; 情如下： 12345678910111213upstream you.domainName.com &#123; server 127.0.0.1:8081;&#125; server &#123; listen 80; server_name you.domainName.com; charset utf-8; location /examples &#123; return 403; &#125; ....&#125; 重启Nginx服务(nginx -s reload)。最后，刷新，一切正常！","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"ngnix","slug":"ngnix","permalink":"/tags/ngnix/"}]},{"title":"CloudStack快速安装指南","slug":"CloudStack安装配置应用操作手册","date":"2019-04-03T09:32:32.000Z","updated":"2019-04-18T08:31:35.068Z","comments":true,"path":"2019/04/03/CloudStack安装配置应用操作手册/","link":"","permalink":"/2019/04/03/CloudStack安装配置应用操作手册/","excerpt":"","text":"CloudStack介绍介绍见： CloudStack介绍 CloudStack安装先决条件 至少两台（cloudstack-management和cloudstack-agent）支持并启用了硬件虚拟化的计算机。 一个CentOS的7.5 x86_64的ISO安装文件 网关位于xxx.xxx.xxx.1的A / 24网络，该网络上不应该有DHCP，运行CloudStack的计算机都不会有动态地址。同样，这是为了简单起见。 环境准备一套基本的CloudStack环境，包括一台CloudStack管理端（cloudstack-management），一个mysql数据库，若干台支持KVM虚拟化的计算节点（cloudstack-agent）以及一台用来做为二级存储的nfs服务器： 在实际生产中，mysql数据库和管理端都可能配备多台作为高可用，计算节点一般也是配置较高的物理服务器，但在实验环境，我们可以采用最小化安装模式，把mysql,nfs和管理端安装在同一台虚拟机上，使用一台支持KVM虚拟化的虚拟机用来作为计算节点 我们的环境本文使用两台虚拟机来搭建我们的环境，nfs,mysql和管理端都装在同一台虚拟机上，cloudstack-agent安装在一台开启了虚拟化支持的虚拟机上，部署架构如下： 定义 两台服务器的IP是： CloudStack管理端（cloudstack-management）：172.18.193.1 KVM虚拟化的计算节点（cloudstack-agent）：172.18.193.2 CloudStack管理端升级yum1yum -y upgrade 主机名CloudStack要求正确设置主机名。如果您在安装中使用了默认选项，那么您的主机名当前设置为localhost.localdomain。为了测试这个，我们将运行： 1hostname --fqdn 此时它可能会返回： 1localhost 要纠正这种情况 - 我们将通过编辑/etc/hosts文件来设置主机名，以便它遵循与此示例类似的格式： 12345678127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6172.18.193.1 mng.cloud.priv172.18.193.1 mng172.18.193.2 cloud1.cloud.priv172.18.193.2 cld172.18.0.1 gw61.139.2.69 dns 修改完该文件后，重新启动网络： 1systemctl restart network 现在使用hostname -fqdn命令重新检查并确保它返回FQDN响应 设置SELinux目前，要使CloudStack正常工作，SELinux必须设置为允许。我们希望为将来的引导配置它，并在当前运行的系统中对其进行修改。 要在运行的系统中将SELinux配置为允许，我们需要运行以下命令： 1setenforce 0 为了确保它保持在该状态，我们需要配置文件/etc/selinux/config以反映许可状态，如下例所示： 12345678910# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of these two values:# targeted - Targeted processes are protected,# mls - Multi Level Security protection.SELINUXTYPE=targeted NTP安装NTP配置是保持云服务器中所有时钟同步的必要条件。但是，默认情况下不安装NTP。所以我们将在此阶段安装和配置NTP。安装完成如下： 1yum -y install ntp 实际的默认配置适用于我们的目的，因此我们只需要启用它并将其设置为在启动时启动，如下所示： 12systemctl enable ntpdsystemctl start ntpd 配置CloudStack包存储库我们需要将机器配置为使用CloudStack软件包存储库。 要添加CloudStack存储库，请创建/etc/yum.repos.d/cloudstack.repo并插入以下信息。 12345[cloudstack]name=cloudstackbaseurl=http://download.cloudstack.org/centos/7/4.11/enabled=1gpgcheck=0 NFS 安装我们的配置将使用NFS进行主存储和二级存储。我们将继续为此目的设置两个NFS共享。我们首先安装nfs-utils。 1yum -y install nfs-utils 我们现在需要配置NFS以提供两个不同的共享。这在/etc/exports文件中相对容易处理。您应该确保它具有以下内容： 12/data/primary *(rw,async,no_root_squash,no_subtree_check)/data/secondary *(rw,async,no_root_squash,no_subtree_check) 您将注意到我们在系统上指定了两个目录（尚未存在）。我们将继续使用以下命令创建这些目录并在其上适当地设置权限： 12mkdir -p /data/primarymkdir /data/secondary CentOS 7.x版本默认使用NFSv4。NFSv4要求域设置在所有客户端上匹配。在我们的示例中，域是cloud.priv，因此请确保取消注释/etc/idmapd.conf中的域设置并设置如下： 1Domain = cloud.priv 现在，您需要在/etc/sysconfig/nfs文件的底部添加配置值（或者仅取消注释并设置它们） 123456LOCKD_TCPPORT=32803LOCKD_UDPPORT=32769MOUNTD_PORT=892RQUOTAD_PORT=875STATD_PORT=662STATD_OUTGOING_PORT=2020 现在我们需要禁用防火墙，这样它就不会阻止连接 12systemctl stop firewalldsystemctl disable firewalld 我们现在需要配置nfs服务以在启动时启动，并通过执行以下命令实际在主机上启动它： 1234systemctl enable rpcbindsystemctl enable nfssystemctl start rpcbindsystemctl start nfs 测试nfs服务端是否能访问 在 agent端执行showmount -e 172.18.193.1 管理服务器安装数据库安装和配置我们将首先安装MySQL并配置一些选项，以确保它与CloudStack一起运行良好。 首先，由于CentOS 7不再提供MySQL二进制文件，我们需要添加一个存储库： 123wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum -y update 通过运行以下命令进行安装： 1yum -y install mysql-server 现在安装了MySQL，我们需要对/etc/my.cnf进行一些配置更改。具体来说，我们需要在[mysqld]部分添加以下选项： 12345innodb_rollback_on_timeout=1innodb_lock_wait_timeout=600max_connections=350log-bin=mysql-binbinlog-format = 'ROW' 现在MySQL已正确配置，我们可以启动它并将其配置为在启动时启动，如下所示： 12systemctl enable mysqldsystemctl start mysqld MySQL连接器安装使用官方MySQL软件包存储库安装Python MySQL连接器。/etc/yum.repos.d/mysql.repo使用以下内容创建文件： 12345[mysql-connectors-community]name=MySQL Community connectorsbaseurl=http://repo.mysql.com/yum/mysql-connectors-community/el/$releasever/$basearch/enabled=1gpgcheck=1 从MySQL导入GPG公钥： 1rpm --import http://repo.mysql.com/RPM-GPG-KEY-mysql 安装mysql-connector 1yum install mysql-connector-python 安装管理服务器我们现在要安装管理服务器。我们通过执行以下命令来做到这一点： 1yum -y install cloudstack-management 当yum -y install cloudstack-management命令不好使的时候，操作如下： 1234wget http://download.cloudstack.org/centos/7/4.11/cloudstack-management-4.11.2.0-1.el7.centos.x86_64.rpmwget http://download.cloudstack.org/centos/7/4.11/cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpmyum localinstall cloudstack-management-4.11.2.0-1.el7.centos.x86_64.rpm cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpm 安装了应用程序本身后，我们现在可以设置数据库，我们将使用以下命令和选项执行此操作： 1cloudstack-setup-databases cloud:password@localhost --deploy-as=root 完成此过程后，您应该看到“CloudStack has successfully initialized the database.”之类的消息。 既然已经创建了数据库，我们可以通过发出以下命令来设置管理服务器的最后一步： 1cloudstack-setup-management 系统模板设置CloudStack使用许多系统VM来提供访问虚拟机控制台，提供各种网络服务以及管理存储的各个方面的功能。当我们引导您的云时，此步骤将获取准备部署的系统映像。 现在我们需要下载系统VM模板并将其部署到我们刚刚挂载的共享。管理服务器包括用于正确操纵系统VMs映像的脚本。 12/usr/share/cloudstack-common/scripts/storage/secondary/cloud-install-sys-tmplt -m /data/secondary -u http://download.cloudstack.org/systemvm/4.11/systemvmtemplate-4.11.2-kvm.qcow2.bz2 -h kvm -F 这就结束了我们的管理服务器的安装 CloudStack计算节点升级yum1yum -y upgrade 配置网络要将其配置为在您的环境中工作。由于我们指定在此环境中不存在DHCP服务器，因此我们将手动配置您的网络接口。 在继续之前，请确保安装了“brctl”并且可用： 1yum install bridge-utils -y 通过控制台连接，您应该以root用户身份登录。我们将首先创建Cloudstack将用于网络的桥梁。创建并打开/etc/sysconfig/network-scripts/ifcfg-cloudbr0并添加以下设置： IP寻址 - 在本文档中，我们假设您将拥有一个用于CloudStack实施的/24网络。这可以是任何RFC 1918网络。 123456789101112DEVICE=cloudbr0TYPE=BridgeONBOOT=yesBOOTPROTO=noneIPV6INIT=noIPV6_AUTOCONF=noDELAY=5IPADDR=172.18.193.2PREFIX=16GATEWAY=172.18.0.1DNS1=61.139.2.69STP=yes 保存配置并退出。然后我们将编辑界面，以便它使用这个桥。 打开您的交互接口的配置文件并按如下所示进行配置： 接口名称仅用作示例。将em1替换为您的默认以太网接口名称。 123456DEVICE=em1TYPE=EthernetONBOOT=yesBOOTPROTO=noneBRIDGE=cloudbr0HWADDR=80:18:44:ea:71:84 您不应使用我们的示例中的硬件地址（也称为MAC地址或UUID）进行配置。它是特定于网络接口的，因此您应该保留UUID指令中已提供的地址。 现在我们已经正确设置了配置文件，我们需要运行一些命令来启动网络： 12systemctl enable networksystemctl restart network 请注意，如果您通过SSH连接，则会暂时（约5秒，具体取决于硬件）断开连接。如果断开连接，则配置中存在错误。 主机名CloudStack要求正确设置主机名。如果您在安装中使用了默认选项，那么您的主机名当前设置为localhost.localdomain。为了测试这个，我们将运行： 1hostname --fqdn 此时它可能会返回： 1localhost 要纠正这种情况 - 我们将通过编辑/etc/hosts文件来设置主机名，以便它遵循与此示例类似的格式： 12345678127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6172.18.193.1 mng.cloud.priv172.18.193.1 mng172.18.193.2 cloud1.cloud.priv172.18.193.2 cld172.18.0.1 gw61.139.2.69 dns 修改完该文件后，重新启动网络： 1systemctl restart network 现在使用hostname -fqdn命令重新检查并确保它返回FQDN响应 设置SELinux目前，要使CloudStack正常工作，SELinux必须设置为允许。我们希望为将来的引导配置它，并在当前运行的系统中对其进行修改。 要在运行的系统中将SELinux配置为允许，我们需要运行以下命令： 1setenforce 0 为了确保它保持在该状态，我们需要配置文件/etc/selinux/config以反映许可状态，如下例所示： 12345678910# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of these two values:# targeted - Targeted processes are protected,# mls - Multi Level Security protection.SELINUXTYPE=targeted NTP安装NTP配置是保持云服务器中所有时钟同步的必要条件。但是，默认情况下不安装NTP。所以我们将在此阶段安装和配置NTP。安装完成如下： 1yum -y install ntp 实际的默认配置适用于我们的目的，因此我们只需要启用它并将其设置为在启动时启动，如下所示： 12systemctl enable ntpdsystemctl start ntpd KVM设置和安装KVM是我们将要使用的虚拟机管理程序 - 我们将恢复已在虚拟机管理程序主机上完成的初始设置并涵盖代理软件的安装，您可以使用相同的步骤将其他KVM节点添加到您的CloudStack环境中。 安装节点服务器1yum -y install cloudstack-agent 当yum -y install cloudstack-agent命令不好使的时候，操作如下： 1234wget http://download.cloudstack.org/centos/7/4.11/cloudstack-agent-4.11.2.0-1.el7.centos.x86_64.rpmwget http://download.cloudstack.org/centos/7/4.11/cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpmyum localinstall cloudstack-agent-4.11.2.0-1.el7.centos.x86_64.rpm cloudstack-common-4.11.2.0-1.el7.centos.x86_64.rpm 我们有两个不同的KVM部分来配置，libvirt和QEMU。 QEMU配置KVM配置只在一个项目上相对简单。我们需要编辑QEMU VNC配置。这是通过编辑/etc/libvirt/qemu.conf并确保以下行存在并取消注释来完成的。 1vnc_listen=0.0.0.0 Libvirt配置CloudStack使用libvirt来管理虚拟机。因此，正确配置libvirt至关重要。Libvirt是云代理的依赖，应该已经安装。 为了实现实时迁移，libvirt必须监听不安全的TCP连接。我们还需要关闭libvirts尝试使用多播DNS广告。这两个设置都在/etc/libvirt/libvirtd.conf中 设置以下参数： 12345listen_tls = 0listen_tcp = 1tcp_port = \"16509\"auth_tcp = \"none\"mdns_adv = 0 在libvirtd.conf中打开“listen_tcp”是不够的，我们还要更改参数，我们还需要修改/etc/sysconfig/libvirtd： 取消注释以下行： 1LIBVIRTD_ARGS=&quot;--listen&quot; 重启libvirt 1systemctl restart libvirtd KVM配置完成 为了完整起见，您应该检查KVM在您的计算机上是否正常运行： 123456lsmod | grep kvm# 输出kvm_intel 183705 47 kvm 615914 1 kvm_intelirqbypass 13503 37 kvm 这就结束了我们对KVM的安装和配置，现在我们将使用CloudStack UI来实际配置我们的云。 CloudStack系统配置访问地址： 12http://&lt;management-server-ip-address&gt;:8080/client# 即：http://172.18.193.1:8080/client 如果管理服务器是全新的安装,那么会出现一个安装向导。在稍后的访问中，你将看到一个登录界面,，你需要通过用户名和密码登入来查看你的仪表盘。 123用户名 -&gt; 你账号的用户ID。默认用户名是admin。密码 -&gt; 用户ID对应的密码。默认用户名的密码是password。域 -&gt; 如果你是root用户，此处留空即可。 CloudStack用户界面帮助云基础设施的用户查看和使用他们的云资源，包括虚拟机、模板和ISO、数据卷和快照、宾客网络，以及IP 地址。如果用户是一个或多个CloudStack项目的成员或管理员，用户界面能提供一个面向项目的视图。 选择”我以前是用过CloudStack，跳过此指南”按钮 选择“资源域” 选择“添加资源域” 选择“基本”网络，点击”下一步” 1234567# 配置内容如下:名称：Zone1IPV4 DNS1：61.139.2.69内部 DNS1：虚拟机选择“KVM”网络方案默认# 这些内容包括下面的填写仅为参考值。可根据实际情况进行修改 点击”下一步” 12# 配置内容如下:物理网络名称:默认 #也可键入cloudstack-management实际网络名称 点击”下一步” 123456# 配置内容如下:提供名称：Pod1预留的系统网关：172.18.0.1预留的系统网络掩码：255.255.0.0起始预留系统IP：172.18.193.3结束预留系统IP：172.18.193.254 点击”下一步” 12345# 配置内容如下:来宾网关：172.18.0.1来宾网络掩码：255.255.0.0来宾起始IP:172.18.194.1来宾结束IP：172.18.194.254 点击”下一步” 123# 配置内容如下:虚拟机管理程序：KVM集群名称：Cluster 点击”下一步” 12345# 配置内容如下:主机名称：172.18.193.2 #cloudstack-agent计算节点地址用户名：root #cloudstack-agent计算节点用户名密码：password #cloudstack-agent计算节点密码主机标签：可不填 点击”下一步” 1234567# 配置内容如下:名称：primary #不是固定的，自己根据需要进行区分即可范围：选择群集协议：选择nfs服务器：172.18.193.1路径：/data/primary #根据安装时的配置填写存储路径：可不填 点击”下一步” 12345# 配置内容如下:提供程序：选择NFS名称：secondary #不是固定的，自己根据需要进行区分即可服务器：172.18.193.1路径：/data/secondary #根据安装时的配置填写 点击”下一步” 点击“启动资源域” 成功后，先不启动资源域，我们可以先看下基础架构 此时系统VM为0 资源启动成功后，系统VM会出现2台 系统VM是不同于主机上创建的普通虚拟机的，他们是CloudStack云平台自带的用于完成自身的一些任务的虚拟机。 Secondary Storage VM：简称为SSVM，用于管理二级存储的相关操作，如模板跟镜像文件的上传与下载，快照，volumes的存放，第一次创建虚拟机时从二级存储拷贝模板到一级存储并且自动创建快照，每一个资源域可以有多个SSVM，当SSVM被删除或停止，它会自动被重建并启动。 Console Proxy VM：用于在web 界面上展示控制台。 通过查看控制台访问里面的虚拟机 CloudStack 虚拟机实例虚拟机实例默认的模板并没有被下载 修改全局设置secstorage.allowed.internal.sites设置 ，二级存储ISO镜像和模板可以下载，IP网段 重启服务systemctl restart cloudstack-management 搭建http服务器-nginx目的：注册ISO时需要填镜像的url，实时下载镜像，外网或者网速不是很好下载会很慢甚至下载失败，故搭建自己的http服务器以便在内网下载镜像，这样速度会快很多。 注 ：在cloudstack-management管理服务器节点搭建nginx 操作教程见：搭建http服务器-nginx 制作模板注册ISO 接下来按步骤走，就可以创建出第一个虚拟机了。","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"CloudStack","slug":"CloudStack","permalink":"/tags/CloudStack/"},{"name":"虚拟机分配","slug":"虚拟机分配","permalink":"/tags/虚拟机分配/"},{"name":"安装指南","slug":"安装指南","permalink":"/tags/安装指南/"}]},{"title":"Java8 实现下载网页的完整代码","slug":"Java8-实现下载网页的完整代码","date":"2019-03-12T07:56:01.000Z","updated":"2019-03-12T08:22:42.205Z","comments":true,"path":"2019/03/12/Java8-实现下载网页的完整代码/","link":"","permalink":"/2019/03/12/Java8-实现下载网页的完整代码/","excerpt":"","text":"java8 实现网页下载，大致分为4步，分别是:给定目标网页链接-&gt;与目标主机建立连接-&gt;读入网页文件流-&gt;写入本地文件 。会用到java io 和 java net库。程序代码如下，留有注释。 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;import java.net.MalformedURLException;import java.net.URL;public class test &#123; public static void main(String[] args) &#123; try &#123; new test().downloadPage(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private String downloadPage() throws IOException &#123; // 目标网页链接 String url = \"https://hexo.io/zh-cn/\"; String inputLine = null; try &#123; URL pageUrl = new URL(url); BufferedReader br = new BufferedReader( new InputStreamReader(pageUrl.openStream(), \"utf-8\")); //程序文件目录建目录 download，用于存放下载的网页 File file = new File(\"D:\\\\Test\\\\maliang\\\\index.html\"); FileOutputStream out = new FileOutputStream(file); OutputStreamWriter write = new OutputStreamWriter(out, \"utf-8\"); // 将输入流读入到变量中，再写入到文件 while ((inputLine = br.readLine()) != null) &#123; write.write(inputLine); System.out.println(inputLine); &#125; br.close(); write.close(); System.err.println(\"下载完毕!\"); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; return url; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"/tags/Java8/"},{"name":"下载网页的完整代码","slug":"下载网页的完整代码","permalink":"/tags/下载网页的完整代码/"}]},{"title":"Linux服务器上搭建svn服务器","slug":"Linux服务器上搭建svn服务器","date":"2019-02-15T03:31:10.000Z","updated":"2019-02-23T08:31:38.515Z","comments":true,"path":"2019/02/15/Linux服务器上搭建svn服务器/","link":"","permalink":"/2019/02/15/Linux服务器上搭建svn服务器/","excerpt":"","text":"背景项目开发中需要版本控制，而我们经常使用的是在windows系统上搭建svn服务器，下面介绍在Linux系统（CentOS 7.3.1611）上搭建svn服务器。 使用yum安装svn使用yum安装svn，命令如下： 1yum -y install subversion 安装完成之后，验证svn安装是否成功 1svn help 新建仓库目录在/opt目录下面创建一个svn目录，用来作为svn存储目录，命令如下： 1mkdir /opt/svn 创建一个测试仓库执行如下命令，创建一个仓库 1svnadmin create /opt/svn/test/ 进入仓库目录下，查看仓库的文件，命令： 12cd /opt/svn/test/ #进入仓库目录ls #展示仓库文件 关于仓库文件的说明： hooks目录：放置hook脚步文件的目录locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端format目录：是一个文本文件，里边只放了一个整数，表示当前文件库配置的版本号conf目录：是这个仓库配置文件（仓库用户访问账户，权限） 配置SVN服务的配置文件svnserve.conf进入到conf文件夹下面，编辑svnserve.conf文件，命令如下： 123cd conflsvim svnserver.conf 在svnserver.conf文件中，anon-access前面的注释去掉，将对应的值设置为none，将auth-access前面的注释也去掉，将password-db前面的注释也去掉，还有将authz-db前面的注释也去掉，显示如下： 最重要的一点，去掉注释之后，配置项前面不能有空格。 配置访问的用户及密码编辑passwd文件，在文件的末尾加上自己需要添加的用户名和密码，显示如图： 1vim passwd 注意：用户和密码都是明文显示的 配置新用户的授权访问的文件编辑authz文件，在该文件中追加如下内容： 12345vim authz# 添加内容[/]flytzuhan=rw 启动svn服务执行如下命令： 1svnserve -d -r /opt/svn/ 其中-d表示后台运行， -r指定根目录，这里需要注意：绝对不能将启动命令写成：svnserve -d -r /opt/svn/test/ 还有启动的时候可能会出现如下错误：svnserve: E000098: Can&#39;t bind server socket: Address already in use 这个是由于已经启动了SVN服务，所以需要先关闭进程，重新启动即可，命令如下： 12killall svnservesvnserve -d -r /opt/svn/ windows系统拉取代码可以在图形化界面中输入：svn://你的IP(公网)/test链接svn 然后你就可以愉快的使用了~~~","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"svn","slug":"svn","permalink":"/tags/svn/"}]},{"title":"React上手技巧","slug":"React上手技巧","date":"2019-02-14T02:41:03.000Z","updated":"2019-02-14T03:11:54.199Z","comments":true,"path":"2019/02/14/React上手技巧/","link":"","permalink":"/2019/02/14/React上手技巧/","excerpt":"","text":"创建一个React应用程序参见：https://blog.csdn.net/tiangongkaiwu152368/article/details/80847494 安装node我们要用create-react-app来开发react，首先要通过包管理器安装create-react-app，而包管理器一般安装了nodejs后会自带的，所以我们的第一步是在我们的电脑上安装node。 请参考以下nodejs安装教程： Node.js安装配置 检测npm包是否可用安装好后，并且也配置进入了环境变量，然后我们来检测下你的npm包是否可用，打开cmd窗口，输入npm -v 进行检测，如下所示，若显示版本号则说明安装成功，环境变量也配置成功，可用开始安装creact-react-app进行react开发了。 使用 create-react-app 快速构建 React 开发环境create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。 create-react-app 自动创建的项目是基于 Webpack + ES6 。 执行以下命令创建项目： 1234npm install -g create-react-appcreate-react-app project_namecd project_name/npm start 参考：create-react-app 在浏览器中打开 http://localhost:3000/ ，结果如下图所示： 提示：安装好后，如果你想卸载，可以直接把install改为uninstal即可，也就是在前面个un就可以表示卸载了。有时候卸载后在安装可能会报写错，此时你直接定位的create-react-app安装目录，然后把这个目录删除一般就能解决了。 怎么运行别人写好的reactjs项目 首先安装nodejs最新稳定版，配置环境变量，使得node和npm命令能正常运行，自己去官方下载； 在项目下运行 npm install （功能：安装依赖） 然后看项目下的README.md，一般有指引教你如何运行。","categories":[{"name":"React","slug":"React","permalink":"/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"React","slug":"React","permalink":"/tags/React/"}]},{"title":"Linux下端口映射工具rinetd","slug":"Linux下端口映射工具rinetd","date":"2019-02-12T08:51:22.000Z","updated":"2019-02-12T09:30:58.619Z","comments":true,"path":"2019/02/12/Linux下端口映射工具rinetd/","link":"","permalink":"/2019/02/12/Linux下端口映射工具rinetd/","excerpt":"","text":"Linux下简单好用的工具rinetd，实现端口映射/转发/重定向 官网地址http://www.boutell.com/rinetd 软件下载1wget http://www.boutell.com/rinetd/http/rinetd.tar.gz 解压安装1234tar zxvf rinetd.tar.gzcd rinetdmakemake install 注意：执行make install时可能出现错误： 缺少目录/usr/man/man8 此时执行 mkdir /usr/man/man8后再执行make install即可 编辑配置123456vi /etc/rinetd.conf# 内容0.0.0.0 8080 172.19.94.3 80800.0.0.0 2222 192.168.0.103 33891.2.3.4 80 192.168.0.10 80 说明一下（0.0.0.0表示本机绑定所有可用地址）将所有发往本机8080端口的请求转发到172.19.94.3的8080端口将所有发往本机2222端口的请求转发到192.168.0.103的3389端口将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口 命令格式是bindaddress bindport connectaddress connectport绑定的地址 绑定的端口 连接的地址 连接的端口或[Source Address] [Source Port] [Destination Address] [Destination Port]源地址 源端口 目的地址 目的端口 启动程序1234rinetd -c /etc/rinetd.conf ##启动转发# 附加：pkill rinetd ##关闭进程 把命令rinetd -c /etc/rinetd.conf加到/etc/rc.local里面就可以开机自动运行 查看状态123netstat -antp | grep 8080 | grep -v grepnetstat -antp | grep rinetd | grep -v grep 需要注意 rinetd.conf中绑定的本机端口必须没有被其它程序占用 运行rinetd的系统防火墙应该打开绑定的本机端口（或者直接关闭防火墙？） 例如： 12-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 1111 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 2222 -j ACCEPT","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"映射","slug":"映射","permalink":"/tags/映射/"},{"name":"rinetd","slug":"rinetd","permalink":"/tags/rinetd/"}]},{"title":"工作以及自我学习计划","slug":"工作以及自我学习计划","date":"2019-01-31T08:38:41.000Z","updated":"2019-01-31T08:41:00.863Z","comments":true,"path":"2019/01/31/工作以及自我学习计划/","link":"","permalink":"/2019/01/31/工作以及自我学习计划/","excerpt":"","text":"人工智能-2019年工作计划","categories":[{"name":"乱语","slug":"乱语","permalink":"/categories/乱语/"}],"tags":[{"name":"学习计划","slug":"学习计划","permalink":"/tags/学习计划/"},{"name":"工作计划","slug":"工作计划","permalink":"/tags/工作计划/"}]},{"title":"让应用程序支持emoji字符","slug":"让应用程序支持emoji字符","date":"2019-01-31T03:00:44.000Z","updated":"2019-05-08T15:53:29.126Z","comments":true,"path":"2019/01/31/让应用程序支持emoji字符/","link":"","permalink":"/2019/01/31/让应用程序支持emoji字符/","excerpt":"","text":"什么是emoji？就是这些表情和符号： 😀😄💦😍😂😱😭😴👌 自iPhone从iOS 5在输入法中开始支持emoji以来，这些表情符号迅速风靡世界。但是很多Web网站竟然还不！支！持！！！ 那怎么才能支持emoji呢？其实代码一行都不用改，因为emoji符号实际上是文本，并不是图片，它们仅仅显示为图片而已。而且，emoji符号已经被标准化并编码到最新的Unicode标准中了，所以，要支持emoji，只需要底层软件系统支持就可以了。 服务器端要正确存储emoji符号，只需要确保Web程序和底层数据库能支持最新的Unicode标准就可以了。 如果使用MySQL作为数据库，需要升级到5.5.3或更新的版本，然后，把默认编码从原来的utf8改为utf8mb4，在my.cnf或者my.ini配置文件中修改如下： 123456[client]default-character-set = utf8mb4[mysqld]character-set-server = utf8mb4collation-server = utf8mb4_general_ci 重启MySQL，然后使用以下命令查看编码，应该全部为utf8mb4（character_set_filesystem和character_set_system除外）： 1234567891011121314mysql&gt; show variables like '%char%';+--------------------------+--------------------------+| Variable_name | Value |+--------------------------+--------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.... |+--------------------------+--------------------------+8 rows in set (0.00 sec) 使用命令查看collation设置，应该全部是utf8mb4_general_ci： 123456789mysql&gt; show variables like '%coll%';+----------------------+--------------------+| Variable_name | Value |+----------------------+--------------------+| collation_connection | utf8mb4_general_ci || collation_database | utf8mb4_general_ci || collation_server | utf8mb4_general_ci |+----------------------+--------------------+3 rows in set (0.01 sec) 如果character_set_database还是为utf8，需要重启服务器。 现在，MySQL就可以正确存储emoji字符了。 Web软件 要支持emoji，需要Web软件也支持。目前，已知支持emoji的包括： Java 8 Node 最后，如果你的Web应用程序没有使用标准的UTF-8编码，而是使用了GBK等编码，想要支持emoji就只能呵呵了","categories":[{"name":"MySQL","slug":"MySQL","permalink":"/categories/MySQL/"}],"tags":[{"name":"emoji","slug":"emoji","permalink":"/tags/emoji/"},{"name":"utf8mb4","slug":"utf8mb4","permalink":"/tags/utf8mb4/"},{"name":"Web","slug":"Web","permalink":"/tags/Web/"}]},{"title":"JVM -verbose参数详解","slug":"JVM-verbose参数详解","date":"2019-01-28T11:50:55.000Z","updated":"2019-01-28T12:05:53.116Z","comments":true,"path":"2019/01/28/JVM-verbose参数详解/","link":"","permalink":"/2019/01/28/JVM-verbose参数详解/","excerpt":"","text":"java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息java -verbose:class在程序运行的时候有多少类被加载！你可以用verbose:class来监视，在命令行输入java -verbose:class XXX (XXX为程序名)你会在控制台看到加载的类的情况。 配置参数： verbose和verbose:class含义相同，输出虚拟机装入的类的信息，显示的信息格式如下： 12345678910[Opened D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.Object from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.io.Serializable from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from D:\\Java\\jdk1.6.0_25\\jre\\lib\\rt.jar]... java –verbose:gc在虚拟机发生内存回收时在输出设备显示信息，格式如下： [Full GC 256K-&gt;160K(124096K), 0.0042708 secs] 该参数用来监视虚拟机内存回收的情况。 12345678910public class JvmVerbose &#123; /** * JVM -verbose[:class|gc|jni] 参数测试 * @param args */ public static void main(String[] args) &#123; JvmVerbose jvmVerbose = new JvmVerbose(); System.gc(); &#125;&#125; 在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为可达，程序编译后，执行命令： java -verbose:gc JvmVerbose 后结果为： 123[GC 647K-&gt;256K(124096K), 0.0274253 secs][Full GC 256K-&gt;160K(124096K), 0.0042708 secs] 箭头前后的数据256K和160K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有256K-160K=96K的对象容量被回收，括号内的数据124096K为堆内存的总容量，收集所需要的时间是0.0042708秒（这个时间在每次执行的时候会有所不同） java –verbose:jni-verbose:jni输出native方法调用的相关情况，一般用于诊断jni调用错误信息。在虚拟机调用native方法时输出设备显示信息，格式如下： [Dynamic-linking native methodjava.lang.Object.registerNatives ... JNI] 该参数用来监视虚拟机调用本地方法的情况，在发生jni错误时可为诊断提供便利。 小试身手： 123456public class Test &#123; public static void main(String args[])&#123; Test test = new Test(); System.gc(); &#125;&#125; 配置参数： 执行Test.class加载了以下这么多类 1234567891011121314151617181920212223242526[Opened C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Object from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.io.Serializable from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.String from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.reflect.GenericDeclaration from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.reflect.Type from C:\\Java\\jdk7\\jre\\lib\\rt.jar]...[Full GC 812K-&gt;442K(15872K), 0.0031244 secs] [Loaded sun.misc.Cleaner from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Shutdown from C:\\Java\\jdk7\\jre\\lib\\rt.jar][Loaded java.lang.Shutdown$Lock from C:\\Java\\jdk7\\jre\\lib\\rt.jar]...","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"/tags/eclipse/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"Maven生成javadoc(api文档)","slug":"Maven生成javadoc-api文档","date":"2019-01-24T02:16:22.000Z","updated":"2019-01-24T02:24:05.640Z","comments":true,"path":"2019/01/24/Maven生成javadoc-api文档/","link":"","permalink":"/2019/01/24/Maven生成javadoc-api文档/","excerpt":"","text":"pom配置123456789101112131415&lt;!-- properties与dependencys同级 --&gt;&lt;properties&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;configuration&gt; &lt;reportOutputDirectory&gt;../javadocs&lt;/reportOutputDirectory&gt; &lt;destDir&gt;easy-delivery&lt;/destDir&gt; &lt;/configuration&gt;&lt;/plugin&gt; 生成doc命令首先需要打开cmd，然后cd到项目目录下，然后执行下面命令即可 例： 123D:cd D:\\maliangnansheng\\IDEA_HKAI\\hkai-ocrmvn javadoc:javadoc 查看文件比如我的项目在hkai-ocr这个文件夹下面，doc也会生成在与hkai-ocr同级目录（也可以修改上面的配置） 打开生成的doc里index.html 就可以看到api页面","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"api","slug":"api","permalink":"/tags/api/"},{"name":"Maven","slug":"Maven","permalink":"/tags/Maven/"}]},{"title":"CentOS部署kodexplorer可道云搭建私有网盘","slug":"CentOS部署kodexplorer可道云搭建私有网盘","date":"2019-01-16T06:38:15.000Z","updated":"2019-01-16T07:50:17.841Z","comments":true,"path":"2019/01/16/CentOS部署kodexplorer可道云搭建私有网盘/","link":"","permalink":"/2019/01/16/CentOS部署kodexplorer可道云搭建私有网盘/","excerpt":"","text":"工具/原料 xampp 可道云kodexplorer PHP环境配置 可以在串口使用getconf LONG_BIT 命令来查看并确定linux操作系统版本 输出：32表面系统是32位。输出：64表面系统是64位。 下载与自己操作系统相适应版本的xampp [32bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/5.6.14/xampp-linux-5.6.14-4-installer.run&gt;（7.3.0没有32位版本的，自己找找哪个版本有）[64bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/7.3.0/xampp-linux-x64-7.3.0-0-installer.run 123mkdir /home/xamppcd /home/xampp/wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/7.3.0/xampp-linux-x64-7.3.0-0-installer.run 安装xampp，为私有云安装构建Apache和PHP环境 12chmod u+x xampp-linux-x64-7.3.0-0-installer.run./xampp-linux-x64-7.3.0-0-installer.run 删除包： 1rm -rf /home/xampp/ 启动xampp，执行/opt/lampp/lampp start启动服务 默认安装在/opt/lampp/下 1/opt/lampp/lampp start 下载和安装可道云kodexplorer 下载最新版本的可道云KodExplorer程序 下载地址：http://kodcloud.com/download.html 下载： 1234mkdir /home/kodexplorercd /home/kodexplorer/# 当时最新版wget http://static.kalcaddle.com/update/download/kodexplorer4.37.zip 将可道云kodexplorer.zip解压 1unzip kodexplorer4.37.zip 将解压后的内容拷贝至/opt/lampp/htdocs/目录下 123cp -r /home/kodexplorer/ /opt/lampp/htdocs/chmod 777 /opt/lampp/htdocs/kodexplorerchmod -R 777 /opt/lampp/htdocs/kodexplorer/data/ 删除不用文件： 1rm -rf /home/kodexplorer/ 浏览器访问kodexplorer的index.php即可访问KodExplorer界面 即：http://IP地址/kodexplorer/index.php 例：http://172.19.15.52/kodexplorer/index.php","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"kodexplorer","slug":"kodexplorer","permalink":"/tags/kodexplorer/"},{"name":"部署","slug":"部署","permalink":"/tags/部署/"}]},{"title":"使用Java打开桌面文件","slug":"使用Java打开桌面文件","date":"2019-01-15T09:34:36.000Z","updated":"2019-01-15T09:59:44.143Z","comments":true,"path":"2019/01/15/使用Java打开桌面文件/","link":"","permalink":"/2019/01/15/使用Java打开桌面文件/","excerpt":"","text":"打开某一文件（默认软件打开）123456789101112public static void main(String[] args) &#123; try &#123; Desktop desktop = Desktop.getDesktop(); if (desktop.isSupported(Desktop.Action.OPEN)) &#123; desktop.open(new File(\"Your.pdf\")); //全路径 &#125; else &#123; System.out.println(\"Open is not supported\"); &#125; &#125; catch (IOException exp) &#123; exp.printStackTrace(); &#125;&#125; 指定某一软件打开对应的文件1234Runtime.getRuntime() .exec(\"WINWORD.EXE（使用啥软件打开）所在全路径 D:\\\\test.docx（文件全路径）\");//例：\"C:\\\\Program Files\\\\Microsoft Office\\\\root\\\\Office16\\\\WINWORD.EXE D:\\\\3.pdf\"","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"Desktop","slug":"Desktop","permalink":"/tags/Desktop/"}]},{"title":"pip的使用技巧","slug":"pip的使用技巧","date":"2019-01-12T06:57:20.000Z","updated":"2019-01-12T08:08:22.305Z","comments":true,"path":"2019/01/12/pip的使用技巧/","link":"","permalink":"/2019/01/12/pip的使用技巧/","excerpt":"","text":"如何使用pip安装特定版本的python第三方包python的包管理器pip特别好用，我们可以使用它来方便的安装第三方包，但是怎样使用pip来安装特定版本的第三方包呢？ 安装好python后，包管理器pip就已经安装好了，在终端中输入pip就可以查阅到pip一些常用用法，如： 12pip install package#这里package即为第三方包的名称，如tensorflow，使用这种安装方式会安装最新版本的包 12pip uninstall package#卸载包 12pip list#列举出当前环境安装的所有包 12pip show package#显示所安装包的信息 12pip install package==version#package：包名；version：版本号。如pip install tensorflow-gpu==1.12.0即是安装1.12.0版本的gpu版本的tensorflow 多版本Python共存时pip给指定版本的python安装package的方法在linux安装了多版本python时（例如python2.7和3.4），pip安装的包不一定是用户想要的位置，此时可以用 -t 选项来指定位置 查看pip指向123pip -V# 输出：pip 9.0.1 from /usr/lib/python2.7/site-packages/pip-9.0.1-py2.7.egg (python 2.7)# 发现指向python 2.7 所以我们的问题变成了怎么通过pip去指定安装到Python3.4下 解决方案 更改pip3指向（推荐） 这种方法可以一劳永逸地让之后的pip3安装都顺利一点 1234567891011121314151617181920212223242526272829303132331.查看pip在哪which pip# 输出：/usr/bin/pip2.查看python在哪which python# 输出：/usr/bin/python3.查看python3在哪which python3# 输出：/usr/local/bin/python34.编辑pip所在文件vim /usr/bin/pip# 我们可以看到如下：-----------------------------pip--------------------------------#!/usr/bin/python# EASY-INSTALL-ENTRY-SCRIPT: 'pip==9.0.1','console_scripts','pip'__requires__ = 'pip==9.0.1'import reimport sysfrom pkg_resources import load_entry_pointif __name__ == '__main__': sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0]) sys.exit( load_entry_point('pip==9.0.1', 'console_scripts', 'pip')() )-----------------------------pip-end----------------------------将第一行 #!/usr/bin/python 修改为#!/usr/local/bin/python3然后pip就指向python2了 强制安装到Python3.4环境下 1python3 -m pip install tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl 这样就可以指定安装到python3下了，不过用这种方法的话每次要安装都得这么做，不过因为我是在别人服务器上做，不好随便更改，因此采用这种方式。 用 -t 选项来指定安装位置 例如目标位置是/usr/local/lib/python3.4/site-packages/ ，要安装tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl这个包，则： 1pip install -t /usr/local/lib/python3.4/site-packages/ tensorflow-1.8.0-cp34-cp34m-manylinux1_x86_64.whl 这一种方式安装一般会报Command &quot;python setup.py egg_info&quot; failed with error code 1这个错 。解决方案（经验）： 12python -m pip install --upgrade --force pip pip install setuptools==33.1.1","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"pip","slug":"pip","permalink":"/tags/pip/"}]},{"title":"Hibernate中更新非空域","slug":"Hibernate中更新非空域","date":"2019-01-10T01:27:16.000Z","updated":"2019-01-10T08:14:58.225Z","comments":true,"path":"2019/01/10/Hibernate中更新非空域/","link":"","permalink":"/2019/01/10/Hibernate中更新非空域/","excerpt":"","text":"Hibernate中更新非空域；传入一个对象，这个对象中有的域可能是null，但是我并不想覆盖原来的数据库中的有值的域。 我的实现方法： 12345678910111213141516171819202122232425262728public class BeanUtil &#123; /** * 复制src对象的非空属性值到target中 * @param src * @param target */ public static void copyNonNullProperties(Object src, Object target) &#123; BeanUtils.copyProperties(src, target, getNullPropertyNames(src)); &#125; /** * 获取对象中属性为空的属性 * @param source * @return */ public static String[] getNullPropertyNames (Object source) &#123; final BeanWrapper src = new BeanWrapperImpl(source); PropertyDescriptor[] pds = src.getPropertyDescriptors(); Set&lt;String&gt; emptyNames = new HashSet&lt;&gt;(); for(PropertyDescriptor pd : pds) &#123; Object srcValue = src.getPropertyValue(pd.getName()); if (srcValue == null) emptyNames.add(pd.getName()); &#125; String[] result = new String[emptyNames.size()]; return emptyNames.toArray(result); &#125;&#125; 如何调用： 123456实体类1：src （前端传来的数据）实体类1：existing （通过前端传来数据的id获取得到数据库表里的数据）//用src中不为空的属性替换existing中对应的属性copyNonNullProperties(src,existing);//调用hibernate的关系更新方法iModelConfigDAO.update(existing); iModelConfigDAO的实现类说明： 123456789101112public class ModelConfigDAOImpl implements IModelConfigDAO&#123; @Resource private SessionFactory sessionFactory; private Session getSession() &#123; return sessionFactory.getCurrentSession(); &#125; public void update(ModelConfig modelConfig) &#123; this.getSession().update(modelConfig); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"/tags/Hibernate/"}]},{"title":"ubuntu 18.04.1 开机启动脚本","slug":"ubuntu-18-04-1-开机启动脚本","date":"2019-01-07T08:18:31.000Z","updated":"2019-01-30T09:23:28.061Z","comments":true,"path":"2019/01/07/ubuntu-18-04-1-开机启动脚本/","link":"","permalink":"/2019/01/07/ubuntu-18-04-1-开机启动脚本/","excerpt":"","text":"ubuntu 18.04.1 开机启动脚本ubuntu18.04不再使用initd管理系统，改用systemd。个人觉得systemd很难用，改变太大，跟之前的完全不同 为了像以前一样，在/etc/rc.local中设置开机启动程序，需要以下几步： systemd默认读取/etc/systemd/system下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。一般系统安装完/lib/systemd/system/下会有rc-local.service文件，即我们需要的配置文件。 链接过来： 1ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service 打开脚本内容： 1cat /etc/systemd/system/rc-local.service 1234567891011121314151617181920212223# SPDX-License-Identifier: LGPL-2.1+## This file is part of systemd.## systemd is free software; you can redistribute it and/or modify it# under the terms of the GNU Lesser General Public License as published by# the Free Software Foundation; either version 2.1 of the License, or# (at your option) any later version.# This unit gets pulled automatically into multi-user.target by# systemd-rc-local-generator if /etc/rc.local is executable.[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no 一般正常的启动文件主要分成三部分： [Unit] 段: 启动顺序与依赖关系 [Service] 段: 启动行为,如何启动，启动类型[Install] 段: 定义如何安装这个配置文件，即怎样做到开机启动 可以看出，/etc/rc.local 的启动顺序是在网络后面，但是显然它少了 Install 段，也就没有定义如何做到开机启动，所以显然这样配置是无效的。 因此我们就需要在后面帮他加上 [Install] 段: 123[Install] WantedBy=multi-user.target Alias=rc-local.service 这里需要注意一下，ubuntu-18.04 默认是没有 /etc/rc.local 这个文件的，需要自己创建 创建/etc/rc.local文件（有的话不用再创建了） 1touch /etc/rc.local 赋可执行权限 1chmod 755 /etc/rc.local 编辑rc.local，添加需要开机启动的任务 12345678910111213141516171819#!/bin/sh -e# # rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will \"exit 0\" on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.########################手动添加的命令########################echo \"this is a test\" &gt; /usr/local/text.logsudo vncserver######################手动添加的命令-end######################exit 0 其中sudo vncserver就是需要开机启动的任务（注意：sudo写上有益无害，避免不必要的麻烦） echo &quot;this is a test&quot; &gt; /usr/local/text.log是测试开机脚本是否生效用的 执行reboot重启系统（查看 /usr/local/text.log 文件是否存在就知道开机脚本是否生效了） ubuntu - 一般情况开机启动脚本借鉴于此博客 先写一个脚本，里面写上执行要执行的命令，再使用update-rc.d 脚本名 defaults命令将改脚本添加到系统启动任务 12cd /etc/init.dvim tale 12345678910111213#!/bin/bash#program#先将jdk的环境准备好export JAVA_HOME=/usr/local/jdk1.8export JRE=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE/lib:.export PATH=$PATH:$JAVA_HOME/bin/:$JRE/bin#执行命令nohup java -jar /home/veir/tale/tale-least.jar &gt;/home/veir/tale/logs/tale.log &amp;exit 0 保存后，给脚本添加可执行权限 1chmod +x tale 添加开机启动服务 12update-rc.d tale defaults#defaults后面可以加一个数字，例如99，它表明一个优先级，越高表示执行的越晚 有一个需要注意，很多命令的执行需要一个系统的环境，例如上面的java -jar xxx就需要jdk的环境支持，然后很有可能，系统在执行此脚本时，jdk的环境还没有加载进来，所以就需要手动在该脚本中声明需要的环境 修改/etc/rc.local脚本/etc/rc.local是Linux系统启动后自动执行的一个脚本，默认情况下这个脚本里面没有任务。修改这个脚本可以启动你自己的应用。 修改方式很简单，在最后一行exit 0之前加上开启服务或应用的命令就好了 1vim /etc/rc.local 得到视图如下： 12345678910111213141516171819#!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will \"exit 0\" on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.########################手动添加的命令######################### 启动xampp-可道云可访问sudo /opt/lampp/lampp start######################手动添加的命令-end######################exit 0 centos/redhat - 一般情况开机启动脚本先写一个脚本，里面写上执行要执行的命令，再使用update-rc.d 脚本名 defaults命令将改脚本添加到系统启动任务 12cd /etc/init.dvim lampp.sh 1234#!/bin/bash# 启动xampp-可道云可访问sudo /opt/lampp/lampp start su -c ‘/etc/init.d/lampp.sh’ 保存后，给脚本添加可执行权限 1chmod +x lampp.sh 打开/etc/rc.d/rc.local或/etc/rc.local文件，在末尾增加/etc/init.d/lampp.sh 12345678910111213141516#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.########################手动添加的命令######################### 启动xampp-可道云可访问/etc/init.d/lampp.sh######################手动添加的命令-end###################### 在centos7(不仅仅)中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限 1chmod +x /etc/rc.d/rc.local 修改/etc/rc.local脚本/etc/rc.local是Linux系统启动后自动执行的一个脚本，默认情况下这个脚本里面没有任务。修改这个脚本可以启动你自己的应用。 修改方式很简单，在最后加上开启服务或应用的命令就好了 1vim /etc/rc.local 得到视图如下： 12345678910111213141516#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.########################手动添加的命令######################### 启动xampp-可道云可访问sudo /opt/lampp/lampp start######################手动添加的命令-end###################### 可在以上视图中发现有一句# Please note that you must run &#39;chmod +x /etc/rc.d/rc.local&#39; to ensure中文翻译请注意，您必须运行“chmod +x /etc/rc.d/rc.才能确保成功 - 意思很明显了！ 1chmod +x /etc/rc.d/rc.local","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"/tags/CentOS/"},{"name":"RedHat","slug":"RedHat","permalink":"/tags/RedHat/"},{"name":"开机启动","slug":"开机启动","permalink":"/tags/开机启动/"}]},{"title":"文件打包-解压-下载","slug":"文件打包-解压-下载","date":"2018-12-28T03:07:17.000Z","updated":"2019-03-13T07:36:49.686Z","comments":true,"path":"2018/12/28/文件打包-解压-下载/","link":"","permalink":"/2018/12/28/文件打包-解压-下载/","excerpt":"","text":"文件打包123456789101112131415161718192021222324252627282930313233/** * 文件打包 * 将传递过来的文件列表写入zip文件 * @param fileList 要打包的文件 * @param zipFileName 打包后的文件名 * @throws IOException */public static void downZipManyFile(List&lt;File&gt; fileList, String zipFileName) throws IOException &#123; BufferedInputStream br = null;//输入流 ZipOutputStream out = null; // 压缩文件输出流 ZipEntry zip = null; //用于表示 ZIP 文件条目。 int size =-1; byte[] buffer = new byte[2048];// 定义缓冲区 if(fileList.size()&gt;0)&#123; out = new ZipOutputStream(new FileOutputStream(zipFileName)); for (int i = 0; i &lt; fileList.size(); i++) &#123; File f =fileList.get(i); zip = new ZipEntry(f.getName()); out.putNextEntry(zip); br = new BufferedInputStream(new FileInputStream(f)); while((size=br.read(buffer))!=-1)&#123; out.write(buffer,0,size); out.flush(); &#125; &#125; zip.clone(); br.close(); out.close(); &#125;&#125; 多种压缩文件解压包含实现对.zip、.rar、.7z、.tar、.tar.gz的解压 Maven 1234567891011121314151617181920&lt;!-- .7z --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding-all-platforms&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .7z end --&gt; &lt;!-- .tar/.tar.gz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.10.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .tar/.tar.gz end --&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337/*功能：多种格式压缩文件解压(.zip、.rar、.7z、.tar、.tar.gz)*///使用gbk编码避免zip解压中文文件名乱码private static final String CHINESE_CHARSET = \"gbk\";//文件读取缓冲区大小private static final int CACHE_SIZE = 1024;//系统类型private static final String WINDOWS=\"windows\";private static final String LINUX=\"linux\";/** * 多种格式压缩文件解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void deCompress(String srcFileName, String destDir)&#123; //存储路径不存在则创建 File dFile=new File(destDir); if (!dFile.exists()) &#123; dFile.mkdirs(); &#125; if (srcFileName.toLowerCase().endsWith(\".zip\")) &#123; unZip(srcFileName, destDir); &#125; else if (srcFileName.toLowerCase().endsWith(\".rar\")) &#123; unRar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".7z\")) &#123; un7Z(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar\")) &#123; unTar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar.gz\")) &#123; unTarGz(srcFileName, destDir); &#125;&#125;/** * .zip格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unZip(String srcFileName, String destDir) &#123; try &#123; //解决中文乱码 ZipFile zip = new ZipFile(srcFileName, Charset.forName(CHINESE_CHARSET)); //循环遍历 for (Enumeration&lt;? extends ZipEntry&gt; entries = zip.entries(); entries.hasMoreElements();) &#123; ZipEntry entry = entries.nextElement(); String zipEntryName = entry.getName(); InputStream in = zip.getInputStream(entry); String outPath = (destDir +\"/\"+ zipEntryName).replaceAll(\"\\\\*\", \"/\"); // 判断路径是否存在,不存在则创建文件路径 File file = new File(outPath.substring(0, outPath.lastIndexOf('/'))); if (!file.exists()) &#123; file.mkdirs(); &#125; // 判断文件全路径是否为文件夹,如果是上面已经上传,不需要解压 if (new File(outPath).isDirectory()) &#123; continue; &#125; FileOutputStream out = new FileOutputStream(outPath); byte[] buf = new byte[CACHE_SIZE]; int len; while ((len = in.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; in.close(); out.close(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;/** * .rar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unRar(String srcFileName, String destDir)&#123; String cmd = null; String unRarCmd = null; try &#123; if (systemType().equals(WINDOWS)) &#123; //解压模板命令 unRarCmd = \"F:\\\\Program Files (x86)\\\\WinRAR\\\\WinRAR.exe x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; else if (systemType().equals(LINUX)) &#123; //解压模板命令 unRarCmd = \"unrar x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; //构造运行对象 Runtime rt = Runtime.getRuntime(); //在单独的进程中执行指定的字符串命令。 rt.exec(cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * .7z格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void un7Z(String srcFileName, String destDir)&#123; RandomAccessFile randomAccessFile = null; IInArchive inArchive = null; try &#123; randomAccessFile = new RandomAccessFile(srcFileName, \"r\"); inArchive = SevenZip. openInArchive(null,new RandomAccessFileInStream(randomAccessFile)); ISimpleInArchive simpleInArchive = inArchive.getSimpleInterface(); //遍历 for (ISimpleInArchiveItem item : simpleInArchive.getArchiveItems()) &#123; int[] hash = new int[] &#123; 0 &#125;; if (!item.isFolder()) &#123; ExtractOperationResult result; long[] sizeArray = new long[1]; //tarFile是遍历的每一个文件 File tarFile=new File(destDir+File.separator+item.getPath()); //tarFile父目录不存在，则创建 if (!tarFile.getParentFile().exists()) &#123; tarFile.getParentFile().mkdirs(); &#125; //创建tarFile文件 tarFile.createNewFile(); result = item.extractSlow(new ISequentialOutStream() &#123; public int write(byte[] data) throws SevenZipException &#123; FileOutputStream fos=null; try &#123; fos = new FileOutputStream(tarFile.getAbsolutePath()); //将数据写入fos fos.write(data); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; hash[0] ^= Arrays.hashCode(data); sizeArray[0] += data.length; return data.length; &#125; &#125;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; finally &#123; if (inArchive != null) &#123; try &#123; inArchive.close(); &#125; catch (SevenZipException e) &#123; e.printStackTrace(); &#125; &#125; if (randomAccessFile != null) &#123; try &#123; randomAccessFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * .tar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTar(String srcFileName, String destDir)&#123; FileInputStream fis = null; OutputStream fos = null; TarInputStream tarInputStream = null; try &#123; fis = new FileInputStream(new File(srcFileName)); tarInputStream = new TarInputStream(fis, CACHE_SIZE); TarEntry entry = null; while(true)&#123; entry = tarInputStream.getNextEntry(); if( entry == null)&#123; break; &#125; if(entry.isDirectory())&#123; System.out.println(entry.getName()); createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; fos = new FileOutputStream(new File(destDir + File.separator + entry.getName())); int count; byte data[] = new byte[CACHE_SIZE]; while ((count = tarInputStream.read(data)) != -1) &#123; fos.write(data, 0, count); &#125; fos.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fis != null)&#123; fis.close(); &#125; if(fos != null)&#123; fos.close(); &#125; if(tarInputStream != null)&#123; tarInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * .tar.gz解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTarGz(String srcFileName, String destDir)&#123; FileInputStream fileInputStream = null; BufferedInputStream bufferedInputStream = null; GZIPInputStream gzipIn = null; TarInputStream tarIn = null; OutputStream out = null; try &#123; fileInputStream = new FileInputStream(new File(srcFileName)); bufferedInputStream = new BufferedInputStream(fileInputStream); gzipIn = new GZIPInputStream(bufferedInputStream); tarIn = new TarInputStream(gzipIn, CACHE_SIZE); TarEntry entry = null; while((entry = tarIn.getNextEntry()) != null)&#123; if(entry.isDirectory())&#123; // 是目录 createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; // 是文件 File tempFIle = new File(destDir + File.separator + entry.getName()); createDirectory(tempFIle.getParent() + File.separator, null); out = new FileOutputStream(tempFIle); int len =0; byte[] b = new byte[CACHE_SIZE]; while ((len = tarIn.read(b)) != -1)&#123; out.write(b, 0, len); &#125; out.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(out != null)&#123; out.close(); &#125; if(tarIn != null)&#123; tarIn.close(); &#125; if(gzipIn != null)&#123; gzipIn.close(); &#125; if(bufferedInputStream != null)&#123; bufferedInputStream.close(); &#125; if(fileInputStream != null)&#123; fileInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * 构建目录 * @param outputDir 输出目录 * @param subDir 子目录 */private static void createDirectory(String outputDir, String subDir)&#123; File file = new File(outputDir); if(!(subDir == null || subDir.trim().equals(\"\"))) &#123;//子目录不为空 file = new File(outputDir + File.separator + subDir); &#125; if(!file.exists())&#123; if(!file.getParentFile().exists())&#123; file.getParentFile().mkdirs(); &#125; file.mkdirs(); &#125;&#125;/** * 判断程序运行在什么系统上 * @return 系统类型 */public static String systemType() &#123; Properties properties = System.getProperties(); String os = properties.getProperty(\"os.name\"); if (os != null &amp;&amp; os.toLowerCase().contains(WINDOWS))&#123; return WINDOWS; &#125;else if (os != null &amp;&amp; os.toLowerCase().contains(LINUX))&#123; return LINUX; &#125; return null;&#125;public static void main(String[] args) &#123; //deCompress(\"E:/Test/Test01.zip\",\"E:/Test/testZip\"); //deCompress(\"E:/Test/Test02.rar\",\"E:/Test/testRar\"); //deCompress(\"E:/Test/Test03.7z\",\"E:/Test/test7z\"); //deCompress(\"E:/Test/Test04.tar\",\"E:/Test/testTar\"); //deCompress(\"E:/Test/apache-tomcat-9.0.13-src.tar.gz\",\"E:/Test/testTarGz\");&#125; 从服务器下载文件下载已经打包好的文件123456789101112131415161718192021222324252627282930313233343536/** * 文件下载 * @param zipFileName zip文件全路径（含文件名） * @param response * @param isDelete 是否将生成的服务器端文件删除 * @return */public ReturnT&lt;?&gt; downloadFile(String zipFileName, HttpServletResponse response, boolean isDelete) &#123; try &#123; File file=new File(zipFileName); // 以流的形式下载文件。 BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file.getPath())); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); response.setContentType(\"application/octet-stream\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + new String(file.getName().getBytes(\"UTF-8\"),\"ISO-8859-1\")); toClient.write(buffer); toClient.flush(); toClient.close(); if(isDelete) &#123; //将生成的服务器端文件删除 file.delete(); &#125; return new ReturnT(HttpStatus.OK, \"下载成功\", null); &#125; catch (Exception e) &#123; logger.error(\"下载失败\",e); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125;&#125; 变打包边下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 下载-边打包边下载 * @param downloadName 压缩包的名字 * @param fileList 所有需要下载的文件列表 * @param request * @param response * @return */@Overridepublic ReturnT&lt;?&gt; downloadFile(String downloadName, List&lt;File&gt; fileList, HttpServletRequest request, HttpServletResponse response) &#123; //响应头的设置 response.reset(); response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"multipart/form-data\"); //设置压缩包的名字 //解决不同浏览器压缩包名字含有中文时乱码的问题 String agent = request.getHeader(\"USER-AGENT\"); try &#123; if (agent.contains(\"MSIE\")||agent.contains(\"Trident\")) &#123; downloadName = java.net.URLEncoder.encode(downloadName, \"UTF-8\"); &#125; else &#123; downloadName = new String(downloadName.getBytes(\"UTF-8\"),\"ISO-8859-1\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; response.setHeader(\"Content-Disposition\", \"attachment;fileName=\\\"\" + downloadName + \"\\\"\"); //设置压缩流：直接写入response，实现边压缩边下载 ZipOutputStream zipos = null; try &#123; zipos = new ZipOutputStream( new BufferedOutputStream(response.getOutputStream())); zipos.setMethod(ZipOutputStream.DEFLATED); //设置压缩方法 &#125; catch (Exception e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; //循环将文件写入压缩流 DataOutputStream os = null; for(int i = 0; i &lt; fileList.size(); i++ )&#123; File file = fileList.get(i); try &#123; //添加ZipEntry，并ZipEntry中写入文件流 //这里，加上i是防止要下载的文件有重名的导致下载失败 zipos.putNextEntry(new ZipEntry(i + file.getName())); os = new DataOutputStream(zipos); InputStream is = new FileInputStream(file); byte[] b = new byte[100]; int length = 0; while((length = is.read(b))!= -1)&#123; os.write(b, 0, length); &#125; is.close(); zipos.closeEntry(); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; &#125; //关闭流 try &#123; os.flush(); os.close(); zipos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ReturnT(HttpStatus.NOT_FOUND, \"下载失败\", null); &#125; return new ReturnT(HttpStatus.OK, \"下载成功\", null);&#125; 其它文件操作获取单个文件的所有内容123456789101112131415161718192021222324/** * 获取单个文件的所有内容 * @param fileName 文件全路径 * @return */public static String readToString(String fileName) &#123; try &#123; File file = new File(fileName); Long filelength = file.length(); byte[] filecontent = new byte[filelength.intValue()]; FileInputStream in = new FileInputStream(file); in.read(filecontent); in.close(); return new String(filecontent, encoding); &#125; catch (FileNotFoundException e) &#123; logger.error(\"该文件不存在或路径错误\",e); e.printStackTrace(); return null; &#125; catch (IOException e) &#123; logger.error(\"读取文件出错\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的文件名列表(全路径)123456789101112131415161718192021222324252627282930/** * 获取多个文件文件列表(全路径) * @param fileDir 文件夹路径 * @param picturePath 图片相对路径 * @param request * @return 返回带域名的文件路径 */public static List&lt;String&gt; readToListPath(String fileDir, String picturePath, HttpServletRequest request) &#123; //获取带部署环境上下文的域名 StringBuffer url = request.getRequestURL(); String tempContextUrl = url .delete(url.length() - request.getRequestURI().length(), url.length()) .append(request.getContextPath()).toString(); List&lt;String&gt; fileNameList = new ArrayList&lt;&gt;(); try &#123; List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); if (fileList.size()==0)&#123; return fileNameList; &#125; for (File f1 : fileList) &#123; fileNameList.add(tempContextUrl+picturePath+\"/\"+f1.getName()); &#125; return fileNameList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件文件列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的内容列表123456789101112131415161718192021/** * 获取多个文件内容列表 * @param fileDir 文件所在路径 * @return */public static List&lt;String&gt; readToListAndString(String fileDir)&#123; try &#123; List&lt;String&gt; fileContentList = new ArrayList&lt;&gt;(); List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); for (File file : fileList)&#123; if(!readToString(file.toString()).equals(\"\"))&#123; fileContentList.add(readToString(file.toString())); &#125; &#125; return fileContentList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件内容列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 递归获取目录下的所有文件123456789101112131415161718192021222324252627282930/** * 递归获取目录下的所有文件 * @param fileDir 文件所在路径 * @return */public static List&lt;File&gt; getFilePath(String fileDir,String endsWith)&#123; List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); File file = new File(fileDir); File[] files = file.listFiles();// 获取目录下的所有文件或文件夹 if (files == null) &#123;// 如果目录为空，返回空 return null; &#125; // 遍历，目录下的所有文件 for (File f : files) &#123; if (f.isFile()) &#123; if(endsWith.equals(\"\")||endsWith==null)&#123; fileList.add(f); &#125;else &#123; if (f.getName().endsWith(endsWith))&#123; fileList.add(f); &#125; &#125; &#125; else if (f.isDirectory()) &#123; getFilePath(f.getAbsolutePath(),endsWith); &#125; &#125; return fileList;&#125; 递归删除文件（删除文件夹）12345678910111213141516171819/** * 递归删除目录下的所有文件及子目录下所有文件 * @param dir 目录路径 * @return */public static boolean deleteDir(File dir) &#123; if (dir.isDirectory()) &#123; String[] children = dir.list(); //递归删除目录中的子目录下 for (int i=0; i&lt;children.length; i++) &#123; boolean success = deleteDir(new File(dir, children[i])); if (!success) &#123; return false; &#125; &#125; &#125; // 目录此时为空或者是文件，可以删除 return dir.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"文件打包","slug":"文件打包","permalink":"/tags/文件打包/"},{"name":"压缩文件解压","slug":"压缩文件解压","permalink":"/tags/压缩文件解压/"}]},{"title":"linux环境下安装 openOffice 并启动服务","slug":"linux环境下安装-openOffice-并启动服务","date":"2018-12-25T02:07:07.000Z","updated":"2019-01-10T08:06:15.269Z","comments":true,"path":"2018/12/25/linux环境下安装-openOffice-并启动服务/","link":"","permalink":"/2018/12/25/linux环境下安装-openOffice-并启动服务/","excerpt":"","text":"背景故事这两天遇到一个大坑，客户要做office 文档在线预览功能，于是乎就要把office文档转换成pdf交给前端显示。 在某度找了一圈都说openOffice+jodconverter 可以搞定这个事情。代码倒是很好找，不过版本很多，各类jar包也很多，但尝试下来发现，转化效果很一般，复杂的excel也无法成功。有同事建议放到服务器上效果可能好些，于是就开始折腾在服务器上安装OpenOffice这个事情。网上各种找大神的博文，发现安装起来不是很顺畅，就写了这篇随笔，记录一下，遇到的问题，方便自己以后查看。 ​ openOffice转转word文档效果不错，转Excel的话就真的效果不行，简单的Excel能处理处理，复杂的就很慢很慢，而且效果极差。再说，实际上微软自己的office软件转pdf的效果也很差。 操作步骤 http://www.openoffice.org/zh-cn/download/ 去官网链接下载linux版本的openOffice 以4.1.6 版本为例。 将压缩包上传至服务器上，并进行解压安装。 12345tar -zxvf 对应的压缩包名字cd 进入解压后的 /zh-cn/RPMSyum localinstall *.rpmcd desktop-integrationrpm -ivh openoffice4.1.6-redhat-menus-4.1.6-9789.noarch.rpm 默认会安装在/opt目录下。 启动服务 123/opt/openoffice4/program/soffice -headless -accept=\"socket,host=127.0.0.1,port=8100;urp;\" -nofirststartwizard 临时启动nohup /opt/openoffice4/program/soffice -headless -accept=\"socket,host=127.0.0.1,port=8100;urp;\" -nofirststartwizard &amp; 后台启动 端口号根据自己项目实际来确定。 后台启动会一直占用内存，据各路大神说 大概100M，我自己没测过具体值不清楚。 有的程序是需要预先启动openOffice 服务的，有的则在代码里自己启动服务。 .查看进程 1netstat -lnp |grep 端口号 大概显示成这样就算启动完了。 1tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 14362/soffice.bin 问题装完openoffice后启动服务可能会报错：no suitable windowing system found, exiting 从字面上的意思就是缺少一个窗口化的系统。所以就安装一个。 1yum groupinstall \"X Window System\"","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"openOffice","slug":"openOffice","permalink":"/tags/openOffice/"},{"name":"安装","slug":"安装","permalink":"/tags/安装/"}]},{"title":"将Word(.doc)里的图片替换成文本","slug":"将Word-doc-里的图片替换成文本","date":"2018-12-20T03:23:24.000Z","updated":"2018-12-29T03:04:42.141Z","comments":true,"path":"2018/12/20/将Word-doc-里的图片替换成文本/","link":"","permalink":"/2018/12/20/将Word-doc-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖1234567891011121314151617181920212223242526&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt;&lt;!-- Jsoup-用以解析HTML --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Jsoup-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195public static void main(String argv[]) &#123; try &#123; //源文件全路径 String oldFileName = \"D:/Test/ml/test.doc\"; //目标文件全路径 String newFileName = \"D:/Test/ml/html_to_word.doc\"; //构造HTML生成全路径 String temporary = new File(oldFileName).getParent()+File.separator+\"temporary.html\"; //读取DOC生成获得html内容和图片集 Map&lt;String,Object&gt; map = convert2Html(oldFileName); //取得图片集 List&lt;String&gt; listPics = (List&lt;String&gt;) map.get(\"listPics\"); //取得生成的html内容 String htmlContent = (String) map.get(\"htmlContent\"); for (String pic : listPics)&#123; //有后缀名的图片才进行识别 if (pic.lastIndexOf(\".\") != -1)&#123; //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //文字替换图片 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;\"); &#125;else &#123;/*因为识别出来的非图片格式（即：无后缀名）的图片再放回doc时会出现 图片异常显示，所以以\"&lt;span&gt;&lt;/span&gt;\"进行占位*/ //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //占位 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&lt;/span&gt;\"); &#125; &#125; //输出HTML文件 writeFile(htmlContent, temporary); //HTML转Doc html2Doc(temporary,newFileName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 输出HTML文件 * @param content 从doc读取生成的html文本 * @param path 目标文件全路径 */public static void writeFile(String content, String path) &#123; FileOutputStream fos = null; BufferedWriter bw = null; org.jsoup.nodes.Document doc = Jsoup.parse(content); String styleOld=doc.getElementsByTag(\"style\").html(); //统一字体格式为宋体 styleOld=styleOld.replaceAll(\"font-family:.+(?=;\\\\b)\", \"font-family:SimSun\"); doc.getElementsByTag(\"head\").empty(); doc.getElementsByTag(\"head\") .append(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); doc.getElementsByTag(\"head\") .append(\" &lt;style type=\\\"text/css\\\"&gt;&lt;/style&gt;\"); doc.getElementsByTag(\"style\") .append(styleOld); /*正则表达式查询字体内容：font-family:.+(?=;\\b)*/ content=doc.html(); content=content .replace(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;\", \"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); try &#123; File file = new File(path); fos = new FileOutputStream(file); bw = new BufferedWriter(new OutputStreamWriter(fos,\"UTF-8\")); bw.write(content); &#125; catch (FileNotFoundException fnfe) &#123; fnfe.printStackTrace(); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; finally &#123; try &#123; if (bw != null) bw.close(); if (fos != null) fos.close(); &#125; catch (IOException ie) &#123; &#125; &#125;&#125;/** * 读取DOC生成获得html内容和图片集 * @param fileName 源文件全路径 * @return 返回的map中包含html内容和图片集 * @throws Exception */public static Map&lt;String,Object&gt; convert2Html(String fileName) throws Exception &#123; //存放html内容和图片集 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //保存图片集 List&lt;String&gt; listPics = new ArrayList&lt;&gt;(); //构造提取出来的图片保存路径以及HTML中&lt;img&gt;的图片源路径 String imgPath = new File(fileName).getParent()+ File.separator+\"img\"+File.separator; File file = new File(imgPath); //不存在，则创建 if (!file.exists())&#123; file.mkdirs(); &#125; HWPFDocument wordDocument = new HWPFDocument(new FileInputStream(fileName)); //WordToHtmlUtils.loadDoc(new FileInputStream(inputFile)); WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter( DocumentBuilderFactory.newInstance().newDocumentBuilder() .newDocument()); wordToHtmlConverter.setPicturesManager( new PicturesManager() &#123; public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches ) &#123; return imgPath.replace(\"\\\\\",\"/\") + suggestedName; &#125; &#125; ); wordToHtmlConverter.processDocument(wordDocument); //保存图片 List pics=wordDocument.getPicturesTable().getAllPictures(); if(pics!=null)&#123; for(int i=0;i&lt;pics.size();i++)&#123; Picture pic = (Picture)pics.get(i); try &#123; String picAbsolutePath = imgPath + pic.suggestFullFileName(); //将图片全路径存入listPics listPics.add(picAbsolutePath); pic.writeImageContent(new FileOutputStream(picAbsolutePath)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Document htmlDocument = wordToHtmlConverter.getDocument(); ByteArrayOutputStream out = new ByteArrayOutputStream(); DOMSource domSource = new DOMSource(htmlDocument); StreamResult streamResult = new StreamResult(out); TransformerFactory tf = TransformerFactory.newInstance(); Transformer serializer = tf.newTransformer(); serializer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); serializer.setOutputProperty(OutputKeys.INDENT, \"yes\"); serializer.setOutputProperty(OutputKeys.METHOD, \"HTML\"); serializer.transform(domSource, streamResult); out.close(); String htmlContent=new String(out.toByteArray()); //替换UEditor无法识别的转义字符 htmlContent=htmlContent.replaceAll(\"&amp;ldquo;\",\"\\\"\").replaceAll(\"&amp;rdquo;\",\"\\\"\") .replaceAll(\"&amp;mdash;\",\"-\"); map.put(\"htmlContent\",htmlContent); map.put(\"listPics\",listPics); return map;&#125;/** * html转doc * @param source * @param target * @throws Exception */public static void html2Doc(String source , String target) throws Exception &#123; //创建 POIFSFileSystem 对象 POIFSFileSystem poifs = new POIFSFileSystem(); //获取DirectoryEntry DirectoryEntry directory = poifs.getRoot(); //创建输出流 OutputStream out = new FileOutputStream(target); try &#123; //创建文档,1.格式\"WordDocument\",2.HTML文件输入流 directory.createDocument(\"WordDocument\", new FileInputStream(source)); //写入 poifs.writeFilesystem(out); //释放资源 out.close(); System.out.println(\"success\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"},{"name":"Jsoup","slug":"Jsoup","permalink":"/tags/Jsoup/"}]},{"title":"OpenOffice-实现文件格式之间的转换.md","slug":"OpenOffice-实现文件格式之间的转换","date":"2018-12-18T11:10:47.000Z","updated":"2018-12-18T12:50:46.786Z","comments":true,"path":"2018/12/18/OpenOffice-实现文件格式之间的转换/","link":"","permalink":"/2018/12/18/OpenOffice-实现文件格式之间的转换/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iTextPDF-实现向PDF追加内容","slug":"iTextPDF-实现向PDF追加内容","date":"2018-12-18T11:10:03.000Z","updated":"2018-12-18T12:49:51.129Z","comments":true,"path":"2018/12/18/iTextPDF-实现向PDF追加内容/","link":"","permalink":"/2018/12/18/iTextPDF-实现向PDF追加内容/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"将Word(.docx)-里的图片替换成文本","slug":"将Word-docx-里的图片替换成文本","date":"2018-12-18T11:08:31.000Z","updated":"2018-12-25T03:01:54.817Z","comments":true,"path":"2018/12/18/将Word-docx-里的图片替换成文本/","link":"","permalink":"/2018/12/18/将Word-docx-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖12345678910111213141516171819&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public static void main(String[] args) throws Exception &#123; textReplacePhoto(\"D:\\\\Test\\\\原报格式样例3.docx\", \"D:\\\\Test\\\\原报格式样例3-1.docx\",\"D:/Test/img\");&#125;/** * 将word里的图片全部替换成文本 * @param oldFileName 传入原文件的全路径（含文件名） * @param newFileName 保存修改后文件的全路径（含文件名） * @param picturePath 读取出来的图片保存路径 * @throws Exception */public static void textReplacePhoto(String oldFileName, String newFileName, String picturePath) throws Exception &#123; File newFile = new File(newFileName.replace(new File(newFileName).getName(),\"\")); //保存路径不存在，则创建 if (!newFile.exists())&#123; newFile.mkdirs(); &#125; if (oldFileName.endsWith(\".docx\"))&#123; //.docx文件的处理方法 //为了确定图片集中的某一张图片 int imgNum=0; //创建输入流 InputStream oldIs = new FileInputStream(oldFileName); //创建输出流 OutputStream newOs = new FileOutputStream(newFileName); //创建一个XWPFDocument XWPFDocument docx = new XWPFDocument(oldIs); //获取到该文档的所有段落集 List&lt;XWPFParagraph&gt; paras = docx.getParagraphs(); //获取到该文档的所有图片集 List&lt;XWPFPictureData&gt; pictures = docx.getAllPictures(); for (XWPFParagraph para:paras)&#123; //段落中所有XWPFRun List&lt;XWPFRun&gt; runList = para.getRuns(); for (int i=0;i&lt;runList.size();i++) &#123; XWPFRun run=runList.get(i); //判断该段落是否是图片 if (!run.getEmbeddedPictures().isEmpty())&#123; //存储读取到的图片,并获取图片全路径 String pictureName=savePictureDocx(pictures,picturePath,imgNum++); //实际有图片才进行以下操作 if (pictureName!=null)&#123; //删除图片 para.removeRun(i); //插入文字 para.insertNewRun(i).setText(\"&#123;&#123;title&#125;&#125;\"); //删除图片 deletePicture(pictureName); &#125; &#125; &#125; &#125; docx.write(newOs); docx.close(); oldIs.close(); newOs.flush(); newOs.close(); &#125;&#125;/** * 存储读取到的图片 - docx * @param pictures 图片集 * @param picturePath 图片保存路径 * @param imgNum 确定图片集中的某一张图片 * @return 图片全路径 * @throws IOException */public static String savePictureDocx(List&lt;XWPFPictureData&gt; pictures, String picturePath,int imgNum) throws IOException &#123; File pictureFile = new File(picturePath); //保存路径不存在，则创建 if (!pictureFile.exists())&#123; pictureFile.mkdirs(); &#125; List&lt;XWPFPictureData&gt; pictures = para.getDocument().getAllPictures(); if (pictures.size()!=0)&#123; XWPFPictureData picture = pictures.get(imgNum); String rawName = picture.getFileName(); String fileExt = rawName.substring(rawName.lastIndexOf(\".\")); String newName = System.currentTimeMillis() + UUID.randomUUID().toString() + fileExt; String pictureName = picturePath + File.separator + newName; FileOutputStream fos = new FileOutputStream(pictureName); fos.write(picture.getData()); fos.flush(); fos.close(); return pictureName; &#125; return null;&#125;/** * 删除临时存储的图片 * @param pictureName 图片全路径（含文件名） * @return */public static boolean deletePicture(String pictureName) &#123; File pictureFile = new File(pictureName); // 目录此时为空，可以删除 return pictureFile.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"}]},{"title":"用VNC搭建Ubuntu VNC可视化界面","slug":"用VNC搭建Ubuntu VNC可视化界面","date":"2018-12-10T11:48:46.000Z","updated":"2019-01-10T08:08:55.307Z","comments":true,"path":"2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","link":"","permalink":"/2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","excerpt":"","text":"安装配置软件 VNC的安装与配置安装之前先输入（获取最新套件的信息） 1apt-get update 输入以下命令安装VNC，安装过程中需要输入Y来确认 1apt-get install vnc4server 启动VNC（第一次启动需要设置密码） 1vncserver 开机启动请参考：ubuntu-18-04-1-开机启动脚本 设置vncservgnome 桌面环境安装与配置（可直接跳至第3步）安装x－windows的基础 1sudo apt-get install x-window-system-core 安装登录管理器 1sudo apt-get install gdm 安装Ubuntu的桌面 1sudo apt-get install ubuntu-desktop 安装gnome配套软件 1sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal 修改VNC配置文件 1sudo vi ~/.vnc/xstartup 修改为： 1234567891011#!/bin/sh# Uncomment the following two lines for normal desktop:export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrcunset DBUS_SESSION_BUS_ADDRESSgnome-panel &amp;gnmoe-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp; 杀掉原桌面进程，输入命令（其中的:1是桌面号）： 1vncserver -kill :1 输入以下命令生成新的会话： 1vncserver :1 ubuntu卸载gnome桌面（可直接跳至第3步） 之前安装好了ubuntu18.04，本来想装个gnome shell来美化一下桌面，结果出现了开机黑屏（灰屏）的现象，经网上查询发现是显卡驱动在gnome3的环境下产生了不兼容，具体解决方法我还没找到，情急之下只能先卸载掉gnome桌面环境。 卸载掉gnome-shell主程序1sudo apt-get remove gnome-shell 卸载掉gnome1sudo apt-get remove gnome 卸载不需要的依赖关系1sudo apt-get autoremove 彻底卸载删除gnome的相关配置文件1sudo apt-get purge gnome 清理安装gnome时候留下的缓存程序软件包12sudo apt-get autocleansudo apt-get clean ubuntu运行VNC Server无桌面时的解决方案配置vnc server实在是一个特别诡异的事，我在不同的ubuntu机器上配置服务时，总是遇到千奇百怪的问题，大部分情况下比较顺利，将~/.vnc/xstartup最后一句x-window-manager&amp;替换为gnome-session&amp;就能顺利地出现桌面，而有些则不行，需要改为gnome-session --session=ubuntu-2d&amp; 问题而今天遇到的ubuntu 18.04，则死活不行，用realvnc viewer连接之后，只有灰灰的一个背景，没有桌面，没有terminal。 查阅了很多博文，有说需要安装gnome-session-fallback的，有说需要安装gdm的，也有用kde的，除了kde我没有尝试，另外两种验证无效，依然只有一个灰色背景。 最后用xfce4桌面解决，选择些方案一是因为xfce相对较小，gnome-session死活不行的情况下，再将一个kde未免太过兴师动众，xfce我使用过一段时间，是一个相当轻量级的GUI环境，清爽易用，功能一点不含糊。决定之后，一次尝试即成功。 安装xfce1sudo apt-get install gnome-core xfce4 配置编辑~/.vnc/xstartup文件： 12345678#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp; 输入以下命令生成新的会话： 1vncserver :1 本地使用VNC连接 本地安装VNC后，使用ip地址:1（其中的:1是桌面号）的方式连接 输入之前设置的VNC密码后点击连接 附录 下载地址VNC Viewer和VNC Server","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"VNC","slug":"VNC","permalink":"/tags/VNC/"}]},{"title":"Linux下安装Java JDK8","slug":"Linux下安装Java-JDK8","date":"2018-12-10T11:44:56.000Z","updated":"2019-01-10T08:06:43.445Z","comments":true,"path":"2018/12/10/Linux下安装Java-JDK8/","link":"","permalink":"/2018/12/10/Linux下安装Java-JDK8/","excerpt":"","text":"手动下载压缩包安装oracle Java JDK 前往oracle Java官网下载JDK 解压缩到指定目录（以jdk-8u144-linux-x64.tar.gz为例） 创建目录: 1sudo mkdir /usr/lib/jvm 解压缩到该目录: 1sudo tar -zxvf jdk-7u60-linux-x64.gz -C /usr/lib/jvm 修改环境变量: 1sudo vi ~/.bashrc 在文件末尾追加下面内容： 12345#set oracle jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量马上生效： 1source ~/.bashrc 查看java版本，看看是否安装成功： 1java -version","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"}]},{"title":"Linux的使用技巧","slug":"Linux的使用技巧","date":"2018-12-10T11:21:02.000Z","updated":"2019-04-19T01:50:38.918Z","comments":true,"path":"2018/12/10/Linux的使用技巧/","link":"","permalink":"/2018/12/10/Linux的使用技巧/","excerpt":"","text":"修改用户名例：将admin改为test（ubuntu） 修改 /etc/passwd用户信息文件1vim /etc/passwd 123#admin:x:1001:1001:admin,,,:/home/admin:/bin/bash#把用户名admin改成rest#test:x:1001:1001:admin,,,:/home/test:/bin/bash 注： 12admin:x:1001:1001:admin,,,:/home/admin:/bin/bash中的admin,,,不可修改，若修改后重启，你将会因为密码错误而不能成功登入系统（只得去机房重新注册用户了） 修改 /etc/shadow用户密码文件1vim /etc/shadow 123#admin:Dnakfw28zf38w:8764:0:168:7:::#由于密码加密方式存放，只修改用户名即可（密码不变）#test:Dnakfw28zf38w:8764:0:168:7::: 再修改 /etc/group用户组文件1vim /etc/group 123#admin:x:1:root,bin,admin#修改admin组为test组#test:x:1:root,bin,test 修改用户的家目录1mv /home/admin /home/test xx is not in the sudoers file 问题解决首先利用whereis 命令查找sudoers配置文件的目录（默认会在/etc/sudoers) 1whereis sudoers 然后就可以利用vi编辑器来把用户添加到sudoers之中 1vi /etc/sudoers 然后找到root ALL=(ALL) ALL 或者 root ALL=(ALL:ALL) ALL所在的位置，把所要添加的用户添加到文件之中 下面是添加完的结果。 1234Allow root to run any commands anywhereroot ALL=(ALL) ALLmaliang ALL=(ALL) ALL（这一行是添加的内容，maliang是我的用户名） 修改用户密码在终端运行 1passwd username 123456改变口令为 username。(当前)UNIX 口令：&lt;输入现在的密码&gt; 输入新的 UNIX 口令： &lt;输入新密码&gt; 重新输入新的 UNIX 口令：&lt;重新输入新密码&gt;passwd：已成功更新密码 开启root用户和使用root用户登陆 以普通用户登录系统，创建root用户的密码 1sudo passwd root 修改文件sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf文件，增加两行： 12greeter-show-manual-login=trueallow-guest=false 保存 修改/etc/pam.d/gdm-autologin、/etc/pam.d/gdm-password文件和/root/.profile文件（ubuntu-18.04需要此步骤） 1vi /etc/pam.d/gdm-autologin 注释掉：auth required pam_succeed_if.so user != root quiet_success 保存 1vi /etc/pam.d/gdm-password 注释掉：auth required pam_succeed_if.so user != root quiet_success 保存 1vim /root/.profile 将文件末尾的mesg n || true这一行修改成tty -s &amp;&amp; mesg n || true 保存 重启系统，输入root用户名和密码，登录系统 解决Ubuntu18.04不能用Xshell使用root用户登录 今天使用Xshell6连接Ubuntu18.04时，连接普通用户可以，但是连接root用户不行（但是实体机或者虚拟机可以root用户登录） 解决方案是： 在Ubuntu18.04中 修改 /etc/ssh/sshd_config这个文件： 1vim /etc/ssh/sshd_config 这是没修改前的： 123456789...# Authentication:#LoginGraceTime 2m#PermitRootLogin prohibit-password#StrictModes yes#MaxAuthTries 6#MaxSessions 10... 修改后的： 12345678910...# Authentication:LoginGraceTime 2m#PermitRootLogin prohibit-passwordPermitRootLogin yesStrictModes yes#MaxAuthTries 6#MaxSessions 10... 然后再在终端输入一下命令：/etc/init.d/ssh restart 来重启ssh服务 重新使用root连接，就可以了 找出文件所在的位置1whereis sudoers（你要找的文件名） linux find 命令查找文件和文件夹查找目录：find /（查找目录范围） -name &#39;查找关键字&#39; -type d查找文件：find /（查找目录范围） -name &#39;查找关键字&#39; -print 查看端口占用并杀死(kill)1234# 查看sudo netstat -tlnp|grep 9090# 查看ps aux|grep yum 12# 杀死kill -9 31540 如何从Yum库下载rpm包但不安装方法一（推荐） 12# 将一个包（包含所有依赖）下载到一个指定的目录(如/opt/gccmkdir/)：yum install -y gcc --downloadonly --downloaddir=/opt/gccmkdir/ 方法二 12# --resolve 表示为下载依赖yumdownloader lsof --resolve --destdir=/data/mydepot/ 方法三（推荐） 12345# 把/etc/yum.conf配置中的keepcache=0参数修改为keepcache=1# 再yum 下载：yum install -y gcc#默认情况下，RPM包会保存在下面的目录中:/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages apt-get 与 yum安装有啥区别rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 1234yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：安装：yum install &lt;package_name&gt; 卸载：yum remove &lt;package_name&gt; 更新：yum update &lt;package_name&gt; 1234apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理：安装：apt-get install &lt;package_name&gt; 卸载：apt-get remove &lt;package_name&gt; 更新：apt-get update &lt;package_name&gt; 安装rpm包进入系统下存放对应.rpm文件的目录，执行 12cd /opt/gccmkdir/rpm -Uvh *.rpm --nodeps --force 注：rpm -Uvh *.rpm –nodeps –force -Uvh就是升级软件包–Update *.rpm就是所有的.rpm包； –nodeps就是安装时不检查依赖关系，比如你这个rpm需要A，但是你没装A，这样你的包就装不上，用了–nodeps你就能装上了； –force就是强制安装，比如你装过这个rpm的版本1，如果你想装这个rpm的版本2，就需要用–force强制安装。 查看Linux版本方法方法一 123456# lsb_release -aLSB Version: :core-3.1-ia32:core-3.1-noarch:graphics-3.1-ia32:graphics-3.1-noarchDistributor ID: CentOSDescription: CentOS release 5.4 (Final)Release: 5.4Codename: Final 方法二 12# cat /etc/redhat-releaseCentOS release 5.4 (Final) 方法三 12# rpm -q centos-releasecentos-release-5-4.el5.centos.1 查看物理CPU个数、核数、逻辑CPU个数、CPU信息（型号）、内存信息1234567891011121314151617# 总核数 = 物理CPU个数 * 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数# 查看物理CPU个数cat /proc/cpuinfo| grep \"physical id\"| sort| uniq| wc -l# 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep \"cpu cores\"| uniq# 查看逻辑CPU的个数cat /proc/cpuinfo| grep \"processor\"| wc -l# 查看CPU信息（型号）cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c# 查看内 存信息cat /proc/meminfo linux运行jar包要运行java的项目需要先将项目打包成war包或者jar包，打包成war包需要将war包部署到tomcat服务器上才能运行。而打包成jar包可以直接使用java命令执行。在linux系统中运行jar包主要有以下四种方式。 1java -jar XXX.jar 这是最基本的jar包执行方式，但是当我们用ctrl+c中断或者关闭窗口时，程序也会中断执行。 1java -jar XXX.jar &amp; &amp;代表在后台运行，使用ctrl+c不会中断程序的运行，但是关闭窗口会中断程序的运行。 1nohup java -jar XXX.jar &amp; 使用这种方式运行的程序日志会输出到当前目录下的nohup.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 1nohup java -jar XXX.jar &gt;temp.out &amp; ‘&gt;temp.out’的意思是将日志输出重定向到temp.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 XShell上传、下载本地文件到linux服务器在linux主机上，安装上传下载工具包rz及sz; 如果不知道你要安装包的具体名称，可以使用yum provides */name 进行查找系统自带软件包的信息 123456[root@host ~]# yum provides */rz...lrzsz-0.12.20-36.el7.x86_64 : The lrz and lsz modem communications programsRepo : baseMatched from:Filename : /usr/bin/rz 一般会列出软件包的名称及版本，还有安装路径；查询到软件包名后，使用yum install -y 包名 进行安装。 lrzsz包安装完成后包括上传rz、下载sz命令 1[root@host ~]# yum install -y lrzsz 上传命令为rz；下再命令为sz 12#上传（windows-&gt;linux）文件-弹出窗口选择需要上传的文件[root@host ~]# rz 12#指定下载（linux-&gt;windows）哪个文件-弹出窗口选择需要保存的路径[root@host ~]# sz 文件名称 ubuntu安装ssh服务SSH分客户端openssh-client和openssh-server 如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo apt-get install openssh-client） 如果要使本机开放SSH服务就需要安装openssh-serversudo（apt-get install openssh-server） 1apt-get install openssh-server 有时候当你执行sudo apt-get XXX这种命令时出现类似下面的输出错误： 12E: Could not get lock /var/lib/dpkg/lock - open (11 Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/) is another process using it? 或者 12345E: Could not ge lock /var/lib/apt/lists/lock - open (11: Resource temporarilyunavailable)E: Unable to lock directory /var/lib/apt/lists/ E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解释 出现这个问题的原因是，还有一个线程在使用apt-get进行下载的操作。但是奇怪的是，我就是没有找到其他使用了apt-get指令的终端界面。那么如何解决这个问题呢，难道要重新启动电脑吗，重启电脑是可以解决这个问题，但是我接下来教你的方法，才是真正的解决方法。 解决办法 先搜索所有运行着的线程 1ps -A | grep apt-get 你会得到类似下面的输出： 123root 752 0.0 0.0 4508 1628 ? Ss 01:13 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily_apt 2098 0.1 0.1 49572 5524 ? S 01:18 0:06 /usr/lib/apt/methods/httpaobo 4425 0.0 0.0 18484 980 pts/1 S+ 02:13 0:00 grep --color=auto apt 第2列就是线程号(kill processnumber)。我们将apt相关的进程给关闭掉，需要使用sudo权限： 1sudo kill 2098 输出： bash: kill: (2098) - Operation not permitted 然后确认sshserver是否启动了： 1ps -e |grep ssh 如果看到sshd那说明ssh-server已经启动了 CentOS7中找不到ifconfig和netstat命令把net-tools包装上就好了 1yum install net-tools 用ifconfig或者ip a命令，获取不到IP地址问题描述：用ifconfig或者ip a命令，获取不到ip地址，即网卡未启动，无法用Xshell远程连接。 解决方案： 进入/etc/sysconfig/network-scripts目录，发现有一个或多个ifcfg-...，即网卡（驱动）存在但未启用。 1ls /etc/sysconfig/network-scripts 修改/etc/sysconfig/network-scripts/ifcfg-...文件， 把ONBOOT=no改为ONBOOT=yes保存退出wq 123vi /etc/sysconfig/network-scripts/ifcfg-em1...# 把`ONBOOT=no`改为`ONBOOT=yes`保存退出 service network restart重启。出现： 1Restarting network (via systemctl): [ 确定 ] OK 输入ifconfig或者ip a命令，出现ip地址。用Xshell连接成功。 CentOS下彻底删除MySQL和重新安装MySQL删除MySQL12345yum remove mysql mysql-server mysql-libs mysql-server;find / -name mysql 将找到的相关东西delete(rm -rf ...)掉；rpm -qa|grep mysql(查询出来的东东yum remove掉) 安装MySQL1yum install mysql mysql-server mysql-libs mysql-server 如何判断Linux是32位还是64位方法1：getconf LONG_BIT 查看 1getconf LONG_BIT 方法2：uname命令查看 12uname -auname -m 方法3: arch命令查看 1arch 方法4: file命令查看 12file /sbin/initfile /bin/ls 方法5: 通过查看CPU的信息来判定Linux系统是否是64位操作系统 12# 如果结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bitcat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"/tags/CentOS/"},{"name":"RedHat","slug":"RedHat","permalink":"/tags/RedHat/"}]}]}