{"meta":{"title":"Nan's Blog","subtitle":"弱者才言命，强者只言运！","description":"克己复礼","author":"马亮南生","url":""},"pages":[{"title":"分类","date":"2018-12-06T11:48:02.000Z","updated":"2018-12-10T08:59:19.994Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-06T11:46:40.000Z","updated":"2018-12-10T08:58:50.994Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"文件打包与解压","slug":"文件打包与解压","date":"2018-12-28T03:07:17.000Z","updated":"2018-12-28T04:00:49.280Z","comments":true,"path":"2018/12/28/文件打包与解压/","link":"","permalink":"/2018/12/28/文件打包与解压/","excerpt":"","text":"文件打包123456789101112131415161718192021222324252627282930313233/** * 文件打包 * 将传递过来的文件列表写入zip文件 * @param fileList 要打包的文件 * @param zipFileName 打包后的文件名 * @throws IOException */public static void downZipManyFile(List&lt;File&gt; fileList, String zipFileName) throws IOException &#123; BufferedInputStream br = null;//输入流 ZipOutputStream out = null; // 压缩文件输出流 ZipEntry zip = null; //用于表示 ZIP 文件条目。 int size =-1; byte[] buffer = new byte[2048];// 定义缓冲区 if(fileList.size()&gt;0)&#123; out = new ZipOutputStream(new FileOutputStream(zipFileName)); for (int i = 0; i &lt; fileList.size(); i++) &#123; File f =fileList.get(i); zip = new ZipEntry(f.getName()); out.putNextEntry(zip); br = new BufferedInputStream(new FileInputStream(f)); while((size=br.read(buffer))!=-1)&#123; out.write(buffer,0,size); out.flush(); &#125; &#125; zip.clone(); br.close(); out.close(); &#125;&#125; 压缩文件解压包含实现对.zip、.rar、.7z、.tar、.tar.gz的解压 Maven 1234567891011121314151617181920&lt;!-- .7z --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt; &lt;artifactId&gt;sevenzipjbinding-all-platforms&lt;/artifactId&gt; &lt;version&gt;9.20-2.00beta&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .7z end --&gt; &lt;!-- .tar/.tar.gz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.10.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- .tar/.tar.gz end --&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337/*功能：多种格式压缩文件解压(.zip、.rar、.7z、.tar、.tar.gz)*///使用gbk编码避免zip解压中文文件名乱码private static final String CHINESE_CHARSET = \"gbk\";//文件读取缓冲区大小private static final int CACHE_SIZE = 1024;//系统类型private static final String WINDOWS=\"windows\";private static final String LINUX=\"linux\";/** * 多种格式压缩文件解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void deCompress(String srcFileName, String destDir)&#123; //存储路径不存在则创建 File dFile=new File(destDir); if (!dFile.exists()) &#123; dFile.mkdirs(); &#125; if (srcFileName.toLowerCase().endsWith(\".zip\")) &#123; unZip(srcFileName, destDir); &#125; else if (srcFileName.toLowerCase().endsWith(\".rar\")) &#123; unRar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".7z\")) &#123; un7Z(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar\")) &#123; unTar(srcFileName, destDir); &#125;else if (srcFileName.toLowerCase().endsWith(\".tar.gz\")) &#123; unTarGz(srcFileName, destDir); &#125;&#125;/** * .zip格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unZip(String srcFileName, String destDir) &#123; try &#123; //解决中文乱码 ZipFile zip = new ZipFile(srcFileName, Charset.forName(CHINESE_CHARSET)); //循环遍历 for (Enumeration&lt;? extends ZipEntry&gt; entries = zip.entries(); entries.hasMoreElements();) &#123; ZipEntry entry = entries.nextElement(); String zipEntryName = entry.getName(); InputStream in = zip.getInputStream(entry); String outPath = (destDir +\"/\"+ zipEntryName).replaceAll(\"\\\\*\", \"/\"); // 判断路径是否存在,不存在则创建文件路径 File file = new File(outPath.substring(0, outPath.lastIndexOf('/'))); if (!file.exists()) &#123; file.mkdirs(); &#125; // 判断文件全路径是否为文件夹,如果是上面已经上传,不需要解压 if (new File(outPath).isDirectory()) &#123; continue; &#125; FileOutputStream out = new FileOutputStream(outPath); byte[] buf = new byte[CACHE_SIZE]; int len; while ((len = in.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; in.close(); out.close(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;/** * .rar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unRar(String srcFileName, String destDir)&#123; String cmd = null; String unRarCmd = null; try &#123; if (systemType().equals(WINDOWS)) &#123; //解压模板命令 unRarCmd = \"F:\\\\Program Files (x86)\\\\WinRAR\\\\WinRAR.exe x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; else if (systemType().equals(LINUX)) &#123; //解压模板命令 unRarCmd = \"unrar x \"; //构建解压命令 cmd = unRarCmd + srcFileName + \" \" + destDir; &#125; //构造运行对象 Runtime rt = Runtime.getRuntime(); //在单独的进程中执行指定的字符串命令。 rt.exec(cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * .7z格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void un7Z(String srcFileName, String destDir)&#123; RandomAccessFile randomAccessFile = null; IInArchive inArchive = null; try &#123; randomAccessFile = new RandomAccessFile(srcFileName, \"r\"); inArchive = SevenZip. openInArchive(null,new RandomAccessFileInStream(randomAccessFile)); ISimpleInArchive simpleInArchive = inArchive.getSimpleInterface(); //遍历 for (ISimpleInArchiveItem item : simpleInArchive.getArchiveItems()) &#123; int[] hash = new int[] &#123; 0 &#125;; if (!item.isFolder()) &#123; ExtractOperationResult result; long[] sizeArray = new long[1]; //tarFile是遍历的每一个文件 File tarFile=new File(destDir+File.separator+item.getPath()); //tarFile父目录不存在，则创建 if (!tarFile.getParentFile().exists()) &#123; tarFile.getParentFile().mkdirs(); &#125; //创建tarFile文件 tarFile.createNewFile(); result = item.extractSlow(new ISequentialOutStream() &#123; public int write(byte[] data) throws SevenZipException &#123; FileOutputStream fos=null; try &#123; fos = new FileOutputStream(tarFile.getAbsolutePath()); //将数据写入fos fos.write(data); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; hash[0] ^= Arrays.hashCode(data); sizeArray[0] += data.length; return data.length; &#125; &#125;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; finally &#123; if (inArchive != null) &#123; try &#123; inArchive.close(); &#125; catch (SevenZipException e) &#123; e.printStackTrace(); &#125; &#125; if (randomAccessFile != null) &#123; try &#123; randomAccessFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * .tar格式解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTar(String srcFileName, String destDir)&#123; FileInputStream fis = null; OutputStream fos = null; TarInputStream tarInputStream = null; try &#123; fis = new FileInputStream(new File(srcFileName)); tarInputStream = new TarInputStream(fis, CACHE_SIZE); TarEntry entry = null; while(true)&#123; entry = tarInputStream.getNextEntry(); if( entry == null)&#123; break; &#125; if(entry.isDirectory())&#123; System.out.println(entry.getName()); createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; fos = new FileOutputStream(new File(destDir + File.separator + entry.getName())); int count; byte data[] = new byte[CACHE_SIZE]; while ((count = tarInputStream.read(data)) != -1) &#123; fos.write(data, 0, count); &#125; fos.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fis != null)&#123; fis.close(); &#125; if(fos != null)&#123; fos.close(); &#125; if(tarInputStream != null)&#123; tarInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * .tar.gz解压 * @param srcFileName 源文件全路径 * @param destDir 解压后存储路径 */public static void unTarGz(String srcFileName, String destDir)&#123; FileInputStream fileInputStream = null; BufferedInputStream bufferedInputStream = null; GZIPInputStream gzipIn = null; TarInputStream tarIn = null; OutputStream out = null; try &#123; fileInputStream = new FileInputStream(new File(srcFileName)); bufferedInputStream = new BufferedInputStream(fileInputStream); gzipIn = new GZIPInputStream(bufferedInputStream); tarIn = new TarInputStream(gzipIn, CACHE_SIZE); TarEntry entry = null; while((entry = tarIn.getNextEntry()) != null)&#123; if(entry.isDirectory())&#123; // 是目录 createDirectory(destDir, entry.getName()); // 创建子目录 &#125;else&#123; // 是文件 File tempFIle = new File(destDir + File.separator + entry.getName()); createDirectory(tempFIle.getParent() + File.separator, null); out = new FileOutputStream(tempFIle); int len =0; byte[] b = new byte[CACHE_SIZE]; while ((len = tarIn.read(b)) != -1)&#123; out.write(b, 0, len); &#125; out.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(out != null)&#123; out.close(); &#125; if(tarIn != null)&#123; tarIn.close(); &#125; if(gzipIn != null)&#123; gzipIn.close(); &#125; if(bufferedInputStream != null)&#123; bufferedInputStream.close(); &#125; if(fileInputStream != null)&#123; fileInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * 构建目录 * @param outputDir 输出目录 * @param subDir 子目录 */private static void createDirectory(String outputDir, String subDir)&#123; File file = new File(outputDir); if(!(subDir == null || subDir.trim().equals(\"\"))) &#123;//子目录不为空 file = new File(outputDir + File.separator + subDir); &#125; if(!file.exists())&#123; if(!file.getParentFile().exists())&#123; file.getParentFile().mkdirs(); &#125; file.mkdirs(); &#125;&#125;/** * 判断程序运行在什么系统上 * @return 系统类型 */public static String systemType() &#123; Properties properties = System.getProperties(); String os = properties.getProperty(\"os.name\"); if (os != null &amp;&amp; os.toLowerCase().contains(WINDOWS))&#123; return WINDOWS; &#125;else if (os != null &amp;&amp; os.toLowerCase().contains(LINUX))&#123; return LINUX; &#125; return null;&#125;public static void main(String[] args) &#123; //deCompress(\"E:/Test/Test01.zip\",\"E:/Test/testZip\"); //deCompress(\"E:/Test/Test02.rar\",\"E:/Test/testRar\"); //deCompress(\"E:/Test/Test03.7z\",\"E:/Test/test7z\"); //deCompress(\"E:/Test/Test04.tar\",\"E:/Test/testTar\"); //deCompress(\"E:/Test/apache-tomcat-9.0.13-src.tar.gz\",\"E:/Test/testTarGz\");&#125; 其它文件操作获取单个文件的所有内容123456789101112131415161718192021222324/** * 获取单个文件的所有内容 * @param fileName 文件全路径 * @return */public static String readToString(String fileName) &#123; try &#123; File file = new File(fileName); Long filelength = file.length(); byte[] filecontent = new byte[filelength.intValue()]; FileInputStream in = new FileInputStream(file); in.read(filecontent); in.close(); return new String(filecontent, encoding); &#125; catch (FileNotFoundException e) &#123; logger.error(\"该文件不存在或路径错误\",e); e.printStackTrace(); return null; &#125; catch (IOException e) &#123; logger.error(\"读取文件出错\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的文件名列表(全路径)123456789101112131415161718192021222324252627282930/** * 获取多个文件文件列表(全路径) * @param fileDir 文件夹路径 * @param picturePath 图片相对路径 * @param request * @return 返回带域名的文件路径 */public static List&lt;String&gt; readToListPath(String fileDir, String picturePath, HttpServletRequest request) &#123; //获取带部署环境上下文的域名 StringBuffer url = request.getRequestURL(); String tempContextUrl = url .delete(url.length() - request.getRequestURI().length(), url.length()) .append(request.getContextPath()).toString(); List&lt;String&gt; fileNameList = new ArrayList&lt;&gt;(); try &#123; List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); if (fileList.size()==0)&#123; return fileNameList; &#125; for (File f1 : fileList) &#123; fileNameList.add(tempContextUrl+picturePath+\"/\"+f1.getName()); &#125; return fileNameList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件文件列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 获取多个文件的内容列表123456789101112131415161718192021/** * 获取多个文件内容列表 * @param fileDir 文件所在路径 * @return */public static List&lt;String&gt; readToListAndString(String fileDir)&#123; try &#123; List&lt;String&gt; fileContentList = new ArrayList&lt;&gt;(); List&lt;File&gt; fileList = getFilePath(fileDir,\"\"); for (File file : fileList)&#123; if(!readToString(file.toString()).equals(\"\"))&#123; fileContentList.add(readToString(file.toString())); &#125; &#125; return fileContentList; &#125;catch (Exception e)&#123; logger.error(\"获取多个文件内容列表异常\",e); e.printStackTrace(); return null; &#125;&#125; 递归获取目录下的所有文件123456789101112131415161718192021222324252627282930/** * 递归获取目录下的所有文件 * @param fileDir 文件所在路径 * @return */public static List&lt;File&gt; getFilePath(String fileDir,String endsWith)&#123; List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); File file = new File(fileDir); File[] files = file.listFiles();// 获取目录下的所有文件或文件夹 if (files == null) &#123;// 如果目录为空，返回空 return null; &#125; // 遍历，目录下的所有文件 for (File f : files) &#123; if (f.isFile()) &#123; if(endsWith.equals(\"\")||endsWith==null)&#123; fileList.add(f); &#125;else &#123; if (f.getName().endsWith(endsWith))&#123; fileList.add(f); &#125; &#125; &#125; else if (f.isDirectory()) &#123; getFilePath(f.getAbsolutePath(),endsWith); &#125; &#125; return fileList;&#125; 递归删除文件（删除文件夹）12345678910111213141516171819/** * 递归删除目录下的所有文件及子目录下所有文件 * @param dir 目录路径 * @return */public static boolean deleteDir(File dir) &#123; if (dir.isDirectory()) &#123; String[] children = dir.list(); //递归删除目录中的子目录下 for (int i=0; i&lt;children.length; i++) &#123; boolean success = deleteDir(new File(dir, children[i])); if (!success) &#123; return false; &#125; &#125; &#125; // 目录此时为空或者是文件，可以删除 return dir.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"文件打包","slug":"文件打包","permalink":"/tags/文件打包/"},{"name":"压缩文件解压","slug":"压缩文件解压","permalink":"/tags/压缩文件解压/"}]},{"title":"linux环境下安装 openOffice 并启动服务","slug":"linux环境下安装-openOffice-并启动服务","date":"2018-12-25T02:07:07.000Z","updated":"2018-12-25T02:42:07.799Z","comments":true,"path":"2018/12/25/linux环境下安装-openOffice-并启动服务/","link":"","permalink":"/2018/12/25/linux环境下安装-openOffice-并启动服务/","excerpt":"","text":"背景故事这两天遇到一个大坑，客户要做office 文档在线预览功能，于是乎就要把office文档转换成pdf交给前端显示。 在某度找了一圈都说openOffice+jodconverter 可以搞定这个事情。代码倒是很好找，不过版本很多，各类jar包也很多，但尝试下来发现，转化效果很一般，复杂的excel也无法成功。有同事建议放到服务器上效果可能好些，于是就开始折腾在服务器上安装OpenOffice这个事情。网上各种找大神的博文，发现安装起来不是很顺畅，就写了这篇随笔，记录一下，遇到的问题，方便自己以后查看。 ​ openOffice转转word文档效果不错，转Excel的话就真的效果不行，简单的Excel能处理处理，复杂的就很慢很慢，而且效果极差。再说，实际上微软自己的office软件转pdf的效果也很差。 操作步骤 http://www.openoffice.org/zh-cn/download/ 去官网链接下载linux版本的openOffice 以4.1.6 版本为例。 将压缩包上传至服务器上，并进行解压安装。 12345tar -zxvf 对应的压缩包名字cd 进入解压后的 /zh-cn/RPMSyum localinstall *.rpmcd desktop-integrationrpm -ivh openoffice4.1.6-redhat-menus-4.1.6-9789.noarch.rpm 默认会安装在/opt目录下。 启动服务 123/opt/openoffice4/program/soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard 临时启动nohup /opt/openoffice4/program/soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard &amp; 后台启动 端口号根据自己项目实际来确定。 后台启动会一直占用内存，据各路大神说 大概100M，我自己没测过具体值不清楚。 有的程序是需要预先启动openOffice 服务的，有的则在代码里自己启动服务。 .查看进程 1netstat -lnp |grep 端口号 大概显示成这样就算启动完了。 1tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 14362/soffice.bin 问题装完openoffice后启动服务可能会报错：no suitable windowing system found, exiting 从字面上的意思就是缺少一个窗口化的系统。所以就安装一个。 1yum groupinstall &quot;X Window System&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"openOffice","slug":"openOffice","permalink":"/tags/openOffice/"},{"name":"安装","slug":"安装","permalink":"/tags/安装/"}]},{"title":"将Word(.doc)里的图片替换成文本","slug":"将Word-doc-里的图片替换成文本","date":"2018-12-20T03:23:24.000Z","updated":"2018-12-20T03:52:59.629Z","comments":true,"path":"2018/12/20/将Word-doc-里的图片替换成文本/","link":"","permalink":"/2018/12/20/将Word-doc-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖1234567891011121314151617181920212223242526&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt;&lt;!-- Jsoup-用以解析HTML --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Jsoup-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public static void main(String argv[]) &#123; try &#123; //源文件全路径 String oldFileName = \"D:/Test/ml/test.doc\"; //目标文件全路径 String newFileName = \"D:/Test/ml/html_to_word.doc\"; //构造HTML生成全路径 String temporary = new File(oldFileName).getParent()+File.separator+\"temporary.html\"; //读取DOC生成获得html内容和图片集 Map&lt;String,Object&gt; map = convert2Html(oldFileName); //取得图片集 List&lt;String&gt; listPics = (List&lt;String&gt;) map.get(\"listPics\"); //取得生成的html内容 String htmlContent = (String) map.get(\"htmlContent\"); for (String pic : listPics)&#123; //有后缀名的图片才进行识别 if (pic.matches(\"(?!(\\\\.jpg|\\\\.png|\\\\.jpeg|\\\\.emf|\\\\.bmp|\\\\.gig)).+ ?(\\\\.jpg|\\\\.png|\\\\.jpeg|\\\\.emf|\\\\.bmp|\\\\.gig)\"))&#123; //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //文字替换图片 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;\"); &#125;else &#123;/*因为识别出来的非图片格式（即：无后缀名）的图片再放回doc时会出现图片异常显示， 所以以\"&lt;span&gt;&lt;/span&gt;\"进行占位*/ //以下两行代码是构造HTML中的图片标记（即：&lt;img ...&gt;） String temp = htmlContent.substring( htmlContent.indexOf(\"&lt;img src=\\\"\"+pic.replace(\"\\\\\",\"/\")+\"\\\"\")); temp = temp.substring(0,temp.indexOf(\"&gt;\")+1); //占位 htmlContent = htmlContent.replaceAll(temp,\"&lt;span&gt;&lt;/span&gt;\"); &#125; &#125; //输出HTML文件 writeFile(htmlContent, temporary); //HTML转Doc html2Doc(temporary,newFileName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 输出HTML文件 * @param content 从doc读取生成的html文本 * @param path 目标文件全路径 */public static void writeFile(String content, String path) &#123; FileOutputStream fos = null; BufferedWriter bw = null; org.jsoup.nodes.Document doc = Jsoup.parse(content); String styleOld=doc.getElementsByTag(\"style\").html(); //统一字体格式为宋体 styleOld=styleOld.replaceAll(\"font-family:.+(?=;\\\\b)\", \"font-family:SimSun\"); doc.getElementsByTag(\"head\").empty(); doc.getElementsByTag(\"head\").append(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); doc.getElementsByTag(\"head\").append(\" &lt;style type=\\\"text/css\\\"&gt;&lt;/style&gt;\"); doc.getElementsByTag(\"style\").append(styleOld); /*正则表达式查询字体内容：font-family:.+(?=;\\b)*/ content=doc.html(); content=content.replace(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;\", \"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;&lt;/meta&gt;\"); try &#123; File file = new File(path); fos = new FileOutputStream(file); bw = new BufferedWriter(new OutputStreamWriter(fos,\"UTF-8\")); bw.write(content); &#125; catch (FileNotFoundException fnfe) &#123; fnfe.printStackTrace(); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; finally &#123; try &#123; if (bw != null) bw.close(); if (fos != null) fos.close(); &#125; catch (IOException ie) &#123; &#125; &#125;&#125;/** * 读取DOC生成获得html内容和图片集 * @param fileName 源文件全路径 * @return 返回的map中包含html内容和图片集 * @throws Exception */public static Map&lt;String,Object&gt; convert2Html(String fileName) throws Exception &#123; //存放html内容和图片集 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //保存图片集 List&lt;String&gt; listPics = new ArrayList&lt;&gt;(); //构造提取出来的图片保存路径以及HTML中&lt;img&gt;的图片源路径 String imgPath = new File(fileName).getParent()+File.separator+\"img\"+File.separator; File file = new File(imgPath); //不存在，则创建 if (!file.exists())&#123; file.mkdirs(); &#125; HWPFDocument wordDocument = new HWPFDocument(new FileInputStream(fileName)); //WordToHtmlUtils.loadDoc(new FileInputStream(inputFile)); WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter( DocumentBuilderFactory.newInstance().newDocumentBuilder() .newDocument()); wordToHtmlConverter.setPicturesManager( new PicturesManager() &#123; public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches ) &#123; return imgPath.replace(\"\\\\\",\"/\") + suggestedName; &#125; &#125; ); wordToHtmlConverter.processDocument(wordDocument); //保存图片 List pics=wordDocument.getPicturesTable().getAllPictures(); if(pics!=null)&#123; for(int i=0;i&lt;pics.size();i++)&#123; Picture pic = (Picture)pics.get(i); try &#123; String picAbsolutePath = imgPath + pic.suggestFullFileName(); //将图片全路径存入listPics listPics.add(picAbsolutePath); pic.writeImageContent(new FileOutputStream(picAbsolutePath)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Document htmlDocument = wordToHtmlConverter.getDocument(); ByteArrayOutputStream out = new ByteArrayOutputStream(); DOMSource domSource = new DOMSource(htmlDocument); StreamResult streamResult = new StreamResult(out); TransformerFactory tf = TransformerFactory.newInstance(); Transformer serializer = tf.newTransformer(); serializer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); serializer.setOutputProperty(OutputKeys.INDENT, \"yes\"); serializer.setOutputProperty(OutputKeys.METHOD, \"HTML\"); serializer.transform(domSource, streamResult); out.close(); String htmlContent=new String(out.toByteArray()); //替换UEditor无法识别的转义字符 htmlContent=htmlContent.replaceAll(\"&amp;ldquo;\",\"\\\"\").replaceAll(\"&amp;rdquo;\",\"\\\"\") .replaceAll(\"&amp;mdash;\",\"-\"); map.put(\"htmlContent\",htmlContent); map.put(\"listPics\",listPics); return map;&#125;/** * html转doc * @param source * @param target * @throws Exception */public static void html2Doc(String source , String target) throws Exception &#123; //创建 POIFSFileSystem 对象 POIFSFileSystem poifs = new POIFSFileSystem(); //获取DirectoryEntry DirectoryEntry directory = poifs.getRoot(); //创建输出流 OutputStream out = new FileOutputStream(target); try &#123; //创建文档,1.格式\"WordDocument\",2.HTML文件输入流 directory.createDocument(\"WordDocument\", new FileInputStream(source)); //写入 poifs.writeFilesystem(out); //释放资源 out.close(); System.out.println(\"success\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"},{"name":"Jsoup","slug":"Jsoup","permalink":"/tags/Jsoup/"}]},{"title":"OpenOffice-实现文件格式之间的转换.md","slug":"OpenOffice-实现文件格式之间的转换","date":"2018-12-18T11:10:47.000Z","updated":"2018-12-18T12:50:46.786Z","comments":true,"path":"2018/12/18/OpenOffice-实现文件格式之间的转换/","link":"","permalink":"/2018/12/18/OpenOffice-实现文件格式之间的转换/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iTextPDF-实现向PDF追加内容","slug":"iTextPDF-实现向PDF追加内容","date":"2018-12-18T11:10:03.000Z","updated":"2018-12-18T12:49:51.129Z","comments":true,"path":"2018/12/18/iTextPDF-实现向PDF追加内容/","link":"","permalink":"/2018/12/18/iTextPDF-实现向PDF追加内容/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"将Word(.docx)-里的图片替换成文本","slug":"将Word-docx-里的图片替换成文本","date":"2018-12-18T11:08:31.000Z","updated":"2018-12-25T03:01:54.817Z","comments":true,"path":"2018/12/18/将Word-docx-里的图片替换成文本/","link":"","permalink":"/2018/12/18/将Word-docx-里的图片替换成文本/","excerpt":"","text":"目标：将word里的图片替换成文本流程、思想： 读取出Word中的图片 - 存储读取到的图片（提供图片识别原） - 删除Word中的该图片 - 在Word中该图片位置插入替换文字 - 删除存储的图片 Maven依赖12345678910111213141516171819&lt;!-- poi-实现word文件的读取和修改等操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2007版（.docx） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 针对于2003版（.doc） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- poi-end --&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public static void main(String[] args) throws Exception &#123; textReplacePhoto(\"D:\\\\Test\\\\原报格式样例3.docx\", \"D:\\\\Test\\\\原报格式样例3-1.docx\",\"D:/Test/img\");&#125;/** * 将word里的图片全部替换成文本 * @param oldFileName 传入原文件的全路径（含文件名） * @param newFileName 保存修改后文件的全路径（含文件名） * @param picturePath 读取出来的图片保存路径 * @throws Exception */public static void textReplacePhoto(String oldFileName, String newFileName, String picturePath) throws Exception &#123; File newFile = new File(newFileName.replace(new File(newFileName).getName(),\"\")); //保存路径不存在，则创建 if (!newFile.exists())&#123; newFile.mkdirs(); &#125; if (oldFileName.endsWith(\".docx\"))&#123; //.docx文件的处理方法 //为了确定图片集中的某一张图片 int imgNum=0; //创建输入流 InputStream oldIs = new FileInputStream(oldFileName); //创建输出流 OutputStream newOs = new FileOutputStream(newFileName); //创建一个XWPFDocument XWPFDocument docx = new XWPFDocument(oldIs); //获取到该文档的所有段落集 List&lt;XWPFParagraph&gt; paras = docx.getParagraphs(); //获取到该文档的所有图片集 List&lt;XWPFPictureData&gt; pictures = docx.getAllPictures(); for (XWPFParagraph para:paras)&#123; //段落中所有XWPFRun List&lt;XWPFRun&gt; runList = para.getRuns(); for (int i=0;i&lt;runList.size();i++) &#123; XWPFRun run=runList.get(i); //判断该段落是否是图片 if (!run.getEmbeddedPictures().isEmpty())&#123; //存储读取到的图片,并获取图片全路径 String pictureName=savePictureDocx(pictures,picturePath,imgNum++); //实际有图片才进行以下操作 if (pictureName!=null)&#123; //删除图片 para.removeRun(i); //插入文字 para.insertNewRun(i).setText(\"&#123;&#123;title&#125;&#125;\"); //删除图片 deletePicture(pictureName); &#125; &#125; &#125; &#125; docx.write(newOs); docx.close(); oldIs.close(); newOs.flush(); newOs.close(); &#125;&#125;/** * 存储读取到的图片 - docx * @param pictures 图片集 * @param picturePath 图片保存路径 * @param imgNum 确定图片集中的某一张图片 * @return 图片全路径 * @throws IOException */public static String savePictureDocx(List&lt;XWPFPictureData&gt; pictures, String picturePath,int imgNum) throws IOException &#123; File pictureFile = new File(picturePath); //保存路径不存在，则创建 if (!pictureFile.exists())&#123; pictureFile.mkdirs(); &#125; List&lt;XWPFPictureData&gt; pictures = para.getDocument().getAllPictures(); if (pictures.size()!=0)&#123; XWPFPictureData picture = pictures.get(imgNum); String rawName = picture.getFileName(); String fileExt = rawName.substring(rawName.lastIndexOf(\".\")); String newName = System.currentTimeMillis() + UUID.randomUUID().toString() + fileExt; String pictureName = picturePath + File.separator + newName; FileOutputStream fos = new FileOutputStream(pictureName); fos.write(picture.getData()); fos.flush(); fos.close(); return pictureName; &#125; return null;&#125;/** * 删除临时存储的图片 * @param pictureName 图片全路径（含文件名） * @return */public static boolean deletePicture(String pictureName) &#123; File pictureFile = new File(pictureName); // 目录此时为空，可以删除 return pictureFile.delete();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"POI","slug":"POI","permalink":"/tags/POI/"},{"name":"Word","slug":"Word","permalink":"/tags/Word/"}]},{"title":"用VNC搭建Ubuntu VNC可视化界面","slug":"用VNC搭建Ubuntu VNC可视化界面","date":"2018-12-10T11:48:46.000Z","updated":"2018-12-10T12:01:46.541Z","comments":true,"path":"2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","link":"","permalink":"/2018/12/10/用VNC搭建Ubuntu VNC可视化界面/","excerpt":"","text":"安装配置软件 VNC的安装与配置安装之前先输入（获取最新套件的信息） 1apt-get update 输入以下命令安装VNC，安装过程中需要输入Y来确认 1apt-get install vnc4server 启动VNC（第一次启动需要设置密码） 1vncserver 设置vncserver开机启动（待完善…） 设置启动脚本 123sudo touch /etc/init.d/vncserversudo chmod +x /etc/init.d/vncserversudo vi /etc/init.d/vncserver 写入以下内容： 12345678910111213141516171819202122232425#!/bin/bash ### BEGIN INIT INFO# Provides: vnc4server# Required-Start: $local_fs $network# Required-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: VNC# Description: VNC Service### END INIT INFOcase &quot;$1&quot; instart) #su -c &quot;vncserver -depth 32 -geometry 1024x768&quot; root su -c &quot;vncserver -geometry 1440x900&quot; username #su -c &quot;vncserver&quot; root ;;stop) vncserver -kill :1 ;;*) echo $&quot;Usage: $0 &#123;start|stop&#125;&quot;exit 1esacEOF 将它加入启动项将它加入启动项 1update-rc.d vncserver defaults 99 gnome 桌面环境安装与配置（可直接跳至第3步）安装x－windows的基础 1sudo apt-get install x-window-system-core 安装登录管理器 1sudo apt-get install gdm 安装Ubuntu的桌面 1sudo apt-get install ubuntu-desktop 安装gnome配套软件 1sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal 修改VNC配置文件 1sudo vi ~/.vnc/xstartup 修改为： 1234567891011#!/bin/sh# Uncomment the following two lines for normal desktop:export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrcunset DBUS_SESSION_BUS_ADDRESSgnome-panel &amp;gnmoe-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp; 杀掉原桌面进程，输入命令（其中的:1是桌面号）： 1vncserver -kill :1 输入以下命令生成新的会话： 1vncserver :1 ubuntu卸载gnome桌面（可直接跳至第3步） 之前安装好了ubuntu18.04，本来想装个gnome shell来美化一下桌面，结果出现了开机黑屏（灰屏）的现象，经网上查询发现是显卡驱动在gnome3的环境下产生了不兼容，具体解决方法我还没找到，情急之下只能先卸载掉gnome桌面环境。 卸载掉gnome-shell主程序1sudo apt-get remove gnome-shell 卸载掉gnome1sudo apt-get remove gnome 卸载不需要的依赖关系1sudo apt-get autoremove 彻底卸载删除gnome的相关配置文件1sudo apt-get purge gnome 清理安装gnome时候留下的缓存程序软件包12sudo apt-get autocleansudo apt-get clean ubuntu运行VNC Server无桌面时的解决方案配置vnc server实在是一个特别诡异的事，我在不同的ubuntu机器上配置服务时，总是遇到千奇百怪的问题，大部分情况下比较顺利，将~/.vnc/xstartup最后一句x-window-manager&amp;替换为gnome-session&amp;就能顺利地出现桌面，而有些则不行，需要改为gnome-session --session=ubuntu-2d&amp; 问题而今天遇到的ubuntu 18.04，则死活不行，用realvnc viewer连接之后，只有灰灰的一个背景，没有桌面，没有terminal。 查阅了很多博文，有说需要安装gnome-session-fallback的，有说需要安装gdm的，也有用kde的，除了kde我没有尝试，另外两种验证无效，依然只有一个灰色背景。 最后用xfce4桌面解决，选择些方案一是因为xfce相对较小，gnome-session死活不行的情况下，再将一个kde未免太过兴师动众，xfce我使用过一段时间，是一个相当轻量级的GUI环境，清爽易用，功能一点不含糊。决定之后，一次尝试即成功。 安装xfce1sudo apt-get install gnome-core xfce4 配置编辑~/.vnc/xstartup文件： 12345678#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp; 输入以下命令生成新的会话： 1vncserver :1 本地使用VNC连接 本地安装VNC后，使用ip地址:1（其中的:1是桌面号）的方式连接 输入之前设置的VNC密码后点击连接 附录 下载地址VNC Viewer和VNC Server","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"VNC","slug":"VNC","permalink":"/tags/VNC/"}]},{"title":"Linux下安装Java JDK8","slug":"Linux下安装Java-JDK8","date":"2018-12-10T11:44:56.000Z","updated":"2018-12-10T11:46:35.507Z","comments":true,"path":"2018/12/10/Linux下安装Java-JDK8/","link":"","permalink":"/2018/12/10/Linux下安装Java-JDK8/","excerpt":"","text":"手动下载压缩包安装oracle Java JDK 前往oracle Java官网下载JDK 解压缩到指定目录（以jdk-8u144-linux-x64.tar.gz为例） 创建目录: 1sudo mkdir /usr/lib/jvm 解压缩到该目录: 1sudo tar -zxvf jdk-7u60-linux-x64.gz -C /usr/lib/jvm 修改环境变量: 1sudo vi ~/.bashrc 在文件末尾追加下面内容： 12345#set oracle jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量马上生效： 1source ~/.bashrc 查看java版本，看看是否安装成功： 1java -version","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"}]},{"title":"Linux的使用技巧","slug":"Linux的使用技巧","date":"2018-12-10T11:21:02.000Z","updated":"2018-12-29T02:51:58.752Z","comments":true,"path":"2018/12/10/Linux的使用技巧/","link":"","permalink":"/2018/12/10/Linux的使用技巧/","excerpt":"","text":"Ubuntu 修改用户名（将admin改为test）由于开始装系统时，用户名脑残打错了，后来强迫症想去更改用户名，所以网上找了一个比较详细的方法 修改 /etc/passwd用户信息文件1vim /etc/passwd 123#admin:x:1001:1001:admin,,,:/home/admin:/bin/bash#把用户名admin改成rest#test:x:1001:1001:admin,,,:/home/test:/bin/bash 注： 12admin:x:1001:1001:admin,,,:/home/admin:/bin/bash中的admin,,,不可修改，若修改后重启，你将会因为密码错误而不能成功登入系统（只得去机房重新注册用户了） 修改 /etc/shadow用户密码文件1vim /etc/shadow 123#admin:Dnakfw28zf38w:8764:0:168:7:::#由于密码加密方式存放，只修改用户名即可（密码不变）#test:Dnakfw28zf38w:8764:0:168:7::: 再修改 /etc/group用户组文件1vim /etc/group 123#admin:x:1:root,bin,admin#修改admin组为test组#test:x:1:root,bin,test 修改用户的家目录1mv /home/admin /home/test xx is not in the sudoers file 问题解决首先利用whereis 命令查找sudoers配置文件的目录（默认会在/etc/sudoers) 1whereis sudoers 然后就可以利用vi编辑器来把用户添加到sudoers之中 1vi /etc/sudoers 然后找到root ALL=(ALL) ALL 或者 root ALL=(ALL:ALL) ALL所在的位置，把所要添加的用户添加到文件之中 下面是添加完的结果。 1234Allow root to run any commands anywhereroot ALL=(ALL) ALLmaliang ALL=(ALL) ALL（这一行是添加的内容，maliang是我的用户名） 修改用户密码在终端运行 1passwd username 123456改变口令为 username。(当前)UNIX 口令：&lt;输入现在的密码&gt; 输入新的 UNIX 口令： &lt;输入新密码&gt; 重新输入新的 UNIX 口令：&lt;重新输入新密码&gt;passwd：已成功更新密码 开启root用户和使用root用户登陆 开启root用户1sudo passwd root 使用root用户登陆1sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf 在最后增加greeter-show-manual-login=true保存退出。注销后可看到登陆框已显示，可输入用户名 关闭guest用户1sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf 在最后增加allow-guest=false保存退出。注销后可看到已经没有guest用户登陆的选项。 找出文件所在的位置1whereis sudoers（你要找的文件名） 查看端口占用并杀死(kill)12# 查看sudo netstat -tlnp|grep 9090 12# 杀死kill -9 31540 如何从Yum库下载rpm包但不安装方法一（推荐） 12# 将一个包（包含所有依赖）下载到一个指定的目录(如/opt/gccmkdir/)：yum install -y gcc --downloadonly --downloaddir=/opt/gccmkdir/ 方法二 12# --resolve 表示为下载依赖yumdownloader lsof --resolve --destdir=/data/mydepot/ 方法三（推荐） 12345# 把/etc/yum.conf配置中的keepcache=0参数修改为keepcache=1# 再yum 下载：yum install -y gcc#默认情况下，RPM包会保存在下面的目录中:/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages 安装rpm包进入系统下存放对应.rpm文件的目录，执行 12cd /opt/gccmkdir/rpm -Uvh *.rpm --nodeps --force 注：rpm -Uvh *.rpm –nodeps –force -Uvh就是升级软件包–Update *.rpm就是所有的.rpm包； –nodeps就是安装时不检查依赖关系，比如你这个rpm需要A，但是你没装A，这样你的包就装不上，用了–nodeps你就能装上了； –force就是强制安装，比如你装过这个rpm的版本1，如果你想装这个rpm的版本2，就需要用–force强制安装。 查看Linux版本方法方法一 123456# lsb_release -aLSB Version: :core-3.1-ia32:core-3.1-noarch:graphics-3.1-ia32:graphics-3.1-noarchDistributor ID: CentOSDescription: CentOS release 5.4 (Final)Release: 5.4Codename: Final 方法二 12# cat /etc/redhat-releaseCentOS release 5.4 (Final) 方法三 12# rpm -q centos-releasecentos-release-5-4.el5.centos.1 linux运行jar包要运行java的项目需要先将项目打包成war包或者jar包，打包成war包需要将war包部署到tomcat服务器上才能运行。而打包成jar包可以直接使用java命令执行。在linux系统中运行jar包主要有以下四种方式。 1java -jar XXX.jar 这是最基本的jar包执行方式，但是当我们用ctrl+c中断或者关闭窗口时，程序也会中断执行。 1java -jar XXX.jar &amp; &amp;代表在后台运行，使用ctrl+c不会中断程序的运行，但是关闭窗口会中断程序的运行。 1nohup java -jar XXX.jar &amp; 使用这种方式运行的程序日志会输出到当前目录下的nohup.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。 1nohup java -jar XXX.jar &gt;temp.out &amp; ‘&gt;temp.out’的意思是将日志输出重定向到temp.out文件，使用ctrl+c中断或者关闭窗口都不会中断程序的执行。","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"/tags/技巧/"},{"name":"配置","slug":"配置","permalink":"/tags/配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"Java","slug":"Java","permalink":"/tags/Java/"}]}]}